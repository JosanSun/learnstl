<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>【Parser系列】Lexer I - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.79ee58592781f37f89cf23e10f1f9ff0.css" />
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"26142441":{"title":"【Parser系列】Lexer I","author":"bajdcc","content":"<h2>写在前面</h2><p>代码：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/CParser\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/CParser<i class=\"icon-external\"></i></a></p><p>本节内容效果图：</p><p><img src=\"https://pic4.zhimg.com/v2-7a31bbe400694f30bc5e2f5cb35ba3db_b.png\" data-rawwidth=\"351\" data-rawheight=\"325\" class=\"content_image\" width=\"351\">任务非常简单——识别空格/回车、变量名、数字。</p><h2>准备工作</h2><p><b><u>思考一：类型</u></b></p><p>要解析C语言，那么肯定得考虑基本数据类型了，如int、char等。然而，我们将把每个识别出的token标记一个类型，这是lexer中的类型（用enum表示），故应有一个对应关系。</p><p>所以要完成的第一个任务，创建映射——  <b>从 lexer_t/enum 到 基本数据类型</b>。</p><p>lexer_t如下：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span></span><span class=\"k\">enum</span> <span class=\"n\">lexer_t</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">l_none</span><span class=\"p\">,</span>\n    <span class=\"n\">l_error</span><span class=\"p\">,</span>\n    <span class=\"n\">l_char</span><span class=\"p\">,</span>\n    <span class=\"n\">l_uchar</span><span class=\"p\">,</span>\n    <span class=\"n\">l_short</span><span class=\"p\">,</span>\n    <span class=\"n\">l_ushort</span><span class=\"p\">,</span>\n    <span class=\"n\">l_int</span><span class=\"p\">,</span>\n    <span class=\"n\">l_uint</span><span class=\"p\">,</span>\n    <span class=\"n\">l_long</span><span class=\"p\">,</span>\n    <span class=\"n\">l_ulong</span><span class=\"p\">,</span>\n    <span class=\"n\">l_float</span><span class=\"p\">,</span>\n    <span class=\"n\">l_double</span><span class=\"p\">,</span>\n    <span class=\"n\">l_operator</span><span class=\"p\">,</span>\n    <span class=\"n\">l_keyword</span><span class=\"p\">,</span>\n    <span class=\"n\">l_identifier</span><span class=\"p\">,</span>\n    <span class=\"n\">l_string</span><span class=\"p\">,</span>\n    <span class=\"n\">l_comment</span><span class=\"p\">,</span>\n    <span class=\"n\">l_space</span><span class=\"p\">,</span>\n    <span class=\"n\">l_newline</span><span class=\"p\">,</span>\n    <span class=\"n\">l_end</span><span class=\"p\">,</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>其中l_end作为最后一个元素，起判断出界的作用。</p><p><b>如何完成一个从enum/int到type的映射呢？</b></p><p>假设我写一个函数：  type get_type(lexer_t)，那么这个type是不确定的！什么函数的返回值或者参数可以有多个type呢？想想看！如std::make_shared，std::make_pair，它的参数和返回值类型是可变的，所以解决方案是——类模版。</p><p>所以，写好一个基础类：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"n\">lexer_t</span><span class=\"o\">&amp;gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">base_t</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">using</span> <span class=\"n\">type</span> <span class=\"o\">=</span> <span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>base_t作为判断类型的类模版，它的type成员是关键。</p><p>接下来就是将其特化，为了简单起见，我偷懒用了宏 :)    PS：后面这样的宏会很多，因为我不想写同样的代码。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"cp\">#define DEFINE_BASE_TYPE(t, obj) \\</span>\n<span class=\"cp\">template&amp;lt;&amp;gt; \\</span>\n<span class=\"cp\">struct base_t&amp;lt;t&amp;gt; \\</span>\n<span class=\"cp\">{ \\</span>\n<span class=\"cp\">    using type = obj; \\</span>\n<span class=\"cp\">};</span>\n\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_char</span><span class=\"p\">,</span> <span class=\"kt\">char</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_uchar</span><span class=\"p\">,</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">char</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_short</span><span class=\"p\">,</span> <span class=\"kt\">short</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_ushort</span><span class=\"p\">,</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">short</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_int</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_uint</span><span class=\"p\">,</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_long</span><span class=\"p\">,</span> <span class=\"kt\">long</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_ulong</span><span class=\"p\">,</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_float</span><span class=\"p\">,</span> <span class=\"kt\">float</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_double</span><span class=\"p\">,</span> <span class=\"kt\">double</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_operator</span><span class=\"p\">,</span> <span class=\"n\">operator_t</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_keyword</span><span class=\"p\">,</span> <span class=\"n\">keyword_t</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_identifier</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_string</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_comment</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_space</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"p\">)</span>\n<span class=\"n\">DEFINE_BASE_TYPE</span><span class=\"p\">(</span><span class=\"n\">l_newline</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"p\">)</span>\n\n<span class=\"cp\">#define LEX_T(t) base_t&amp;lt;l_##t&amp;gt;::type</span>\n</code></pre></div><p>现在，我想得到字符串的类型，只要使用base_t&amp;lt;l_string&amp;gt;::type即可，或是宏LEX_T(string)。</p><p><u><b>思考二：识别</b></u></p><p>如何识别空格、变量名、数字呢？这里用到正则表达式——std::regex。关于正则表达式的资料很丰富，这个工具非常有用。</p><p>好了，这里贴出识别的regex：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span>    <span class=\"n\">regex_t</span> <span class=\"n\">r_digit</span><span class=\"p\">{</span> <span class=\"s\">R\"((\\d*\\.?\\d+|\\d+\\.?\\d*)([e][+-]?\\d+)?)\"</span> <span class=\"p\">};</span>\n    <span class=\"n\">regex_t</span> <span class=\"n\">r_alpha</span><span class=\"p\">{</span> <span class=\"s\">R\"([[:alpha:]_]\\w*)\"</span> <span class=\"p\">};</span>\n    <span class=\"n\">regex_t</span> <span class=\"n\">r_space</span><span class=\"p\">{</span> <span class=\"s\">R\"(([ ]+)|((\\r\\n)+)|(\\n+))\"</span> <span class=\"p\">};</span>\n</code></pre></div><ul><li>数字的识别图参考<a href=\"https://zhuanlan.zhihu.com/p/25879478\" class=\"internal\">【LeetCode】065-验证数字 - 知乎专栏</a> ，匹配后用atof转成数字即可<br></li><li>变量名的识别主要是第一位不能是数字</li><li>空格/回车需要精确识别是哪一种，因为是回车的话行数会加一，以便为后期报错提供信息（某行某列出错）</li></ul><br><h2>动手写Lexer</h2><p><b><u>Lexer.h</u></b></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"c1\">// 词法分析</span>\n<span class=\"k\">class</span> <span class=\"nc\">CLexer</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">explicit</span> <span class=\"n\">CLexer</span><span class=\"p\">(</span><span class=\"n\">string_t</span> <span class=\"n\">str</span><span class=\"p\">);</span>\n    <span class=\"o\">~</span><span class=\"n\">CLexer</span><span class=\"p\">();</span>\n\n    <span class=\"c1\">// 外部接口</span>\n<span class=\"cp\">#define DEFINE_LEXER_GETTER(t) LEX_T(t) get_##t();</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">uchar</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">short</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">ushort</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">uint</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">long</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">ulong</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">double</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"k\">operator</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">keyword</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">identifier</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">comment</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">space</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">newline</span><span class=\"p\">)</span>\n<span class=\"cp\">#undef DEFINE_LEXER_GETTER</span>\n\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">lexer_t</span> <span class=\"n\">next</span><span class=\"p\">();</span>\n\n    <span class=\"n\">lexer_t</span> <span class=\"nf\">get_type</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"nf\">get_line</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"nf\">get_column</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"nf\">get_last_line</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"nf\">get_last_column</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n    <span class=\"n\">string_t</span> <span class=\"nf\">current</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n\n    <span class=\"kt\">void</span> <span class=\"n\">move</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">idx</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">inc</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"kt\">bool</span> <span class=\"n\">newline</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">// 内部解析</span>\n    <span class=\"n\">lexer_t</span> <span class=\"nf\">next_digit</span><span class=\"p\">();</span>\n    <span class=\"n\">lexer_t</span> <span class=\"nf\">next_alpha</span><span class=\"p\">();</span>\n    <span class=\"n\">lexer_t</span> <span class=\"nf\">next_space</span><span class=\"p\">();</span>\n\n    <span class=\"kt\">int</span> <span class=\"nf\">local</span><span class=\"p\">();</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"n\">string_t</span> <span class=\"n\">str</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"p\">{</span> <span class=\"mi\">0</span> <span class=\"p\">};</span>\n    <span class=\"kt\">int</span> <span class=\"n\">last_index</span><span class=\"p\">{</span> <span class=\"mi\">0</span> <span class=\"p\">};</span>\n    <span class=\"kt\">int</span> <span class=\"n\">length</span><span class=\"p\">{</span> <span class=\"mi\">0</span> <span class=\"p\">};</span>\n\n    <span class=\"n\">lexer_t</span> <span class=\"n\">type</span> <span class=\"p\">{</span> <span class=\"n\">l_none</span> <span class=\"p\">};</span>\n    <span class=\"kt\">int</span> <span class=\"n\">line</span><span class=\"p\">{</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n    <span class=\"kt\">int</span> <span class=\"n\">column</span><span class=\"p\">{</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n    <span class=\"kt\">int</span> <span class=\"n\">last_line</span><span class=\"p\">{</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n    <span class=\"kt\">int</span> <span class=\"n\">last_column</span><span class=\"p\">{</span> <span class=\"mi\">1</span> <span class=\"p\">};</span>\n\n    <span class=\"k\">struct</span>\n    <span class=\"p\">{</span>\n<span class=\"cp\">#define DEFINE_LEXER_GETTER(t) LEX_T(t) _##t;</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">uchar</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">short</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">ushort</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">uint</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">long</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">ulong</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"kt\">double</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"k\">operator</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">keyword</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">identifier</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">string</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">comment</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">space</span><span class=\"p\">)</span>\n        <span class=\"n\">DEFINE_LEXER_GETTER</span><span class=\"p\">(</span><span class=\"n\">newline</span><span class=\"p\">)</span>\n<span class=\"cp\">#undef DEFINE_LEXER_GETTER</span>\n    <span class=\"p\">}</span> <span class=\"n\">bags</span><span class=\"p\">;</span>\n\n    <span class=\"c1\">// 正则表达式</span>\n    <span class=\"n\">smatch_t</span> <span class=\"n\">sm</span><span class=\"p\">;</span>\n    <span class=\"n\">regex_t</span> <span class=\"n\">r_digit</span><span class=\"p\">{</span> <span class=\"s\">R\"((\\d*\\.?\\d+|\\d+\\.?\\d*)([e][+-]?\\d+)?)\"</span> <span class=\"p\">};</span>\n    <span class=\"n\">regex_t</span> <span class=\"n\">r_alpha</span><span class=\"p\">{</span> <span class=\"s\">R\"([[:alpha:]_]\\w*)\"</span> <span class=\"p\">};</span>\n    <span class=\"n\">regex_t</span> <span class=\"n\">r_space</span><span class=\"p\">{</span> <span class=\"s\">R\"(([ ]+)|((?:\\r\\n)+)|(\\n+))\"</span> <span class=\"p\">};</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>它的构造函数需要一个字符串，那就是所要解析的文本。几处宏是方便实现set_XXX/get_XXX。</p><p>数据成员：</p><ul><li>index / last_index：当前遍历/前次遍历的str的指针</li><li>type：前次识别的类型</li><li>line / last_line：当前/前次 行数</li><li>column / last_column：当前/前次 列数</li></ul><p>方法：</p><ul><li>get_XXX：略</li><li>next：解析下一个token，这是核心功能</li><li>move：识别token后，刷新当前所在位置（某行某列）</li><li>local：返回当前指针指向处的字符，返回int类型是方便兼容ANSI/UNICODE</li><li>next_XXX：识别数字、空格、变量名</li></ul><br><p><b><u>Lexer.cpp</u></b></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"n\">lexer_t</span> <span class=\"n\">CLexer</span><span class=\"o\">::</span><span class=\"n\">next</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">local</span><span class=\"p\">();</span>\n    <span class=\"n\">type</span> <span class=\"o\">=</span> <span class=\"n\">l_error</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">isalpha</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"sc\">'_'</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">type</span> <span class=\"o\">=</span> <span class=\"n\">next_alpha</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">isdigit</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">type</span> <span class=\"o\">=</span> <span class=\"n\">next_digit</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">isspace</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">type</span> <span class=\"o\">=</span> <span class=\"n\">next_space</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">type</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">string_t</span> <span class=\"n\">CLexer</span><span class=\"o\">::</span><span class=\"n\">current</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">switch</span> <span class=\"p\">(</span><span class=\"n\">type</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n    <span class=\"k\">case</span> <span class=\"nl\">l_space</span><span class=\"p\">:</span>\n    <span class=\"k\">case</span> <span class=\"nl\">l_newline</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"s\">\"... [\"</span> <span class=\"o\">+</span> <span class=\"n\">LEX_STRING</span><span class=\"p\">(</span><span class=\"n\">type</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s\">\"]\"</span><span class=\"p\">;</span>\n    <span class=\"k\">default</span><span class=\"o\">:</span>\n        <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">str</span><span class=\"p\">.</span><span class=\"n\">substr</span><span class=\"p\">(</span><span class=\"n\">last_index</span><span class=\"p\">,</span> <span class=\"n\">index</span> <span class=\"o\">-</span> <span class=\"n\">last_index</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"n\">CLexer</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">idx</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">inc</span><span class=\"p\">,</span> <span class=\"kt\">bool</span> <span class=\"n\">newline</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">last_index</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"p\">;</span>\n    <span class=\"n\">last_line</span> <span class=\"o\">=</span> <span class=\"n\">line</span><span class=\"p\">;</span>\n    <span class=\"n\">last_column</span> <span class=\"o\">=</span> <span class=\"n\">column</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">newline</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">column</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"n\">line</span> <span class=\"o\">+=</span> <span class=\"n\">inc</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">inc</span> <span class=\"o\">&amp;lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"n\">column</span> <span class=\"o\">+=</span> <span class=\"n\">idx</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">column</span> <span class=\"o\">+=</span> <span class=\"n\">inc</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">index</span> <span class=\"o\">+=</span> <span class=\"n\">idx</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">lexer_t</span> <span class=\"n\">CLexer</span><span class=\"o\">::</span><span class=\"n\">next_digit</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">regex_search</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">.</span><span class=\"n\">cbegin</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">str</span><span class=\"p\">.</span><span class=\"n\">cend</span><span class=\"p\">(),</span> <span class=\"n\">sm</span><span class=\"p\">,</span> <span class=\"n\">r_digit</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">auto</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">sm</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">str</span><span class=\"p\">();</span>\n        <span class=\"n\">bags</span><span class=\"p\">.</span><span class=\"n\">_double</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">atof</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">());</span>\n        <span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">());</span>\n        <span class=\"k\">return</span> <span class=\"n\">l_double</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"s\">\"digit not match\"</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">l_error</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">lexer_t</span> <span class=\"n\">CLexer</span><span class=\"o\">::</span><span class=\"n\">next_alpha</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">regex_search</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">.</span><span class=\"n\">cbegin</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">str</span><span class=\"p\">.</span><span class=\"n\">cend</span><span class=\"p\">(),</span> <span class=\"n\">sm</span><span class=\"p\">,</span> <span class=\"n\">r_alpha</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">auto</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"n\">sm</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">str</span><span class=\"p\">();</span>\n        <span class=\"n\">bags</span><span class=\"p\">.</span><span class=\"n\">_identifier</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">();</span>\n        <span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">());</span>\n        <span class=\"k\">return</span> <span class=\"n\">l_identifier</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"s\">\"alpha not match\"</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">l_error</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">lexer_t</span> <span class=\"n\">CLexer</span><span class=\"o\">::</span><span class=\"n\">next_space</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">regex_search</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">.</span><span class=\"n\">cbegin</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">str</span><span class=\"p\">.</span><span class=\"n\">cend</span><span class=\"p\">(),</span> <span class=\"n\">sm</span><span class=\"p\">,</span> <span class=\"n\">r_space</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">auto</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">find_if</span><span class=\"p\">(</span><span class=\"n\">sm</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">sm</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">(),</span> <span class=\"p\">[](</span><span class=\"k\">auto</span><span class=\"p\">)</span> <span class=\"p\">{</span><span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span> <span class=\"p\">});</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m</span> <span class=\"o\">==</span> <span class=\"n\">sm</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">())</span> <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"s\">\"space not match\"</span><span class=\"p\">);</span>\n        <span class=\"k\">auto</span> <span class=\"n\">ms</span> <span class=\"o\">=</span> <span class=\"n\">m</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">str</span><span class=\"p\">();</span>\n        <span class=\"k\">auto</span> <span class=\"n\">ml</span> <span class=\"o\">=</span> <span class=\"n\">ms</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">();</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ms</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"sc\">' '</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">bags</span><span class=\"p\">.</span><span class=\"n\">_space</span> <span class=\"o\">=</span> <span class=\"n\">ml</span><span class=\"p\">;</span>\n            <span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">ml</span><span class=\"p\">);</span>\n            <span class=\"k\">return</span> <span class=\"n\">l_space</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ms</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'\\r'</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">bags</span><span class=\"p\">.</span><span class=\"n\">_newline</span> <span class=\"o\">=</span> <span class=\"n\">ml</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">ml</span><span class=\"p\">,</span> <span class=\"n\">bags</span><span class=\"p\">.</span><span class=\"n\">_newline</span><span class=\"p\">,</span> <span class=\"nb\">true</span><span class=\"p\">);</span>\n            <span class=\"k\">return</span> <span class=\"n\">l_newline</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ms</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"sc\">'\\n'</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">bags</span><span class=\"p\">.</span><span class=\"n\">_newline</span> <span class=\"o\">=</span> <span class=\"n\">ml</span><span class=\"p\">;</span>\n            <span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">ml</span><span class=\"p\">,</span> <span class=\"n\">bags</span><span class=\"p\">.</span><span class=\"n\">_newline</span><span class=\"p\">,</span> <span class=\"nb\">true</span><span class=\"p\">);</span>\n            <span class=\"k\">return</span> <span class=\"n\">l_newline</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"s\">\"space not match\"</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">l_error</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"s\">\"space not match\"</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">l_error</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">CLexer</span><span class=\"o\">::</span><span class=\"n\">local</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">index</span> <span class=\"o\">&amp;lt;</span> <span class=\"n\">length</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">str</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">];</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>方法解释：</p><ul><li>next：判别当前字符是数字/空格/字符，是的话跳到相应的识别函数中，这是LL1识别方法<br></li><li>next_digit：正则匹配时，返回l_double类型，这里为了方便，就先不识别int</li><li>next_alpha：正则匹配时，返回l_identifier类型<br></li><li>next_space：稍微复杂点，匹配时，需要在捕获组capture中找，找到后，存到字符串s中，然后只要判断s[0]是什么就可以了</li></ul><br><h2>测试！</h2><p>看看这段代码功能如何、正确与否，上测试吧~</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"cp\">#define OUTPUT(l, t) printf(\"[%03d:%03d] %-12s - %s\\n\", \\</span>\n<span class=\"cp\">    l.get_last_line(), \\</span>\n<span class=\"cp\">    l.get_last_column(), \\</span>\n<span class=\"cp\">    LEX_STRING(l.get_type()).c_str(), \\</span>\n<span class=\"cp\">    l.current().c_str());</span>\n\n<span class=\"cp\">#define TEST(l, t, v) \\</span>\n<span class=\"cp\">    assert(l.next() == l_##t); \\</span>\n<span class=\"cp\">    assert(l.get_##t() == v); \\</span>\n<span class=\"cp\">    OUTPUT(l, t);</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"s\">\"ABC </span><span class=\"se\">\\r\\n\\n\\n</span><span class=\"s\">0.2e8  a_ _b</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">;</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"# 输入 </span><span class=\"se\">\\n</span><span class=\"s\">----[[[</span><span class=\"se\">\\n</span><span class=\"s\">%s</span><span class=\"se\">\\n</span><span class=\"s\">----]]]</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span> <span class=\"n\">str</span><span class=\"p\">);</span>\n\n    <span class=\"n\">CLexer</span> <span class=\"n\">lexer</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">);</span>\n\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"</span><span class=\"se\">\\n</span><span class=\"s\"># 解析 </span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\n\n    <span class=\"n\">TEST</span><span class=\"p\">(</span><span class=\"n\">lexer</span><span class=\"p\">,</span> <span class=\"n\">identifier</span><span class=\"p\">,</span> <span class=\"s\">\"ABC\"</span><span class=\"p\">);</span>\n    <span class=\"n\">TEST</span><span class=\"p\">(</span><span class=\"n\">lexer</span><span class=\"p\">,</span> <span class=\"n\">space</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"n\">TEST</span><span class=\"p\">(</span><span class=\"n\">lexer</span><span class=\"p\">,</span> <span class=\"n\">newline</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"n\">TEST</span><span class=\"p\">(</span><span class=\"n\">lexer</span><span class=\"p\">,</span> <span class=\"n\">newline</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"n\">TEST</span><span class=\"p\">(</span><span class=\"n\">lexer</span><span class=\"p\">,</span> <span class=\"kt\">double</span><span class=\"p\">,</span> <span class=\"mf\">0.2e8</span><span class=\"p\">);</span>\n    <span class=\"n\">TEST</span><span class=\"p\">(</span><span class=\"n\">lexer</span><span class=\"p\">,</span> <span class=\"n\">space</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"n\">TEST</span><span class=\"p\">(</span><span class=\"n\">lexer</span><span class=\"p\">,</span> <span class=\"n\">identifier</span><span class=\"p\">,</span> <span class=\"s\">\"a_\"</span><span class=\"p\">);</span>\n    <span class=\"n\">TEST</span><span class=\"p\">(</span><span class=\"n\">lexer</span><span class=\"p\">,</span> <span class=\"n\">space</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"n\">TEST</span><span class=\"p\">(</span><span class=\"n\">lexer</span><span class=\"p\">,</span> <span class=\"n\">identifier</span><span class=\"p\">,</span> <span class=\"s\">\"_b\"</span><span class=\"p\">);</span>\n    <span class=\"n\">TEST</span><span class=\"p\">(</span><span class=\"n\">lexer</span><span class=\"p\">,</span> <span class=\"n\">newline</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>阶段性总结</h2><p>总体的代码看着很清爽~功能单一、结构精简，那么为了能够更快、更好地看到本系列的效果呢，我打算先完成目标、再完善功能！也就是说，先搞定下面的代码</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>int main() {\n    int i;\n    i = 1+2/3*4-5+6*(7-8);\n    printf(\"%d\", i);\n}\n</code></pre></div><p>其他的for/if等都不实现，这样就不会写着写着云里雾里去了。不过上面的代码看起来简单，实际上包含了四则运算优先级的问题，如果就用LL去做呢会有问题，像<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/SimpleConsole\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/SimpleConsole<i class=\"icon-external\"></i></a> 里面我就用了坑爹的GetMostLeftCombineAtom（破坏了美感），但用LL做代码非常清晰，也不需要了解LR等其他知识。</p><p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/SimpleConsole\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/SimpleConsole<i class=\"icon-external\"></i></a> 代码不多，但是感觉非常awesome，贴几处代码<br></p><div class=\"highlight\"><pre><code class=\"language-common-lisp\"><span></span><span class=\"nv\">empty</span> <span class=\"nb\">=</span> <span class=\"nv\">builtin</span> <span class=\"nv\">empty</span>\n<span class=\"nv\">fnx</span> <span class=\"nv\">head</span> <span class=\"nv\">x</span> <span class=\"nv\">xs</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">x</span>    <span class=\"nb\">-</span><span class=\"err\">\\</span>\n<span class=\"nv\">fnx</span> <span class=\"nv\">tail</span> <span class=\"nv\">x</span> <span class=\"nv\">xs</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">xs</span>   <span class=\"nv\">--------</span> <span class=\"err\">这几处才是关键！</span>\n<span class=\"nv\">fnx</span> <span class=\"nb\">list</span> <span class=\"nv\">x</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">x</span>       <span class=\"nv\">-/</span>\n<span class=\"nv\">fn</span> <span class=\"nv\">bool</span> <span class=\"nv\">x</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">bool</span> <span class=\"nv\">x</span>\n<span class=\"nv\">fn</span> <span class=\"nb\">not</span> <span class=\"nv\">x</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nb\">not</span> <span class=\"nv\">x</span>\n<span class=\"nv\">fnx</span> <span class=\"nv\">is_empty</span> <span class=\"nv\">x</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">is_empty</span> <span class=\"nv\">x</span>\n<span class=\"nv\">fnx</span> <span class=\"nv\">is_single</span> <span class=\"nv\">x</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">is_single</span> <span class=\"nv\">x</span>\n<span class=\"nv\">fnx</span> <span class=\"nv\">is_many</span> <span class=\"nv\">x</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">is_many</span> <span class=\"nv\">x</span>\n<span class=\"nv\">fn</span> <span class=\"nv\">match</span> <span class=\"nb\">cond</span> <span class=\"no\">t</span> <span class=\"nv\">f</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">match</span> <span class=\"nb\">cond</span> <span class=\"no\">t</span> <span class=\"nv\">f</span>\n<span class=\"nv\">fn</span> <span class=\"k\">if</span> <span class=\"nb\">cond</span> <span class=\"no\">t</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"k\">if</span> <span class=\"nb\">cond</span> <span class=\"no\">t</span>\n<span class=\"nv\">fn</span> <span class=\"nv\">exec</span> <span class=\"nb\">exp</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">exec</span> <span class=\"nb\">exp</span>\n<span class=\"nv\">fn</span> <span class=\"nb\">equal</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nb\">equal</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span>\n<span class=\"nv\">fn</span> <span class=\"nv\">not_equal</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">not_equal</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span>\n<span class=\"nv\">fn</span> <span class=\"nv\">lt</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">lt</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span>\n<span class=\"nv\">fn</span> <span class=\"nv\">gt</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">gt</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span>\n<span class=\"nv\">fn</span> <span class=\"nv\">lte</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">lte</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span>\n<span class=\"nv\">fn</span> <span class=\"nv\">gte</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">gte</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span>\n<span class=\"nv\">fn</span> <span class=\"nv\">range</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span> <span class=\"nv\">=&amp;gt;</span> <span class=\"nv\">builtin</span> <span class=\"nv\">range</span> <span class=\"nv\">x</span> <span class=\"nv\">y</span>\n</code></pre></div><p>然后求个pi值（用Web去实现console <a href=\"http://link.zhihu.com/?target=https%3A//github.com/chrisdone/jquery-console\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">chrisdone/jquery-console<i class=\"icon-external\"></i></a> 再加点signalr）：</p><p><img src=\"https://pic2.zhimg.com/v2-ed10f787021422ec7bf5273c138276ad_b.png\" data-rawwidth=\"414\" data-rawheight=\"356\" class=\"content_image\" width=\"414\">这样的书写是非常爽的，哈哈。</p><p>那下一节将完善功能，使其能识别操作符、关键字。</p>","updated":"2017-04-01T23:52:36.000Z","canComment":false,"commentPermission":"anyone","commentCount":4,"collapsedCount":0,"likeCount":13,"state":"published","isLiked":false,"slug":"26142441","isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic2.zhimg.com/v2-1eeb66213f95fdbe1d27a530c6aaf465_r.png","links":{"comments":"/api/posts/26142441/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/20032517","id":"20032517","name":"Parser"},{"url":"https://www.zhihu.com/topic/19554298","id":"19554298","name":"编程"},{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"}],"titleImageSize":{"width":400,"height":200},"href":"/api/posts/26142441","excerptTitle":"","column":{"slug":"learncpp","name":"从零开始构建标准库"},"tipjarState":"inactivated","sourceUrl":"","pageCommentsCount":4,"snapshotUrl":"","publishedTime":"2017-04-02T07:52:36+08:00","url":"/p/26142441","lastestLikers":[{"profileUrl":"https://www.zhihu.com/people/liu-jian-zhong-18-35","bio":"Still too young.","hash":"6cf91996b4beddf66364442b47a892ba","uid":54071624990720,"isOrg":false,"description":"Computer Science College Junior","isOrgWhiteList":false,"slug":"liu-jian-zhong-18-35","avatar":{"id":"9997bb4f17c8b90ff5c135e19298631d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"name":"刘健中"},{"profileUrl":"https://www.zhihu.com/people/jin-zhao-31-64","bio":"全沾码农","hash":"2b7b7b81b25a0d080e35af9b13aa6016","uid":76461843152896,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"jin-zhao-31-64","avatar":{"id":"1c6c63bacb6c77be51f3de3c31cb9475","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"name":"Jin Zhao"},{"profileUrl":"https://www.zhihu.com/people/zhang-tao-60-41","bio":"人生苦短，我只撸管","hash":"15b363842a220063d598c1932aab77a0","uid":596464246247264300,"isOrg":false,"description":"人生何其短，何苦要撕逼","isOrgWhiteList":false,"slug":"zhang-tao-60-41","avatar":{"id":"4a9fe7239915c2a6878f478c282d3e89","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"name":"Magicman"},{"profileUrl":"https://www.zhihu.com/people/xiong-chu-yuan-10","bio":"大概是个比较喜欢看书的好孩子~","hash":"d537af7bec192062a1162682ad0de352","uid":652262592857378800,"isOrg":false,"description":"NLP学习中, ACM已弃。\n（头像是女票，非本人，勿扰）","isOrgWhiteList":false,"slug":"xiong-chu-yuan-10","avatar":{"id":"v2-25eb33c7a3fcb934bb2f8bb185fbad5b","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"岐山凤鸣"},{"profileUrl":"https://www.zhihu.com/people/yangmingtian","bio":"學生，Oier，蛟川人","hash":"e12b3fb057c667118eefaa78034d6996","uid":550733447195320300,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"yangmingtian","avatar":{"id":"v2-b011c6a8ffdd16fe7039de2cd5f37d60","template":"https://pic1.zhimg.com/{id}_{size}.jpg"},"name":"楊明天"}],"summary":"写在前面代码：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/CParser\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/CParser<i class=\"icon-external\"></i></a>本节内容效果图：任务非常简单——识别空格/回车、变量名、数字。准备工作<b><u>思考一：类型</u></b>要解析C语言，那么肯定得考虑基本数据类型了，如int、char等。然而，我们将把每个识别出的token标记一个类型，这是lexer中的类型（用enum…","reviewingCommentsCount":0,"meta":{"previous":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic2.zhimg.com/v2-bef57d4a49ad03d4fe34857d7039edf9_r.png","links":{"comments":"/api/posts/26135675/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"},{"url":"https://www.zhihu.com/topic/19601369","id":"19601369","name":"编译原理"},{"url":"https://www.zhihu.com/topic/19554298","id":"19554298","name":"编程"}],"href":"/api/posts/26135675","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<h2>写在前面</h2><p>下面进入最好玩的部分——语法分析，做一个简易的能解析C语言并运行的程序。当然了，这已经不是第一次写了。</p><p>如正统的LR语法分析（java）实现自己的语言jMiniLang <a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jMiniLang\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/jMiniLang<i class=\"icon-external\"></i></a>。</p><p><b>实现<em>Y-Combinator</em>（lambda调用自身）：</b></p><p><img src=\"http://pic4.zhimg.com/v2-3c75c31ee37ec83925be9892215257e7_b.png\" data-rawwidth=\"526\" data-rawheight=\"582\" class=\"origin_image zh-lightbox-thumb\" width=\"526\" data-original=\"http://pic4.zhimg.com/v2-3c75c31ee37ec83925be9892215257e7_r.png\"><b>实现Shell和管道：</b></p><p><img src=\"http://pic4.zhimg.com/v2-d121a9ef08d330936fddf2100fb722bb_b.png\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"http://pic4.zhimg.com/v2-d121a9ef08d330936fddf2100fb722bb_r.png\">同样，也试了一把ANTLR（java）<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jProlog\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/jProlog<i class=\"icon-external\"></i></a>：</p><p><img src=\"http://pic2.zhimg.com/v2-13816586dc5c28547a93dae525deadc5_b.png\" data-rawwidth=\"826\" data-rawheight=\"694\" class=\"origin_image zh-lightbox-thumb\" width=\"826\" data-original=\"http://pic2.zhimg.com/v2-13816586dc5c28547a93dae525deadc5_r.png\"><img src=\"http://pic2.zhimg.com/v2-8950926e0b4ce805da20ce7f5c203185_b.png\" data-rawwidth=\"826\" data-rawheight=\"694\" class=\"origin_image zh-lightbox-thumb\" width=\"826\" data-original=\"http://pic2.zhimg.com/v2-8950926e0b4ce805da20ce7f5c203185_r.png\">同样地，在做了Codewars Ryu1难度的题<a href=\"http://link.zhihu.com/?target=https%3A//www.codewars.com/kata/simple-interactive-interpreter\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Simple Interactive Interpreter<i class=\"icon-external\"></i></a>后，又仿了个函数式编程语言出来<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/SimpleConsole\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/SimpleConsole<i class=\"icon-external\"></i></a>：</p><img src=\"http://pic2.zhimg.com/v2-a37024aee4c73c0356a2ffe0196a7789_b.jpg\" data-rawwidth=\"640\" data-rawheight=\"276\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"http://pic2.zhimg.com/v2-a37024aee4c73c0356a2ffe0196a7789_r.jpg\"><h2>本系列主要内容</h2><p>那么本系列主要围绕怎样从零做一个parser，顺带用点C++11的特性，IDE用的是VS2015。那么按照正常的parser思路，编码的顺序如下：</p><ol><li><b>词法分析 lexer</b></li><li><b>语法分析 parser</b></li><li><b>语义分析 semantic</b></li><li><b>中间语言生成 genil </b>这里仿汇编那样的形式吧，基于寄存器的</li><li><b>目标代码生成 gencode </b>生成什么暂时还未想，所以初定设计自己的指令集</li><li><b>指令集与虚拟机 vm </b>之前做的全是基于栈的，这次做基于寄存器的，那么难度加大，但是做完后，仿个操作系统出来也是可以的</li></ol><p>那么上述每个环节其实都很有意思的，<b>设计属于自己的语言</b>其实是非常有成就的一件事。那个开头的jminilang、jprolog、simpleconsole其实时间比较久了，也没有精心再去介绍它们，索性就新开一章，<b>再一次造轮子</b>。所谓熟能生巧，同样的东西，做的次数多了，那么写起来就像满腹经纶，有条有理，不再有坑，每一次写的代码就有进步。</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":26135675,"publishedTime":"2017-04-01T16:36:03+08:00","url":"/p/26135675","title":"【Parser系列】启程","summary":"写在前面下面进入最好玩的部分——语法分析，做一个简易的能解析C语言并运行的程序。当然了，这已经不是第一次写了。如正统的LR语法分析（java）实现自己的语言jMiniLang <a href=\"https://github.com/bajdcc/jMiniLang\" data-editable=\"true\" data-title=\"bajdcc/jMiniLang\">bajdcc/jMiniLang</a>。<b>实现<em>Y-Combinator</em>（lambda调用自身）：</b><b>实现Shell和管道：</b>同样，也…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0},"next":null},"commentsCount":4,"likesCount":13,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{},"favlists":{}},"me":{},"global":{},"columns":{"learncpp":{"following":false,"canManage":false,"href":"/api/columns/learncpp","name":"从零开始构建标准库","creator":{"slug":"bajdcc"},"url":"/learncpp","slug":"learncpp","avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"}}},"columnPosts":{},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true},"favlistsByUser":{},"favlistRelations":{}}</textarea>

    <script src="//static.zhihu.com/hemingway/common.09e6a1984c735e134505.js"></script>
<script src="//static.zhihu.com/hemingway/app.89ecf4e073987c60567b.js"></script>
<script src="//static.zhihu.com/hemingway/raven.4f017398aa850e39fe3c.js" async defer></script>
  </body>
</html>
