<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>第一章番外：内存 - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.ad2159a596c8458712d70cf5a5b17235.css" />
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"24953467":{"title":"第一章番外：内存","author":"bajdcc","content":"<h1>第一章番外：内存</h1><h2>参考</h2><p>这篇参考文章写得很详细：<a href=\"http://link.zhihu.com/?target=http%3A//blog.codinglabs.org/articles/a-malloc-tutorial.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CodingLabs - 如何实现一个malloc<i class=\"icon-external\"></i></a></p><h2>前言</h2><p>本节主要讲述内存的故事。</p><p>学习C++的过程中，一般书上介绍各种对象各种用法各种注意点各种坑。然而，通过写书上这些代码，究竟能够起到什么作用，这种程序是怎样管理内存的呢？看完书还是一知半解。</p><p>以几个例子为例：“烫烫烫”和“屯屯屯”是神马一回事？为什么总是出现Access violation？什么是野指针？堆上还是栈上傻傻分不清？内存会不会不够用啊？什么时候要释放这些空间？this指针到底是什么？为毛会有Stack overflow/Segment fault？变量、结构体、对象是内存中的东西吗？内存里面究竟是哪些妖魔鬼怪？…………</p><p>围绕着内存的问题有很多很多，上面的问题不可能去一一解答。</p><h2>内存的故事</h2><h3>奇怪的仓库</h3><p>整个计算机系统中的各部分协调工作，才是确保电脑不会动不动就蓝屏的关键。同样的，C++乃至整个编程语言世界都是建立在计算机系统的基础上，我们看到的，也只是冰山一角。</p><p>因此，平常人看内存：“那不就是个放一堆奇奇怪怪东西的空间么”。那么这些“奇怪的东西”是什么呢？</p><p>首先，要了解这些“奇怪的东西”，就必须明白计算机的运作方式？一般是“冯<em>·</em>诺依曼”架构的，如果你对它还不熟悉，那么下面的内容理解起来需要费多一些时间。</p><p>计算机的运作方式简单起见（表述不太严谨），就是：</p><ol><li><p><strong>CPU从内存获取指令</strong></p></li><li><p><strong>CPU执行这个指令，根据这个指令做相应的事情（如读文件、打印输出等）</strong></p></li><li><p><strong>CPU找到下一条指令的位置</strong></p></li><li><p><strong>回到第一步骤</strong></p></li></ol><p>一些问题：CPU读的第一条指令是什么？CPU读错了怎么办？下一条指令在哪里？CPU做什么事情都行吗，能不能和太阳肩并肩（手动滑稽）？这牵扯到操作系统的内容了，这里不展开。</p><p>现在，从计算机的运作方式中我们可以看出：</p><ul><li><p>内存中应该存放着<strong>指令</strong></p></li><li><p>内存中应该也存放着<strong>数据</strong></p></li><li><p>内存中可能还有其他我们不知道的东西（咖喱棒吗）</p></li></ul><p>那指令和数据在内存中是怎样存放的呢？会不会是随机打乱着放的呢？当然不会，操作系统其实是个强迫症、整理控，它对指令和数据的存放要求非常严格：</p><ul><li><p>指令就该放在专门的存放指令的地方！</p></li><li><p>数据也应该放在专门的放数据的地方！</p></li></ul><p>那么这个要求呢，在操作系统层次上叫作“段”/Segment。</p><h3>大叔的日常</h3><p>我们的<strong>大叔（操作系统）</strong>其实是一个疯狂的整理控，它对内存的打理是非常苛刻的。为什么这么苛刻呢？原因在于内存其实空间是有限的，如果那些<strong>小弟（程序）</strong>去外面带了一堆的<strong>杀马特（申请内存）</strong>回来，那么大叔家就会被挤爆，到时候整个系统就挂了。</p><p>所以大叔会时刻关注家里的情况，计算着目前家里有多少小弟，有多少杀马特，有多少吃的喝的。一旦发现不够用了，大叔立马开启一级警报：谁谁谁，把你的杀马特带出去！你你你，不准再把杀马特带进屋里来！我的天哪，你们把家里搞成啥样了，快把奶嘴都放抽屉里！此时大叔变成了凶残的大妈。</p><p>上面的例子只是为了形象说明，求轻拍。</p><h3>黑客的伎俩</h3><p>刚刚说到内存中有指令有数据，两者分别存放在特定的区域。</p><p>那么指令跟数据的关系其实很微妙：</p><ul><li><p>如果我恶意修改了数据，那么指令的执行就会受影响</p></li><li><p>如果我恶意修改了指令，那么指令和数据我都可以改掉了</p></li></ul><p>所以典型的思路是：我改了一点数据，结果影响了指令的正常运行，指令出现了意料之外的情况。其中一种情况是，<strong>指令会执行到数据的区域上来</strong>。这样，我更改了数据区域，相当于更改了指令区域。更改了指令区域的后果就是：可以让系统与大太阳肩并肩，你可以胡作非为了。</p><p>那么这里，有一个小小的例子可以说明：<a href=\"http://link.zhihu.com/?target=http%3A//www.secbox.cn/hacker/program/c/2350.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">初探缓冲区溢出 C++ strcpy<i class=\"icon-external\"></i></a>。这个例子用VC6.0进行编译，所以程序运行没有报错，若用较新的VS2015编译运行会发现程序运行会报错（它检测到指令被修改）。这个例子就是大名鼎鼎的“<strong>缓冲区溢出漏洞</strong>”。</p><p>如果我直接去修改指令区域，可能会收到一个Access Violation的手动滑稽表情。</p><h2>管理内存</h2><p>前面简单介绍了内存的一系列知识，但内存不是只可远观不可亵玩的，相反地，我们需要自己去管理内存。</p><p>“管理”一般就是简单的CURD（增删改查）。</p><h3>内存的申请</h3><p>申请内存是门大学问。</p><p>前面说了大叔其实是整理控，如果你胡乱地申请内存，大叔便会恼怒，让你的程序越走越慢——这可是你自找的。</p><p>偌大一片内存，如何管理？常言道不扫一屋何以扫天下，就以一小块内存作为自留地，自己耕耘吧。</p><p>假设现在手头有块地，大小是1KB。</p><ul><li><p>如果要提供1MB空间，那么不好意思，地不够，不借</p></li><li><p>如果要提供1KB，正好，给你</p></li><li><p>如果要1B，呵呵，免费赠送（为了取整），给你4B；如果要5B，同样，给8B</p></li><li><p>难道工作就这么简单？拿衣服</p></li></ul><p>现在情况复杂了，有借有还，再借不难。</p><ul><li><p>之前借的1KB还你了</p></li><li><p>一半地借人了，一半地还了，现在只剩一半地</p></li><li><p>借借还还越来越乱，最后是有半KB空间，但连100B也借不出去！</p></li></ul><p>你火了：我要请个整理控来！我要请一堆整理控来！</p><ul><li><p>整理控1：我每次从开头找，只要找到符合你要求大小的，就把它给你</p></li><li><p>整理控2：我全部找一遍，把符合你要求但是空间最小的地给你</p></li><li><p>整理控3：等等等等，我把这些零碎的地全合并到前面去，再把后面的空地给你，但是首先…</p></li><li><p>整理控4：给你零碎的地我想没问题吧……（被一脚踢飞）</p></li><li><p>整理控5：我全部找一遍，把符合你要求但是空间最大的地给你</p></li><li><p>整理控6：我全部找一遍，把符合你要求但是空间适中的地给你</p></li></ul><p>最后，你非常开心，然后请了整理控1，并拒绝了后面所有人。</p><h3>内存的归还</h3><p>内存的归还还不简单，一个字，还！</p><p>但其中有玄机：两个空地被归还了，很巧的是这两块地相邻，结果当然是这两块地合并成一块空地了。但是在编程中，并没有此等好事，大叔说：“合并是神马？两个杀马特会自动合并成一个杀马特吗？当然是你来做！”</p><p>面对前面一块块零零落落的地，你感慨万千：“用什么方法来记录它们比较好呢？”</p><p>于是你买了几百本数学练习簿，打算记账。直到有一天，你惊讶地发现：</p><p>它，今天终于的确来还地了。但是，它是第一次向你申请土地的人！它的记录在前面300页！苍天！大地！我找了几宿才找到他！这可恨的！</p><p>所以，你嘀咕着：“是记载方式出问题了吗？”突然，你想到了什么。</p><p>你买一本空白的几千页厚的书，按照土地的总量，计算出一页纸代表多少土地。谁借了，就在那部分纸上写上他的名字。但是显而易见，这种方法出了问题：别人少还了很难找出来。</p><p>后来，你想了一个办法。谁借了地，在相应的那部分纸的第一张写上他的名字。然后，将这块地相邻的上一块地和下一块地的页码也记在上面，虽然这样的话，这一页纸就没用了，不过好在可以解决问题。</p><p>最后，这种方法很久都没出问题。这种方法也是比较普遍的方法，详情请看最前面的参考部分。</p><h2>总结</h2><p>每个写程序的人都是管理内存的大师，不过这大师要打引号。什么时候，自己成为了一个整理控，有着对内存要求很苛刻的独特癖好，那么这个时候——你就成了大叔。</p>","updated":"2017-01-19T06:55:38.000Z","canComment":false,"commentPermission":"anyone","commentCount":0,"collapsedCount":0,"likeCount":1,"state":"published","isLiked":false,"slug":"24953467","isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic4.zhimg.com/v2-e7257b5a7547a4e967fe9f38aca198e7_r.jpg","links":{"comments":"/api/posts/24953467/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/19593616","id":"19593616","name":"编程学习"},{"url":"https://www.zhihu.com/topic/19584970","id":"19584970","name":"C++"},{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"}],"titleImageSize":{"width":0,"height":0},"href":"/api/posts/24953467","excerptTitle":"","column":{"slug":"learncpp","name":"从零开始构建标准库"},"tipjarState":"inactivated","sourceUrl":"","pageCommentsCount":0,"snapshotUrl":"","publishedTime":"2017-01-19T14:55:38+08:00","url":"/p/24953467","lastestLikers":[{"profileUrl":"https://www.zhihu.com/people/cking-31","bio":"it工程师","hash":"008499ee63ecc4b85bbde79f3f8da42f","uid":624873062756257800,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"cking-31","avatar":{"id":"472b0b0cca5778be6ba62fad91bf6320","template":"https://pic1.zhimg.com/{id}_{size}.png"},"name":"cking"}],"summary":"第一章番外：内存参考这篇参考文章写得很详细：<a href=\"http://blog.codinglabs.org/articles/a-malloc-tutorial.html\" data-editable=\"true\" data-title=\"CodingLabs - 如何实现一个malloc\">CodingLabs - 如何实现一个malloc</a>前言本节主要讲述内存的故事。学习C++的过程中，一般书上介绍各种对象各种用法各种注意点各种坑。然而，通过写书上这些代码，究竟能够起到什么作用，这种程序是怎样管理内存的…","reviewingCommentsCount":0,"meta":{"previous":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic2.zhimg.com/v2-d05d41e5c2080b4e75613c8cf074f435_r.png","links":{"comments":"/api/posts/24928430/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"},{"url":"https://www.zhihu.com/topic/19584970","id":"19584970","name":"C++"},{"url":"https://www.zhihu.com/topic/19593616","id":"19593616","name":"编程学习"}],"href":"/api/posts/24928430","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<h1>第二章：变长数组（一）</h1><h2>地位</h2><p>变长数组是比较基础的数据结构，对初学者而言，是它是它就是它！</p><p>假如没有循环语句去遍历，那么数组也就不会那么广为人知。数组在生活中也有体现，如报表、清单等等，它意味着连续的空间。大家知道内存其实就是一片连续的空间，所以内存也是一个巨大的数组，不过由于某种原因，你只能访问有限的空间。</p><p>静态分配的定长数组，那没问题，它长度永远不变，在编译期就可以安排好，没毛病。不过定长数组功能有限，假如要读取全班成绩，没读到尾巴之前，谁也不知道有多少个学生。除非知道了大致的学生总数，先分配空间；否则定长数组就无用武之地。</p><p>为了解决定长数组的局限性，变长数组应运而生。说是变长，其实是“假”变长。先分配好空间，结果空间不够了，这时候就尴尬了：“老大，留还是撤？”。留的话，不知道后面还有没有空间，结果生死未卜；战略转移的话，很有可能找到新家，就这样决定了！</p><p>怎么个“战略转移”法？就是找处新地方，将原来的数据搬过去。</p><h2>基础</h2><h3>向量</h3><p>在这里，类名是<em>vector</em>即向量。</p><p>了解一下向量的基本操作：</p><ul><li><p>增：插入至头，插入至中间，添加至末尾，插入连续的数据</p></li><li><p>删：删除头、尾、中间、连续区域</p></li><li><p>改：修改数据，修改预设大小</p></li><li><p>查：查询某个位置的数据，获取数组的有效长度</p></li></ul><p>本节是第一节，主要介绍vector的基本功能。后续“增删改查”的环节会添加迭代器。</p><h2>思路</h2><p>在先前的内存池基础上实现简单的vector。</p><h2>详解</h2><h3>一、再分配</h3><p>补上先前缺少的重新分配内存方法。</p><p>思路：在内存池中查找指定大小的块，如果没有就报错，如果有的话，就搬运这些数据，最后把原有内存释放。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span> <span class=\"c1\">// 重新分配内存</span>\n<span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"nf\">_realloc</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">uint</span> <span class=\"n\">newSize</span><span class=\"p\">,</span> <span class=\"n\">uint</span> <span class=\"n\">clsSize</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t<span class=\"n\">block</span> <span class=\"o\">*</span><span class=\"n\">blk</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&amp;lt;</span><span class=\"n\">block</span><span class=\"o\">*&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n\t<span class=\"o\">--</span><span class=\"n\">blk</span><span class=\"p\">;</span> <span class=\"c1\">// 自减得到块的元信息头</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">verify_address</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">))</span>\n\t\t<span class=\"k\">return</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">block_align</span><span class=\"p\">(</span><span class=\"n\">newSize</span> <span class=\"o\">*</span> <span class=\"n\">clsSize</span><span class=\"p\">);</span> <span class=\"c1\">// 计算新的内存大小</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">_new</span> <span class=\"o\">=</span> <span class=\"n\">_alloc</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">_new</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"c1\">// 空间不足</span>\n\t\t<span class=\"n\">_free</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">);</span>\n\t\t<span class=\"k\">return</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">oldSize</span> <span class=\"o\">=</span> <span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">size</span><span class=\"p\">;</span>\n\t<span class=\"n\">memmove</span><span class=\"p\">(</span><span class=\"n\">_new</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">__min</span><span class=\"p\">(</span><span class=\"n\">oldSize</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"p\">));</span> <span class=\"c1\">// 移动内存</span>\n\t<span class=\"n\">_free</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n\t<span class=\"k\">return</span> <span class=\"n\">_new</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>二、设置参数</h3><p>设置一些参数。</p><br><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">namespace</span> <span class=\"n\">vector_config</span>\n<span class=\"p\">{</span>\n\t<span class=\"c1\">// 最大空间</span>\n\t<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">size_t</span> <span class=\"n\">FULL_SIZE</span> <span class=\"o\">=</span> <span class=\"mh\">0x100000</span><span class=\"p\">;</span>\n\t<span class=\"c1\">// 共用内存池</span>\n\t<span class=\"k\">static</span> <span class=\"n\">memory</span><span class=\"o\">::</span><span class=\"n\">memory_pool</span><span class=\"o\">&amp;lt;</span><span class=\"n\">FULL_SIZE</span><span class=\"o\">&amp;gt;</span> <span class=\"n\">mem</span><span class=\"p\">;</span>\n\n\t<span class=\"c1\">// 默认总容量</span>\n\t<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">size_t</span> <span class=\"n\">DEF_SIZE</span> <span class=\"o\">=</span> <span class=\"mh\">0x10</span><span class=\"p\">;</span>\n\t<span class=\"c1\">// 默认递增容量</span>\n\t<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">size_t</span> <span class=\"n\">ACC_SIZE</span> <span class=\"o\">=</span> <span class=\"mh\">0x10</span><span class=\"p\">;</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><h3>三、向量</h3><p>目前只实现了向量的核心部分。</p><p>往向量中添加数据的时候，如果可用空间不够了，就去向内存池申请更大的一片空间。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"c1\">// 向量（变长数组）</span>\n<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"o\">&amp;gt;</span>\n<span class=\"k\">class</span> <span class=\"nc\">vector</span>\n<span class=\"p\">{</span>\n\t<span class=\"k\">using</span> <span class=\"n\">data_t</span> <span class=\"o\">=</span> <span class=\"n\">T</span><span class=\"p\">;</span>\n\n\t<span class=\"kt\">size_t</span> <span class=\"n\">capacity</span><span class=\"p\">;</span> <span class=\"c1\">// 所有空间</span>\n\t<span class=\"kt\">size_t</span> <span class=\"n\">used</span><span class=\"p\">;</span> <span class=\"c1\">// 已用空间</span>\n\t<span class=\"kt\">size_t</span> <span class=\"n\">acc</span><span class=\"p\">;</span> <span class=\"c1\">// 每次递增大小</span>\n\n\t<span class=\"n\">data_t</span> <span class=\"o\">*</span><span class=\"n\">data</span><span class=\"p\">;</span> <span class=\"c1\">// 数据</span>\n\n\t<span class=\"kt\">void</span> <span class=\"nf\">extend</span><span class=\"p\">()</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"n\">capacity</span> <span class=\"o\">+=</span> <span class=\"n\">acc</span><span class=\"p\">;</span>\n\t\t<span class=\"c1\">// 注意：扩充容量时，原有数据失效！</span>\n\t\t<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">vector_config</span><span class=\"o\">::</span><span class=\"n\">mem</span><span class=\"p\">.</span><span class=\"n\">realloc</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\n<span class=\"k\">public</span><span class=\"o\">:</span>\n\n\t<span class=\"n\">vector</span><span class=\"p\">()</span>\n\t\t<span class=\"o\">:</span> <span class=\"n\">capacity</span><span class=\"p\">(</span><span class=\"n\">vector_config</span><span class=\"o\">::</span><span class=\"n\">DEF_SIZE</span><span class=\"p\">)</span>\n\t\t<span class=\"p\">,</span> <span class=\"n\">used</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\t\t<span class=\"p\">,</span> <span class=\"n\">acc</span><span class=\"p\">(</span><span class=\"n\">vector_config</span><span class=\"o\">::</span><span class=\"n\">ACC_SIZE</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">vector_config</span><span class=\"o\">::</span><span class=\"n\">mem</span><span class=\"p\">.</span><span class=\"n\">alloc_array</span><span class=\"o\">&amp;lt;</span><span class=\"n\">data_t</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">capacity</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 添加新元素至末尾</span>\n\t<span class=\"kt\">void</span> <span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">obj</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">used</span> <span class=\"o\">&amp;gt;=</span> <span class=\"n\">capacity</span><span class=\"p\">)</span>\n\t\t<span class=\"p\">{</span>\n\t\t\t<span class=\"n\">extend</span><span class=\"p\">();</span>\n\t\t<span class=\"p\">}</span>\n\t\t<span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">used</span><span class=\"o\">++</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">obj</span><span class=\"p\">;</span> <span class=\"c1\">// T类型的赋值拷贝</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 弹出末尾的元素</span>\n\t<span class=\"n\">T</span><span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">pop</span><span class=\"p\">()</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">used</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t\t\t<span class=\"k\">throw</span> <span class=\"s\">\"Empty vector\"</span><span class=\"p\">;</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">forward</span><span class=\"o\">&amp;lt;</span><span class=\"n\">T</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"o\">--</span><span class=\"n\">used</span><span class=\"p\">]);</span> <span class=\"c1\">// 返回右值引用</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 获取元素</span>\n\t<span class=\"n\">T</span><span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">get</span><span class=\"p\">(</span><span class=\"kt\">size_t</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"k\">const</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">index</span> <span class=\"o\">&amp;gt;=</span> <span class=\"n\">used</span><span class=\"p\">)</span>\n\t\t\t<span class=\"k\">throw</span> <span class=\"s\">\"Invalid index\"</span><span class=\"p\">;</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">forward</span><span class=\"o\">&amp;lt;</span><span class=\"n\">T</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]);</span> <span class=\"c1\">// 返回右值引用</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 获取最末尾元素</span>\n\t<span class=\"n\">T</span><span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">top</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">used</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 得到大小</span>\n\t<span class=\"kt\">size_t</span> <span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">used</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><h3>六、单元测试</h3><p>测试了添加和寻址功能，目前没啥问题。</p><h2>源码</h2><p>文章：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/learnstl/blob/master/chapter/02/Vector_I.md\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/learn</span><span class=\"invisible\">stl/blob/master/chapter/02/Vector_I.md</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></p><p>源码：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/learnstl/blob/master/code/02/vector.h\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/learn</span><span class=\"invisible\">stl/blob/master/code/02/vector.h</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></p><h2>总结</h2><p>vector的编写过程还算轻松~</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":24928430,"publishedTime":"2017-01-17T22:50:23+08:00","url":"/p/24928430","title":"第二章：变长数组（一）","summary":"第二章：变长数组（一）地位变长数组是比较基础的数据结构，对初学者而言，是它是它就是它！假如没有循环语句去遍历，那么数组也就不会那么广为人知。数组在生活中也有体现，如报表、清单等等，它意味着连续的空间。大家知道内存其实就是一片连续的空间，所…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0},"next":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic4.zhimg.com/v2-b71e68befd80ac92674b599f1791849f_r.png","links":{"comments":"/api/posts/25027543/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"},{"url":"https://www.zhihu.com/topic/19848273","id":"19848273","name":"DirectUI"},{"url":"https://www.zhihu.com/topic/19616605","id":"19616605","name":"DirectX"}],"href":"/api/posts/25027543","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<p>新建了个项目：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/GameFramework\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/GameFramework<i class=\"icon-external\"></i></a><br></p><p>--------------------------------------------------------</p>继续开坑~偶然想起一个遥远的轮子——<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/CCGuiFoundation\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/CCGuiFoundation<i class=\"icon-external\"></i></a> ，这是借鉴轮子哥的。<p>这个轮子的架构是C/C++，渲染用DirectX，库用STL/ATL（删掉了wtf库）。不过整个项目很庞大，超过了一万行代码，所以将它化简，先抽出核心部分来做。</p><p>鉴于渲染用的DirectX，因此也不引用其他渲染库了，怪麻烦的。游戏的逻辑交互大多用Lua，因此趁机好好研究下Lua。</p><p>大致的内容有：</p><ol><li>Window类的设计，对Win32 API的封装，消息、事件</li><li>DirectUI的设计，显示层对象间的关系（相对位置计算）</li><li>DirectX的初始化及使用，渲染图元</li><li>Lua的交互</li><li>经典窗体控件的实现</li></ol><p>不过第一步应该是实现一个最小化框架，能够在黑屏幕上打出Hello world！（借助Lua和DX）</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":25027543,"publishedTime":"2017-01-26T16:19:21+08:00","url":"/p/25027543","title":"【游戏框架系列】开篇","summary":"新建了个项目：<a href=\"https://github.com/bajdcc/GameFramework\" data-editable=\"true\" data-title=\"bajdcc/GameFramework\">bajdcc/GameFramework</a> --------------------------------------------------------继续开坑~偶然想起一个遥远的轮子——<a href=\"https://github.com/bajdcc/CCGuiFoundation\" data-editable=\"true\" data-title=\"bajdcc/CCGuiFoundation\" class=\"\">bajdcc/CCGuiFoundation</a> ，这是借鉴轮子哥的。这个轮子的架构是C/C++，渲染用DirectX，库用STL/ATL（删掉了wtf库）。不…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0}},"commentsCount":0,"likesCount":1,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{}},"me":{},"global":{},"columns":{"learncpp":{"following":false,"canManage":false,"href":"/api/columns/learncpp","name":"从零开始构建标准库","creator":{"slug":"bajdcc"},"url":"/learncpp","slug":"learncpp","avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"FULLINFO":false}},"columnPosts":{},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true}}</textarea>

    <script src="//static.zhihu.com/hemingway/common.ac46319b23e12700340a.js"></script>
<script src="//static.zhihu.com/hemingway/app.47dccfede9fcf0800757.js"></script>
<script src="//static.zhihu.com/hemingway/raven.ccdadd4407812d1aac2f.js" async defer></script>
  </body>
</html>
