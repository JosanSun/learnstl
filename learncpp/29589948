<!doctype html>
<html lang="zh-CN" class="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>【CEval系列】简介 - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.801234ee6d0e1200c89b55e9d3bf896f.css" />
    <style></style>
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","wechatConfigAPI":"/api/wechat/jssdkconfig","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"29589948":{"contributes":[{"sourceColumn":{"lastUpdated":1497249764,"description":"玩玩有趣的东西","permission":"COLUMN_PUBLIC","memberId":10760740,"contributePermission":"COLUMN_PUBLIC","translatedCommentPermission":"all","canManage":true,"intro":"写写C++","urlToken":"learncpp","id":25963,"imagePath":"v2-bf63794c542fc73b11e17014b7e0d01d.jpg","slug":"learncpp","applyReason":"0","name":"学习C++","title":"学习C++","url":"https://zhuanlan.zhihu.com/learncpp","commentPermission":"COLUMN_ALL_CAN_COMMENT","canPost":true,"created":1483611626,"state":"COLUMN_NORMAL","followers":2487,"avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"activateAuthorRequested":false,"following":false,"imageUrl":"https://pic2.zhimg.com/v2-bf63794c542fc73b11e17014b7e0d01d_l.jpg","articlesCount":48},"state":"accepted","targetPost":{"titleImage":"https://pic3.zhimg.com/v2-8ecd6093851e4cda1271ba94c66f3cc2_r.png","lastUpdated":1506125878,"imagePath":"v2-8ecd6093851e4cda1271ba94c66f3cc2.png","permission":"ARTICLE_PUBLIC","topics":[16495,1354,17215],"summary":"CEval - 四则运算器（C++）源码：<a href=\"https://github.com/bajdcc/CEval\">bajdcc/CEval</a>最近把jMiniLang玩得差不多了，有点腻了。重温一下设计模式，这也不是重新造轮子，不必用高大上的LR分析去弄，这个正经C++专栏（雾）还是要来点C++干货的。回故一下曾经做的：LR分析（Java）一条龙工程——Pars…","copyPermission":"ARTICLE_COPYABLE","translatedCommentPermission":"all","likes":0,"origAuthorId":0,"publishedTime":"2017-09-22T22:24:44+08:00","sourceUrl":"","urlToken":29589948,"id":4024557,"withContent":false,"slug":29589948,"bigTitleImage":false,"title":"【CEval系列】简介","url":"/p/29589948","commentPermission":"ARTICLE_ALL_CAN_COMMENT","snapshotUrl":"","created":1506090284,"comments":0,"columnId":0,"content":"","parentId":0,"state":"ARTICLE_PUBLISHED","imageUrl":"https://pic3.zhimg.com/v2-8ecd6093851e4cda1271ba94c66f3cc2_r.png","author":{"bio":"专业研究野生技术","isFollowing":false,"hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"slug":"bajdcc","isFollowed":false,"description":"专业研究野生技术 https://github.com/bajdcc","name":"陈安","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},"memberId":10760740,"excerptTitle":"","voteType":"ARTICLE_VOTE_CLEAR"},"id":833205}],"title":"【CEval系列】简介","author":"bajdcc","content":"<h2>CEval - 四则运算器（C++）</h2><p>源码：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/CEval\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/CEval<i class=\"icon-external\"></i></a></p><p>最近把jMiniLang玩得差不多了，有点腻了。重温一下设计模式，这也不是重新造轮子，不必用高大上的LR分析去弄，这个正经C++专栏（雾）还是要来点C++干货的。</p><p>回故一下曾经做的：</p><ul><li>LR分析（Java）一条龙工程——Parser、IR、VM、UI，维护最久的：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jMiniLang\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/jMini</span><span class=\"invisible\">Lang</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li>LISP解释器（C++，ANTLR）：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/MyScript\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/MyScr</span><span class=\"invisible\">ipt</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li>简单C语言编译器+虚拟机（C++，正则表达式）：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/CParser\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/CPars</span><span class=\"invisible\">er</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li>管道：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/CppShell\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/CppSh</span><span class=\"invisible\">ell</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li>仿Prolog（Java &amp;amp; ANTLR）：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jProlog\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/jProl</span><span class=\"invisible\">og</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li>函数式语言（C#）：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/SimpleConsole\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/Simpl</span><span class=\"invisible\">eConsole</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li><b>数字转人民币（Java）——设计模式装逼典范，过度设计的反面教材哈哈，我已经把它翻成C++了，就在下面</b>：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/translate\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/trans</span><span class=\"invisible\">late</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li></ul><p>没想到做过了这么多东西，写了这么多轮子，所以说对Parser这块可以说比较熟练了（排除编译优化哈），对计算器呢，肯定不能用已经实现过的方法，应该要有创新点。</p><p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/translate\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数字转人民币<i class=\"icon-external\"></i></a>这个工程我感觉很有价值（你想过用编译指令去Parse一个简单的数字吗？），想办法把它融到本项目中去（感觉用用扩展），然后这个工程是上述所有工程中最早写的，这样想还觉得现在写的代码太low了（逃</p><h2>思路</h2><h2>一、解析（Parser &amp;amp; Lexer）</h2><p>肯定要用LL人肉分析啦，这是<b>基本功</b>嘛，，</p><p>这里会重温：</p><ol><li>词法分析</li><ol><li>字符串转整型（不用正则）</li><li>字符串转浮点（不用正则）</li><li>识别操作符（包括内置操作符和<b>可自定义扩展操作符</b>）</li><li>赋值语句（简单点就是ID=Exp）</li></ol><li>语法分析</li><ol><li>LL分析</li><li>生成语法树</li></ol></ol><p><br></p><h2>二、求值（Eval）</h2><p>一般而言，求个表达式的值，用算符优先文法也能做，不过太老套了。</p><p>LL分析表达式最大问题是优先级问题，如果我写了文法，然后去掉左递归，当然也可以，不过太没人性了，这方面用yaac和ANTLR比较好，它们帮你做。</p><p>比如对于“3+4*5”，识别到乘号前，“3+4”肯定不能搞成一棵树，如果我硬要做，也行，只是到时候到乘号时就要忍痛割爱了（<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/SimpleConsole\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">函数式编程<i class=\"icon-external\"></i></a>这个项目就用这个坑爹方法）。我不做，那行，把“3+4”顺序放到栈里，也就是算符文法。看来没别的路走了。</p><p>然而我还是要做，就是要生成树，到时候我改还不成么。碰到乘号后，我就把“4”这个结点替换成树，也就是说，算符文法是碰到没有更高优先级就归约，我不管，<b>我就是要立即马上归约，这是本项目要尝试的地方</b>，管它高不高效，哈哈。</p><p>还有个问题是归约后立马求值还是整体一起求值，其实，前者是自底向上，后者是自顶向下。我就是倾向于前者——<b>立马求值</b>，第一，出错后立马爆炸，免得解析后面多余的内容，第二，直接在归约时计算数值类型，该整型换浮点就换掉。</p><h2>三、扩展（Extension）</h2><p>就是函数呗，如abs等函数。引入变量名后，好处还是比较大的。当然这又会有一个坑爹问题——函数对参数的类型要求。参照上文，我的想法是——类型不同，如果不能自动转换，那立马爆炸。</p><p>扩展的第一个内容我想应该是<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/translate\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">人民币翻译方案<i class=\"icon-external\"></i></a>，我把多余的设计去掉，只剩下指令部分。一般LR分析看到一个函数调用，肯定先把参数给归约了，然后再到函数。而LL的话，我一看到变量名，发现是函数，就调用了相应函数的Parser方法，将控制权交给它。</p><p>为什么？因为不用对参数归约了呀，让函数去做。人民币翻译的代码里面，它就是Lexer和Parser搅在一起，哈哈，真是神设计，不知道当初怎么想的。</p><h2>计划</h2><ol><li><b>【已完成】</b> 人民币解析（Java移植到C++）</li><li>完成四则运算解析</li><li>完成某些黑科技</li></ol><h2>====================================</h2><h2>【已完成模块】人民币翻译（C++）</h2><p>本模块代码：<b>2k Lines</b>。</p><p>【简要分析】数字转人民币显示的难点有：数字按四位划分、合法性检查、零的取舍。</p><h2>一、顶层设计</h2><p>三个阶段：词法过滤、正则分组、语法分析。</p><p>设计原因：便于匹配顶层调用（面向调用的），结合常见的设计方式。</p><p>后面的专栏我会以下面三大阶段分别介绍。</p><h2>阶段一：RefString 系列代码（词法分析阶段的流过滤器）</h2><p>实现基于字符串的装饰器模式，类似于LINQ。</p><p>示例代码在ModRmbLexer结尾处（建造者模式）：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"n\">shared_ptr</span><span class=\"o\">&amp;lt;</span><span class=\"n\">IRefStringIterator</span><span class=\"o\">&amp;gt;</span> <span class=\"n\">RmbLexer</span><span class=\"o\">::</span><span class=\"n\">decorator</span><span class=\"p\">(</span><span class=\"n\">string</span> <span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">make_shared</span><span class=\"o\">&amp;lt;</span><span class=\"n\">RefString</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n        <span class=\"o\">-&amp;gt;</span><span class=\"n\">iterator</span><span class=\"p\">()</span> <span class=\"c1\">// 启用流</span>\n        <span class=\"o\">-&amp;gt;</span><span class=\"n\">skipHead</span><span class=\"p\">(</span><span class=\"sc\">'0'</span><span class=\"p\">)</span> <span class=\"c1\">// 启用向前看，跳过数字前置零</span>\n        <span class=\"o\">-&amp;gt;</span><span class=\"n\">findFirst</span><span class=\"p\">(</span><span class=\"sc\">'.'</span><span class=\"p\">)</span> <span class=\"c1\">// 找到小数点</span>\n        <span class=\"o\">-&amp;gt;</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"c1\">// 只取小数点后两位</span>\n        <span class=\"o\">-&amp;gt;</span><span class=\"n\">lookAhead</span><span class=\"p\">();</span> <span class=\"c1\">// 启用向前看</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>经过筛选后，\"000905000234.0678\"就变成了\"905000234.06\"。</p><p>而RefString设计之初就是只保存<b>原字符串指针和起始终止位置</b>，不复制原字符串，然而Java中确实是可以这么实现的，但是！C++里面string仍然会拷贝啊，除非一直保存string的指针，感觉太繁琐，所以C++里面RefString的功能就只是提供了流的接口而已。</p><h2>阶段二：ModRmbStyle 系列代码（词法分析阶段的正则匹配状态机）</h2><p>ModRmbStyle 生成了一系列指令，用于字符串的分组捕获及错误处理（状态机模式）。该阶段将数字拆分成<b>整数、小数点、小数</b>这三个部分，结果还是字符串，可以看做是正则捕获阶段。</p><p>指令集的设计以及分阶段的指令集也是我自己的想法和实现。</p><p>示例代码在ModRmbStyle，这里不贴了。</p><h2>阶段三：ModRmbParser 系列代码（生成AST）</h2><p>ModRmbParser 生成AST，用访问者模式就可以遍历生成最终的人民币大写表示。</p><p>LL分析不说了，由于第二阶段将字符串拆分成三组，这样就分别对整数、小数点、小数三部分进行LL分析，生成AST。</p><p>语法分析阶段顶层调用代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"n\">lexer</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">match</span><span class=\"p\">();</span> <span class=\"c1\">// 词法分析+正则捕获</span>\n<span class=\"n\">group</span> <span class=\"o\">=</span> <span class=\"n\">lexer</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">getGroup</span><span class=\"p\">();</span> <span class=\"c1\">// 获取匹配后的分组</span>\n<span class=\"n\">normalizeGroup</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span> <span class=\"c1\">// 填充缺失的分组</span>\n<span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"n\">make_shared</span><span class=\"o\">&amp;lt;</span><span class=\"n\">StoreableNode</span><span class=\"o\">&amp;gt;</span><span class=\"p\">();</span> <span class=\"c1\">// AST的根</span>\n<span class=\"n\">root</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">addNode</span><span class=\"p\">(</span><span class=\"n\">parseNode</span><span class=\"p\">(</span><span class=\"n\">INTEGER</span><span class=\"p\">,</span> <span class=\"n\">group</span><span class=\"p\">.</span><span class=\"n\">at</span><span class=\"p\">(</span><span class=\"n\">INTEGER</span><span class=\"p\">)),</span> <span class=\"nb\">true</span><span class=\"p\">);</span> <span class=\"c1\">// 添加整数部分子树</span>\n<span class=\"n\">root</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">addNode</span><span class=\"p\">(</span><span class=\"n\">parseNode</span><span class=\"p\">(</span><span class=\"n\">DOT</span><span class=\"p\">,</span> <span class=\"n\">group</span><span class=\"p\">.</span><span class=\"n\">at</span><span class=\"p\">(</span><span class=\"n\">DOT</span><span class=\"p\">)),</span> <span class=\"nb\">true</span><span class=\"p\">);</span> <span class=\"c1\">// 添加小数点</span>\n<span class=\"n\">root</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">addNode</span><span class=\"p\">(</span><span class=\"n\">parseNode</span><span class=\"p\">(</span><span class=\"n\">DECIMAL</span><span class=\"p\">,</span> <span class=\"n\">group</span><span class=\"p\">.</span><span class=\"n\">at</span><span class=\"p\">(</span><span class=\"n\">DECIMAL</span><span class=\"p\">)),</span> <span class=\"nb\">true</span><span class=\"p\">);</span> <span class=\"c1\">// 添加小数部分子树</span>\n</code></pre></div><h2>二、小结</h2><p>具体的过程说明、设计模式使用、设计的原因我还没来得及想好，后面更新到专栏。</p><p>这样折腾的好处：</p><ol><li>锻炼/复习一下设计模式</li><li>便于扩展</li><li>每个项目都是自己所做的工艺品，追求极致和完美，当然是很有满足感喽</li></ol><p>原本是打算再写个RomanStyle将数字转成罗马数字的，我将转换过程独立成四个阶段：<b>词法过滤、正则匹配、生成AST、遍历AST生成结果</b>。后面会尝试完成RomanStyle，以证明这个坑爹的设计是可取的（逃</p><p>呵呵，一个小模块就有2k行代码了，那CEval这个项目最终也不会很简单就是了。</p>","updated":"2017-09-22T14:24:44.000Z","canComment":false,"commentPermission":"anyone","commentCount":0,"collapsedCount":0,"likeCount":1,"state":"published","isLiked":false,"slug":"29589948","isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic3.zhimg.com/v2-8ecd6093851e4cda1271ba94c66f3cc2_r.png","links":{"comments":"/api/posts/29589948/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/19599592","id":"19599592","name":"设计模式"},{"url":"https://www.zhihu.com/topic/19554298","id":"19554298","name":"编程"},{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"}],"adminClosedComment":false,"titleImageSize":{"width":677,"height":442},"href":"/api/posts/29589948","excerptTitle":"","tipjarState":"inactivated","annotationAction":[],"sourceUrl":"","pageCommentsCount":0,"hasPublishingDraft":false,"snapshotUrl":"","publishedTime":"2017-09-22T22:24:44+08:00","url":"/p/29589948","lastestLikers":[{"bio":"Malt语言之父 （逃","isFollowing":false,"hash":"5a444f1fd85a11a13560e28426a83488","uid":826202252833325000,"isOrg":false,"slug":"liu-zhi-hang-78","isFollowed":false,"description":"我不懂，我不会，我不知道/惊恐\n\n起这名是为了让每本书都印上我的名字（逃","name":"目录","profileUrl":"https://www.zhihu.com/people/liu-zhi-hang-78","avatar":{"id":"v2-48f2a6a2360c8c19b12d783643fe7889","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false}],"summary":"CEval - 四则运算器（C++）源码：<a href=\"https://github.com/bajdcc/CEval\">bajdcc/CEval</a>最近把jMiniLang玩得差不多了，有点腻了。重温一下设计模式，这也不是重新造轮子，不必用高大上的LR分析去弄，这个正经C++专栏（雾）还是要来点C++干货的。回故一下曾经做的：LR分析（Java）一条龙工程——Pars…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"annotationDetail":null,"commentsCount":0,"likesCount":1,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"专业研究野生技术","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{},"favlists":{}},"me":{},"global":{},"columns":{"next":{}},"columnPosts":{},"columnSettings":{"colomnAuthor":[],"uploadAvatarDetails":"","contributeRequests":[],"contributeRequestsTotalCount":0,"inviteAuthor":""},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true},"favlistsByUser":{},"favlistRelations":{},"promotions":{},"switches":{"couldAddVideo":false},"draft":{"titleImage":"","titleImageSize":{},"isTitleImageFullScreen":false,"canTitleImageFullScreen":false,"title":"","titleImageUploading":false,"error":"","content":"","draftLoading":false,"globalLoading":false,"pendingVideo":{"resource":null,"error":null}},"drafts":{"draftsList":[],"next":{}},"config":{"userNotBindPhoneTipString":{}},"recommendPosts":{"articleRecommendations":[],"columnRecommendations":[]},"env":{"isAppView":false,"appViewConfig":{"content_padding_top":128,"content_padding_bottom":56,"content_padding_left":16,"content_padding_right":16,"title_font_size":22,"body_font_size":16,"is_dark_theme":false,"can_auto_load_image":true,"app_info":"OS=iOS"},"isApp":false},"sys":{}}</textarea>

    
    <script src="//static.zhihu.com/hemingway/common.88ebcfb3d810a398ff8a.js"></script>
<script src="//static.zhihu.com/hemingway/app.398b3cbc1a5a7ed4c9ca.js"></script>
<script src="//static.zhihu.com/hemingway/raven.4399bd4c70bb7f1e8291.js" async defer></script>
  </body>
</html>
