<!doctype html>
<html lang="zh-CN" class="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>【jMiniOS】设计思路 - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.801234ee6d0e1200c89b55e9d3bf896f.css" />
    <style></style>
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","wechatConfigAPI":"/api/wechat/jssdkconfig","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"28540783":{"contributes":[{"sourceColumn":{"lastUpdated":1497249764,"description":"玩玩有趣的东西","permission":"COLUMN_PUBLIC","memberId":10760740,"contributePermission":"COLUMN_PUBLIC","translatedCommentPermission":"all","canManage":true,"intro":"写写C++","urlToken":"learncpp","id":25963,"imagePath":"v2-bf63794c542fc73b11e17014b7e0d01d.jpg","slug":"learncpp","applyReason":"0","name":"学习C++","title":"学习C++","url":"https://zhuanlan.zhihu.com/learncpp","commentPermission":"COLUMN_ALL_CAN_COMMENT","canPost":true,"created":1483611626,"state":"COLUMN_NORMAL","followers":2487,"avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"activateAuthorRequested":false,"following":false,"imageUrl":"https://pic2.zhimg.com/v2-bf63794c542fc73b11e17014b7e0d01d_l.jpg","articlesCount":48},"state":"accepted","targetPost":{"titleImage":"https://pic1.zhimg.com/v2-64890af92346a518857a589904a8ff18_r.jpg","lastUpdated":1502802850,"imagePath":"v2-64890af92346a518857a589904a8ff18.jpg","permission":"ARTICLE_PUBLIC","topics":[1354,17103,3646],"summary":"前言项目地址：<a href=\"https://github.com/bajdcc/jMiniLang\">bajdcc/jMiniLang</a>演示视频：<a href=\"https://www.bilibili.com/video/av13294962\">【jMiniOS】脚本操作系统演示_野生技术协会_科技_bilibili_哔哩哔哩</a> 编程简书：<a href=\"http://www.jianshu.com/p/c7d819fbf873\">jMiniLang的设计思路</a>jMiniLang是一个Java实现的基于栈的解释器，包含了语法分析和虚拟机等两大内容。基于这个虚拟机呢，用脚本搭建了…","copyPermission":"ARTICLE_COPYABLE","translatedCommentPermission":"all","likes":0,"origAuthorId":0,"publishedTime":"2017-08-15T21:14:11+08:00","sourceUrl":"","urlToken":28540783,"id":3604077,"withContent":false,"slug":28540783,"bigTitleImage":true,"title":"【jMiniOS】设计思路","url":"/p/28540783","commentPermission":"ARTICLE_ALL_CAN_COMMENT","snapshotUrl":"","created":1502802851,"comments":0,"columnId":25963,"content":"","parentId":0,"state":"ARTICLE_PUBLISHED","imageUrl":"https://pic1.zhimg.com/v2-64890af92346a518857a589904a8ff18_r.jpg","author":{"bio":"专业研究野生技术","isFollowing":false,"hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"slug":"bajdcc","isFollowed":false,"description":"专业研究野生技术 https://github.com/bajdcc","name":"陈安","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},"memberId":10760740,"excerptTitle":"","voteType":"ARTICLE_VOTE_CLEAR"},"id":768755}],"title":"【jMiniOS】设计思路","author":"bajdcc","content":"<h2>前言</h2><p>项目地址：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jMiniLang\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/jMiniLang<i class=\"icon-external\"></i></a></p><p>演示视频：<a href=\"http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av13294962\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">【jMiniOS】脚本操作系统演示_野生技术协会_科技_bilibili_哔哩哔哩<i class=\"icon-external\"></i></a></p><p><br></p><a class=\"video-box\" href=\"http://link.zhihu.com/?target=http%3A//www.bilibili.com/video/av13294962/\" target=\"_blank\" data-video-id=\"880899315634159616\" data-video-playable=\"true\" data-name=\"【jMiniOS】脚本操作系统演示_野生技术协会_科技_bilibili_哔哩哔哩\" data-poster=\"https://pic2.zhimg.com/v2-d5f56e840fa0b5784d03a46c439afc65.jpg\" data-lens-id=\"\">              <img class=\"thumbnail\" src=\"https://pic2.zhimg.com/v2-d5f56e840fa0b5784d03a46c439afc65.jpg\">              <span class=\"content\">                <span class=\"title\">【jMiniOS】脚本操作系统演示_野生技术协会_科技_bilibili_哔哩哔哩<span class=\"z-ico-extern-gray\"></span><span class=\"z-ico-extern-blue\"></span></span>                <span class=\"url\"><span class=\"z-ico-video\"></span>http://www.bilibili.com/video/av13294962/</span>              </span>            </a>            <p>编程</p><p>简书：<a href=\"http://link.zhihu.com/?target=http%3A//www.jianshu.com/p/c7d819fbf873\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">jMiniLang的设计思路<i class=\"icon-external\"></i></a></p><p>jMiniLang是一个Java实现的基于栈的解释器，包含了语法分析和虚拟机等两大内容。</p><p>基于这个虚拟机呢，用脚本搭建了一个简单的“操作系统”。本来只是用来测试下解释器的语法特性的，后来把一些想法加了进去。</p><p>截图在<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jMiniLang/releases\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/jMiniLang<i class=\"icon-external\"></i></a>里面，操作视频在。<br>系统的架构倒是比较“另类”的，它完全就是由管道和互斥来构造的。对于进程而言，无非就是阻塞来实现进程同步，管道一方面可以形成阻塞，另一方面可以实现进程间通信，可以说，管道机制非常有效。</p><p>下面就简单讲讲jMiniOS系统的设计思路。几个部分：<b>语法特性、同步机制、系统架构</b>。(一共就3张图)</p><h2>语法特性</h2><p>语法分析用LALR的，只要设计好BNF就能解析，parser涉及的内容太多，这里就略了。这里说下某些特性的实现：闭包和协程。</p><h2>闭包</h2><p>说到闭包，就会提到lambda。实现闭包，首先，<b>系统需要能够动态地返回函数</b>，其次，<b>返回的函数中会引用到函数体外部的变量</b>。</p><p><br></p><noscript><img src=\"https://pic3.zhimg.com/v2-08e8dd7f761434a776463692cdd48ba2_b.png\" data-rawwidth=\"325\" data-rawheight=\"162\" class=\"content_image\" width=\"325\"></noscript><img src=\"data:image/svg+xml;utf8,&amp;lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='325'%20height='162'&amp;gt;&amp;lt;/svg&amp;gt;\" data-rawwidth=\"325\" data-rawheight=\"162\" class=\"content_image lazy\" width=\"325\" data-actualsrc=\"https://pic3.zhimg.com/v2-08e8dd7f761434a776463692cdd48ba2_b.png\"><p><br></p><p>上图中的fact会返回一个lambda（fk其实是多余的，只是语法实现功能有限）叫fk，fk中的一句\"call f(n-1)\"引用到了外层fact函数的参数f。</p><p><b>那这个特性如何去实现呢？</b></p><p>想像一下我现在执行fact函数时，发生的情况：</p><ol><li>f压栈，调用fact</li><li>栈上取参f，放入数据栈</li><li>返回一个lambda(图中是fk)</li></ol><p>这时执行这个返回的lambda(注意它有一个参数n)：</p><ol><li>参数n压栈，调用lambda</li><li>栈上取参n</li><li>如果n大于0，跳到4，否则跳到5</li><li>执行f(n-1)，乘上n，再返回</li><li>返回1</li></ol><p>这里的问题是：<b>在lambda中，如何执行f(n-1)呢？</b>进一步要思考的问题：<b>返回的lambda知晓不知晓f的存在？什么时候知晓的？</b>解决了问题，就能实现闭包。</p><p><b>便于描述，将图中的f称作一个闭包(变量)。</b></p><p><b>思路：动态解决+静态解决。</b></p><p>从语法分析开始说起，解析fact函数之前，fk函数已经解析完毕了，这是由LR分析的特点决定的。在解析fk函数之前，fact的参数f已经被我放入一层层的符号表中，不管找到的这个f是在哪一层函数中的，只要找到了，确认不是引用错误就行。</p><h2><b>步骤一：静态解决</b></h2><p>在符号表中找到f后，接下来，我要让fk函数进行<b>自检</b>。由于这时fk函数已经是AST中的一个结点了，只要递归调用自检函数就可以了。自检很简单，凡是引用某个变量的，就将引用对象放入<b>引用表</b>中。然后，看一下fk函数的<b>参数表</b>。最终，<b>引用表-参数表=闭包</b>。</p><p>这样，通过自检，我在解析fact的过程中知道了fk的闭包。</p><p>解析好语法树后，就可以生成指令了。对于fk这个lambda，生成指令包含两大部分——实现部分和赋值部分。</p><p>实现部分就是将fk函数里面代码翻成指令(然后知道了fk第一行指令的位置fk_line)，好理解。</p><p>赋值部分就是生成lambda并赋值给fk，指令类似于\"load_lambda fk_line\"，这是因为对lambda而言，需要做一些额外的工作，因为这是动态语言，所以必须生成一个为function的动态类型。那闭包又该如何处理呢？对于函数中的闭包需要“额外优待”，即生成指令时将这些变量载入进去，每个变量有个自己的编号，载入这些编号就可以了。所以对于图中的fk，在\"load_lambda fk_line\"前肯定要有个声明闭包的指令\"load_lambda_reference f\"，这样<b>在生成动态类型时，会将外部变量f的值绑定到fk函数中</b>。</p><h2><b>步骤二：动态解决</b></h2><p>动态运行的指令类似于(这里简化了，跟项目生成的有差别)：</p><p>【fk函数的实现指令】<br>[1000] 载入参数n到数据栈<br>....<br>[1010] 返回</p><p>【fact函数的实现指令】<br>[2000] 载入参数f到数据栈<br>[2001] 将f放到额外的一个栈中(用于存放闭包)<br>[2002] 加载函数fk，地址1000，这时检测额外栈中有闭包，故生成动态类型RuntimeFunction时加上一个闭包f</p><p>【调用fact函数返回的lambda--fk】<br>[3000] 将n取出并保存到数据栈中<br>....<br>[3005] \"call f(n-1)\"对应的指令，这时要加载f，到符号表中找肯定找不到(因为当前执行的环境中没有f)，因而尝试到当前环境fk的闭包里去找，找到后执行它并返回</p><h2><b>闭包部分总结</b></h2><ol><li>语法分析部分：AST中查找闭包(变量)，将闭包的信息存入AST结点ExpFunc中</li><li>指令生成部分：在AST中的调用结点ExpInvoke中，如果发现了闭包信息，就添加额外的指令load_lambda_reference(本项目中是压栈指令，将闭包的编号压栈，再将闭包数量压栈)</li><li>运行时部分：执行到load_lambda指令时，确认是否有闭包在栈中，如果有，将其添加到运行时函数类型RuntimeFunction中</li><li>查找变量：先在当前(函数)域中查找正常声明的变量(用var声明的)，找不到，再从域中查找闭包(变量)，再找不到，从上一层域中找，以此类推</li></ol><h2>协程</h2><p><br></p><noscript><img src=\"https://pic2.zhimg.com/v2-8a2afb263c74059d442b22609ce0fc61_b.png\" data-rawwidth=\"262\" data-rawheight=\"229\" class=\"content_image\" width=\"262\"></noscript><img src=\"data:image/svg+xml;utf8,&amp;lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='262'%20height='229'&amp;gt;&amp;lt;/svg&amp;gt;\" data-rawwidth=\"262\" data-rawheight=\"229\" class=\"content_image lazy\" width=\"262\" data-actualsrc=\"https://pic2.zhimg.com/v2-8a2afb263c74059d442b22609ce0fc61_b.png\"><p><br></p><p>认识协程，先想一个问题：实现对[a,b]中每个整数的依次处理(比方，实现[1,100]这一百个数的依次打印)</p><p>【简单方法】for循环100个数，分别调用之<br>【一般方法】先生成一个数组，for循环放入1~100这100个数，然后对数组遍历<br>【另类方法】协程，如图所示</p><p>上面除另类方法外，应该都好理解。另类方法其实是一种新的语法特性，协程。</p><p>在上面的问题上增加难度，现在对[a,b]进行扩展，变成[a,正无穷)，如何？</p><p>【简单方法】依然可以<br>【一般方法】数组占用了大量内存空间，程序gg<br>【另类方法】依然可以</p><p>再降低难度，将范围[a,b]变成列表{101,203,407,666,888}，列表里数是我胡乱写的，如何？</p><p>【简单方法】gg<br>【一般方法】将列表中的数依然放入数组并遍历<br>【另类方法】依然可以(yield 101,yield 203...)</p><p>需要3的倍数，...，再分别调用，如何？</p><p>【简单方法】可以<br>【一般方法】gg<br>【另类方法】魔性，\"foreach (var i : call g_range(1, INT_MAX) * 3) {}\"，改个数字即可</p><p>综上，协程确实在某些方法与传统方法有着差别。</p><p>项目中用yield声明协程函数，返回用\"yield n\"。</p><p>foreach搭配yield的使用，使得foreach每次迭代时，会调用一次协程函数，协程返回一个当前索引i，然后再执行foreach循环体。第二次循环调用的协程不会重新开始，而是在第一次循环的基础上<b>继续执行</b>，这，就是协程的精华。常规语法时，每次调用同一个函数，如果函数不依靠任何外部信息，那么每次返回的值都是相同的，而协程不一样，它每次被调用后，就“<b>自动暂停</b>”了。</p><p><b>协程要怎样实现呢？</b></p><p>协程的实现基于for循环。for的语法是\"for (声明指令; 判断指令; 迭代指令) {主体}\"；foreach的语法是\"foreach(var 变量名 : yield函数表达式){主体}\"。</p><p>for循环生成指令的主要步骤：</p><ol><li>生成声明指令</li><li>生成break和continue的label</li><li>生成判断指令</li><li>生成循环主体指令</li><li>生成迭代指令(如i++)</li></ol><p>而foreach生成指令的步骤：</p><ol><li>生成声明指令</li><li>生成break和continue的label</li><li><b>调用协程函数(函数如果返回空则break)</b></li><li>生成循环主体指令</li><li>生成迭代指令(如i++)</li></ol><p>在foreach中协程一直存在，既然它的状态是持续的，因而必然要保存其状态。</p><p>先设计好一些指令：</p><ol><li>iyldl 协程返回</li><li>iyldr 协程进入</li><li>iyldx 协程销毁</li><li>iyldy 协程创建</li><li>iyldi 协程栈数据入栈</li><li>iyldo 协程栈数据出栈</li></ol><p>上述指令负责程序在foreach间与协程函数间进行切换，以及数据交换等操作。</p><h2>【协程函数翻译指令】</h2><p>无非是原有的return指令变成了yield return指令。原先：ipushXXX/iret；现在：ipushXXX/iyldi/iyldl，即数据压栈、数据进协程栈、协程切回。</p><h2>【调用者foreach指令】</h2><p><b>调用协程的具体过程</b></p><p>判断协程是否初始化(首次创建)，如果没有创建，就初始化。</p><p>初始化操作：</p><ol><li>调用类型：ipush 调用类型/iyldi</li><li>协程传参：ipush 每个参数/后面带iyldi</li><li>ipush 地址：传协程入口地址</li><li>iyldy：创建协程，此时协程栈的大小=1(调用类型)+参数数量+1(地址)</li></ol><p>如果已经初始化完成，进行：</p><ol><li>iyldr：切换到协程</li><li>iyldo：将数据出协程栈，入数据栈</li><li>ijnan：判断数据合法性，如果是null，就退出foreach循环</li></ol><p><b>协程的创建</b></p><ol><li>读取协程栈中的数据：调用类型+协程参数+协程地址。</li><li>切换到协程并执行</li></ol><p>由于有协程栈和调用栈，所以栈与栈间存在父子关系。协程是当前调用栈创建出的，因为要设置父子关系parent。这样，当协程返回时，只要找到其parent就可以了(子找父)。反过来时，父根据hash表找到子，这是因为同一时刻同一层次也只有唯一一个协程存在。</p><p><b>循环出口的清理工作</b></p><p>执行iyldx，销毁创建的协程。</p><h2>协程部分总结</h2><ol><li>调用栈部分：协程就是一种调用栈，而调用栈可以创建协程(调用)栈，反之亦可，可见调用栈存在层级关系，栈间的切换可以用类似树中父子关系实现</li><li>协程传参：通过协程栈数据通道进行传参，这个通道维系当前调用栈和产生的协程调用栈，且协程调用栈和普通调用栈一样，也有自己的数据栈和函数栈</li><li>指令部分：由上述设计的6种指令组成，不过还可进一步简化，值得注意的是，协程的创建只能创建一次，后一次必须检测协程是否已存在，避免重复创建</li></ol><h2>同步机制</h2><p>jMiniLang采用的单线程模拟多进程的方式，这种比较容易实现。</p><p>多进程的世界，有两个典型问题——互斥量、信号量。进程的状态我设置得很简单——阻塞和非阻塞。把互斥量、信号量这两个问题解决了，就ok。</p><p>从时间来看，互斥量的使用场景应是激烈竞争、占用时间少的情况；信号量的情况是竞争不激烈、占用时间长。基于此情况，我将多数操作采用<b>自旋锁</b>实现，如锁定单变量的操作等。将少数耗时操作用信号量去做，即让进程休眠，节省开销。</p><h2>互斥量</h2><p>自旋锁实现是很简单的，就是轮循。由于解释器是单线程的，因此非常easy。</p><p>我添加了全局共享变量，让互斥量有用武之地。比如进程间的等待操作，将pid挂到等待列表上，而读写等待列表的操作是互斥的，且读写操作很快。</p><p>代码写来就是\"lock(var);操作...;unlock(var);\"，而lock的操作就是\"while(检测var有锁不，有就锁定);操作...\"，unlock的操作\"直接解锁var变量\"。其中这个while就是轮询。事实上，这些轮询操作都可以转化为用信号量去做，只是要设计一些等待列表。上面说到使用场景不怎么花时间(就改个变量)，而用信号量会让进程休眠，强行进程切换，因此用信号量反而不适宜。</p><p><b>PS：jMiniLang中的互斥量是用自旋锁实现的，这不意味着所有互斥量都是用自旋锁做的。</b></p><h2>信号量</h2><p>这里，信号量我主要用block()和wakeup()，就是阻塞和唤醒。这两个方法的使用不是在用户代码层面，是在虚拟机层面。</p><p><b>管道与信号量</b></p><p>本系统中我设计了管道，相信管道这一概念已非常普及了。我没有直接提供操作信号量的API，而是提供了管道的API。</p><p>管道的操作：</p><ol><li>创建/销毁</li><li>读/写</li></ol><p>其中，管道读是一个阻塞操作，利用这一阻塞，可以用管道去实现信号量的功能。</p><p>原理也很简单，设计的命名管道，每一管道有缓冲区。读：如果缓冲区无数据，就阻塞，否则取数据；写：向缓冲区写数据，并唤醒阻塞的进程。</p><p>另外，进程等待(join)操作也是阻塞的。类似的耗时操作都可以改成阻塞的。</p><h2>系统架构</h2><p>用jMiniLang解释器做个仿OS的程序，姑且称作jMiniOS吧。</p><p>它的设计理念：</p><ol><li>基于互斥量和信号量</li><li>仅有共享变量服务(全局set/get)和管道服务</li><li>微服务架构service</li><li>多进程间的输入/输出流</li><li>中断例程task(流实现)</li></ol><h2>服务组成</h2><noscript><img src=\"https://pic4.zhimg.com/v2-c883752c3760f54b5e655c5353559bc7_b.png\" data-rawwidth=\"741\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"741\" data-original=\"https://pic4.zhimg.com/v2-c883752c3760f54b5e655c5353559bc7_r.png\"></noscript><img src=\"data:image/svg+xml;utf8,&amp;lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='741'%20height='354'&amp;gt;&amp;lt;/svg&amp;gt;\" data-rawwidth=\"741\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"741\" data-original=\"https://pic4.zhimg.com/v2-c883752c3760f54b5e655c5353559bc7_r.png\" data-actualsrc=\"https://pic4.zhimg.com/v2-c883752c3760f54b5e655c5353559bc7_b.png\"><p><br></p><p>模拟IRQ的系统服务task：</p><ol><li>remote 用户界面输入输出</li><li>task 微服务代理</li><li>print 控制台debug输出</li><li>signal 信号(如poweroff)</li></ol><p>用户服务service(目前实现的)：system util ui net</p><h2>微服务架构</h2><p>三种对象：客户端(调用者)、代理端(系统服务)、服务端(被调用者)</p><p>下面区别三种对象：<b>客户端、代理端、服务端</b></p><ol><li>客户端（调用者）<br>调用方法：客户端进程调用g_task_get/g_task_get_fast/g_task_get_fast_arg方法，获取数据</li><li>代理端（充当中介）<br>已实现的task_handler，它的目的是连接客户端和服务端</li><li>服务端（服务者）<br>这方面要自己实现</li></ol><p>调用顺序：</p><ol><li>客户端调用task_get_fast等方法</li><li>task_get_fast安排好请求数据，触发int#1服务中断</li><li>中断会调用task_handler代理方法</li></ol><h2>客户端向代理端发送消息</h2><ol><li>准备请求数据</li><li>锁定等待队列</li><li>将当前进程添加至代理端的等待队列中</li><li>解锁队列</li><li>报告服务中断例程</li><li>发送消息事件给中断例程，使之调用task_handler</li><li>此时代理端会向服务端发送请求</li><li>等待代理端处理完毕</li></ol><h2>代理端处理客户端的消息</h2><ol><li>锁定等待队列</li><li>取最早等待的进程，移除它</li><li>解锁队列</li><li>读取客户端的数据</li><li>唤醒服务端，这时服务端在处理请求</li><li>连接服务端</li><li>防止多个代理端同时请求服务端，用管道做阻塞</li><li>处理完毕，唤醒客户端</li></ol><h2>此架构的好处</h2><p>如果没有代理端，那么客户端和服务端直接相连，由于服务端只有一条输入管道，那么多个客户端发送的数据会发生冲突，因此多个客户端的请求只能一个个来，代理端就是这个作用，维护一个等待队列。</p><p>另外，服务端的接口不会暴露给客户端，保证了安全。</p><h2>进程传输流</h2><p>jMiniOS提供了一个简单的shell，用来执行一些程序，依照linux，采用管道去处理父/子进程间的输入输出流。</p><p>以最简单的pipe函数为例：</p><ol><li>获取本pid的输入流句柄</li><li>获取本pid的输出流句柄</li><li>读取输入流，在读取操作中将数据传给输出流</li></ol><p>当最内层的进程销毁输出流后，流将被链式销毁，直到最外层进程。实现ctrl+c的思路：销毁各子进程的输入流、创建SIGKILL类似的共享变量。</p><p>由于我未实现kill_process函数，所以每个进程只能自己退出，不会强行被kill，这样只要所有进程都退出，就说明堵塞的调用没有问题。</p><h2>总结</h2><p>从15年开始第一行代码，到现在约莫2W行(除去废话)，每次加个新功能要想半天+查错N天，但是还是坚持下来了。写上面的闭包和协程时因为当时懒没多少注释，还打log半天才搞懂当时的设计思路，所以写写总结也是必要的，毕竟是坚持得最久的一个repo了。</p><p>把parser+vm+ui结合起来，除了fastjson和log4j也没用其他库，白手起家，自娱自乐~</p>","updated":"2017-08-15T13:14:11.000Z","canComment":false,"commentPermission":"anyone","commentCount":6,"collapsedCount":0,"likeCount":20,"state":"published","isLiked":false,"slug":"28540783","isTitleImageFullScreen":true,"rating":"none","titleImage":"https://pic1.zhimg.com/v2-64890af92346a518857a589904a8ff18_r.jpg","links":{"comments":"/api/posts/28540783/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/19554298","id":"19554298","name":"编程"},{"url":"https://www.zhihu.com/topic/19601369","id":"19601369","name":"编译原理"},{"url":"https://www.zhihu.com/topic/19561132","id":"19561132","name":"Java"}],"adminClosedComment":false,"titleImageSize":{"width":1366,"height":768},"href":"/api/posts/28540783","excerptTitle":"","column":{"slug":"learncpp","name":"学习C++"},"tipjarState":"inactivated","annotationAction":[],"sourceUrl":"","pageCommentsCount":6,"hasPublishingDraft":false,"snapshotUrl":"","publishedTime":"2017-08-15T21:14:11+08:00","url":"/p/28540783","lastestLikers":[{"bio":"主攻java，至少有一门要拿的出手的语言","isFollowing":false,"hash":"c4052648a55b6e4a6fdd97b6dd555e6c","uid":705325738768728000,"isOrg":false,"slug":"wthhhhh20","isFollowed":false,"description":"以前我是你，后来你是我","name":"Waston","profileUrl":"https://www.zhihu.com/people/wthhhhh20","avatar":{"id":"7393fc9cc3b046f8b9cc35dbbdbf118c","template":"https://pic1.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":"较为文艺的程序猿,其实我比较喜欢攻城狮这个名字","isFollowing":false,"hash":"96ba4848808f0d0c0b2c3ef2619f66a5","uid":659778421467516900,"isOrg":false,"slug":"flycash","isFollowed":false,"description":"生于广东，在南京上大学，在上海工作","name":"flycash","profileUrl":"https://www.zhihu.com/people/flycash","avatar":{"id":"v2-871ff49690bdd0d21bb695375e98c7b4","template":"https://pic1.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":"","isFollowing":false,"hash":"1262175165bcb049ff6f92b3f22fbe01","uid":28791351017472,"isOrg":false,"slug":"sky-15","isFollowed":false,"description":"","name":"sky","profileUrl":"https://www.zhihu.com/people/sky-15","avatar":{"id":"da8e974dc","template":"https://pic1.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":"不学无术","isFollowing":false,"hash":"3c4f4209b348b8604a5364aae9ffacce","uid":27569223106560,"isOrg":false,"slug":"Dr-hao","isFollowed":false,"description":"","name":"Petzold","profileUrl":"https://www.zhihu.com/people/Dr-hao","avatar":{"id":"c9c7c0ea9","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":"Moonport City FC","isFollowing":false,"hash":"62ae9636c654dcd0c2dfcec5a2908a9a","uid":681558952152666100,"isOrg":false,"slug":"linker-84","isFollowed":false,"description":"","name":"pewant","profileUrl":"https://www.zhihu.com/people/linker-84","avatar":{"id":"v2-83dc13a3048cd39d35e65dafffc38573","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false}],"summary":"<img src=\"http://pic3.zhimg.com/v2-08e8dd7f761434a776463692cdd48ba2_200x112.png\" data-rawwidth=\"325\" data-rawheight=\"162\" class=\"origin_image inline-img zh-lightbox-thumb\" data-original=\"http://pic3.zhimg.com/v2-08e8dd7f761434a776463692cdd48ba2_r.png\">前言项目地址：<a href=\"https://github.com/bajdcc/jMiniLang\">bajdcc/jMiniLang</a>演示视频：<a href=\"https://www.bilibili.com/video/av13294962\">【jMiniOS】脚本操作系统演示_野生技术协会_科技_bilibili_哔哩哔哩</a> 编程简书：<a href=\"http://www.jianshu.com/p/c7d819fbf873\">jMiniLang的设计思路</a>jMiniLang是一个Java实现的基于栈的解释器，包含了语法分析和虚拟机等两大内容。基于这个虚拟机呢，用脚本搭建了…","reviewingCommentsCount":0,"meta":{"previous":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic2.zhimg.com/50/v2-226a2785025c112f09feaa2c5d6d0b89_xl.jpg","links":{"comments":"/api/posts/27979309/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19554298","id":"19554298","name":"编程"},{"url":"https://www.zhihu.com/topic/19625716","id":"19625716","name":"算法与数据结构"},{"url":"https://www.zhihu.com/topic/19635471","id":"19635471","name":"可视化"}],"adminClosedComment":false,"href":"/api/posts/27979309","excerptTitle":"","author":{"bio":"专业研究野生技术","isFollowing":false,"hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"slug":"bajdcc","isFollowed":false,"description":"专业研究野生技术 https://github.com/bajdcc","name":"陈安","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},"content":"<p><b>【0708更新】</b></p><p>完善了动画，支持元素的插入与删除，并将结果压成视频传至b站<a href=\"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av12667435/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">【算法可视化计划】01 堆排序<i class=\"icon-external\"></i></a>。</p><p>这个js模板非常棒，看来以后的各种算法的可视化就靠它了。</p><p><br></p><a class=\"video-box\" href=\"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av12667435/\" target=\"_blank\" data-video-id=\"874227715681681408\" data-video-playable=\"true\" data-name=\"【算法可视化计划】01 堆排序_野生技术协会_科技_bilibili_哔哩哔哩\" data-poster=\"https://pic3.zhimg.com/v2-3397c995ce60499c82960dc00a53a726.jpg\" data-lens-id=\"\">              <img class=\"thumbnail\" src=\"https://pic3.zhimg.com/v2-3397c995ce60499c82960dc00a53a726.jpg\">              <span class=\"content\">                <span class=\"title\">【算法可视化计划】01 堆排序_野生技术协会_科技_bilibili_哔哩哔哩<span class=\"z-ico-extern-gray\"></span><span class=\"z-ico-extern-blue\"></span></span>                <span class=\"url\"><span class=\"z-ico-video\"></span>https://www.bilibili.com/video/av12667435/</span>              </span>            </a>            <p><br></p><p>----------------------------------------------</p><p>原作者链接文章：<a href=\"https://link.zhihu.com/?target=http%3A//www.benfrederickson.com/heap-visualization/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Visualizing min-heap algorithms with D3.js<i class=\"icon-external\"></i></a></p><p>稍微改了下，地址在<a href=\"https://link.zhihu.com/?target=https%3A//github.com/bajdcc/ACM/tree/master/ds/heap\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/ACM<i class=\"icon-external\"></i></a>，在线演示：<a href=\"https://link.zhihu.com/?target=https%3A//bajdcc.github.io/html/heap.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Visualizing min-heap algorithms with D3.js<i class=\"icon-external\"></i></a></p><p>动画：</p><p><br></p><img src=\"https://pic2.zhimg.com/50/v2-0adfc512f7340e17a54ea7cf3bd13441_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"327\" data-thumbnail=\"https://pic2.zhimg.com/50/v2-0adfc512f7340e17a54ea7cf3bd13441_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic2.zhimg.com/50/v2-0adfc512f7340e17a54ea7cf3bd13441_r.jpg\"><p></p><p></p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":27979309,"publishedTime":"2017-07-19T15:46:08+08:00","url":"/p/27979309","title":"【D3.js】建堆动画","summary":"<b>【0708更新】</b>完善了动画，支持元素的插入与删除，并将结果压成视频传至b站<a href=\"https://www.bilibili.com/video/av12667435/\">【算法可视化计划】01 堆排序</a>。这个js模板非常棒，看来以后的各种算法的可视化就靠它了。 ----------------------------------------------原作者链接文章：<a href=\"http://www.benfrederickson.com/heap-visualization/\">Visualizing min-heap al…</a>","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":3,"likesCount":22},"next":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic1.zhimg.com/50/v2-15c59a7711011767c2279f9a23e16c78_xl.jpg","links":{"comments":"/api/posts/29008180/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19554298","id":"19554298","name":"编程"},{"url":"https://www.zhihu.com/topic/19561132","id":"19561132","name":"Java"},{"url":"https://www.zhihu.com/topic/19552686","id":"19552686","name":"操作系统"}],"adminClosedComment":false,"href":"/api/posts/29008180","excerptTitle":"","author":{"bio":"专业研究野生技术","isFollowing":false,"hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"slug":"bajdcc","isFollowed":false,"description":"专业研究野生技术 https://github.com/bajdcc","name":"陈安","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},"content":"<p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt%23L95\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/jMini</span><span class=\"invisible\">Lang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></p><p>演示GIF(1.57MB)，控制台输出效果(还有parser/vm/ui)自己实现：</p><img src=\"http://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_b.gif\" data-rawwidth=\"810\" data-rawheight=\"610\" data-thumbnail=\"http://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"810\" data-original=\"http://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_r.gif\"><h2>信号量与PV原语</h2><p><b>信号量</b>为正数代表有<u>空闲资源</u>，为零与负数代表<u>没有空闲资源</u>。负数的绝对值代表等待的进程个数。信号量用<b>（S，Q）</b>表示，S是非负初值的整型变量，Q为进程等待队列。</p><p><b>P原语（阻塞）</b>：令S=S-1，若S&amp;gt;=0，进程继续执行，否则该进程变为等待状态，入队列Q</p><p><b>V原语（唤醒）</b>：令S=S+1，若S&amp;gt;0，进程继续执行，否则释放队列Q中第一个等待信号量的进程</p><p>实现互斥：令S=1。</p><p><br></p><h2>用管道语义实现PV操作</h2><p>当前jMiniOS支持的管道操作：</p><ol><li>create_pipe，创建管道，返回句柄</li><li>write_pipe，向管道中写入一个字符（非堵塞）</li><li>read_pipe，从管道中不断读取字符流（堵塞）</li><li>read_pipe_once，从管道中读取一个字符（堵塞）</li><li>destroy_pipe，销毁管道</li></ol><p>用管道实现信号量：</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>var g_create_semaphore = func ~(name, n) {\n    if (call g_query_pipe(name)) {\n        return;\n    }\n    var pipe = call g_create_pipe(name);\n    call g_write_pipe(pipe, call g_string_rep(\"*\", n));\n    return pipe;\n};\nexport \"g_create_semaphore\";\nvar g_use_semaphore = func ~(name) {\n    return call g_create_pipe(name);\n};\nexport \"g_use_semaphore\";\nvar g_destroy_semaphore = func ~(handle) {\n    call g_destroy_pipe_once(handle);\n};\nexport \"g_destroy_semaphore\";\nvar g_lock_semaphore = func ~(handle) {\n    call g_read_pipe_once(handle);\n};\nexport \"g_lock_semaphore\";\nvar g_unlock_semaphore = func ~(handle) {\n    call g_write_pipe(handle, \"*\");\n};\nexport \"g_unlock_semaphore\";\n</code></pre></div><p><b>关键：</b></p><ol><li>创建管道后，信号量的初始值=管道中存储的字符个数，即管道中的内容=信号量中可用资源。</li><li>P操作 = 向管道中写一字符</li><li>V操作 = 从管道中读一字符</li><li>Mutex实现，create_mutex = create_semaphore(1)</li></ol><h2>实现哲学家就餐问题</h2><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>/* 哲学家就餐问题 */\nvar stage_philo = func ~() {\n    call word_typewrite(\"演示哲学家就餐问题！    \\n\", 100);\n    var print_mutex = call g_create_mutex(\"philo_print\");\n    foreach (var i : call g_range(1, 5)) {\n        call g_create_semaphore(\"fork_\" + i, 1); // 每个叉最多能使用一次\n    }\n    var handles = [];\n    var philo = func ~(args) { // philo = 新建进程， args = 参数\n        var eat = call g_map_get(args, \"eating\");\n        var o = call g_map_get(args, \"out\");\n        var id = call g_map_get(args, \"id\");\n        var left_id = call g_map_get(args, \"left_id\"); // 左叉ID\n        var right_id = call g_map_get(args, \"right_id\"); // 右叉ID\n        var left = call g_use_semaphore(\"fork_\" + left_id); // 左叉信号量\n        var right = call g_use_semaphore(\"fork_\" + right_id); // 右叉信号量\n        call eat(o, \"Philosophy#\" + id + \" ready\");\n        foreach (var j : call g_range(1, 10)) { // 吃十次才饱\n            call g_lock_semaphore(left); // P左叉\n            call eat(o, \"Philosophy#\" + id + \" is using fork#\" + left_id);\n            call g_lock_semaphore(right); // P右叉\n            call eat(o, \"Philosophy#\" + id + \" is using fork#\" + right_id);\n            call eat(o, \"Philosophy#\" + id + \" is eating. Process: \" + j + \"0%\");\n            call g_unlock_semaphore(left); // V左叉\n            call g_unlock_semaphore(right); // V右叉\n        }\n        call eat(o, \"Philosophy#\" + id + \" OK\");\n    };\n    var eating = func ~(out, str) { // 输出\n        var pm = call g_use_mutex(\"philo_print\");\n        call g_lock_mutex(pm);\n        foreach (var c : call g_range_string(str)) {\n            call g_write_pipe(out, c);\n        }\n        call g_write_pipe(out, '\\n');\n        call g_task_sleep_ms(100);\n        call g_unlock_mutex(pm);\n    };\n    foreach (var j : call g_range(1, 5)) {\n        var args = {}; // 传参\n        call g_map_put(args, \"eating\", eating);\n        call g_map_put(args, \"out\", out);\n        call g_map_put(args, \"id\", j);\n        call g_map_put(args, \"left_id\", (j == 1) ? 5 : (j - 1));\n        call g_map_put(args, \"right_id\", (j == 5) ? 1 : (j + 1));\n        var h = call g_create_user_process_args(philo, args); // 新建进程\n        call g_array_add(handles, h);\n        call g_task_sleep(1);\n    }\n    call g_join_process_array(handles);\n    foreach (var k : call g_range(1, 5)) {\n        call g_destroy_semaphore(call g_use_semaphore(\"fork_\" + k)); // 销毁\n    }\n    call g_destroy_mutex(call g_use_mutex(\"philo_print\")); // 销毁\n};\n</code></pre></div><p><br></p><h2>总结</h2><p>从实例上看，哲学家不是同时开始就餐的，而是陆续就餐，同时就餐肯定会导致死锁问题。所以要有一定的防死锁和饥饿的解法，网上也有很多，有一种管程的解法。</p><p>例子中<b>每个哲学家不会知道其他哲学家的状态</b>，因此肯定会有缺陷啦，假如先让A就餐，然后A吃完再唤醒其他人，那就好办了。</p><p><b>唤醒</b>语义，好东西，想想linux中的进程状态实现，soga。因此，我们的程序除了要支持lock/unlock之外，还要支持wait/notify，下回分解。</p><p><br></p><p>===========================================</p><h2>0903 更新：用管程实现（jMiniLang语言）</h2><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>/* 哲学家就餐问题 - 管程解决 */\nvar stage_philo2 = func ~() {\n    call word_typewrite(\"【管程】演示哲学家就餐问题！    \\n\", 100);\n    call g_create_mutex(\"philo_print\");\n    call g_create_mutex(\"philo_monitor\");\n    var states = [];\n    call g_array_add(states, g_null);\n    foreach (var i : call g_range(1, 5)) {\n        call g_create_semaphore(\"philo_\" + i, 1); // 记录每个哲学家的状态（管程）\n        call g_array_add(states, \"thinking\"); // 开始时哲学家都在思考\n    }\n    var handles = [];\n    var philo2 = func ~(args) {\n        var eat = call g_map_get(args, \"eating\"); // 拿参数\n        var states = call g_map_get(args, \"states\");\n        var o = call g_map_get(args, \"out\");\n        var id = call g_map_get(args, \"id\");\n        var left_id = call g_map_get(args, \"left_id\");\n        var right_id = call g_map_get(args, \"right_id\");\n        var monitor = call g_use_mutex(\"philo_monitor\");\n        call eat(o, \"Philosophy#\" + id + \" ready\");\n        var enter = func ~() { // 进入临界区\n            var monitor = call g_use_mutex(\"philo_monitor\");\n            call g_lock_mutex(monitor); // mutex自带等待队列\n            call g_printdn(\"Philosophy#\" + id + \" entered critical section\");\n        };\n        var leave = func ~() { // 离开临界区\n            call g_printdn(\"Philosophy#\" + id + \" leaved critical section\");\n            var monitor = call g_use_mutex(\"philo_monitor\");\n            call g_unlock_mutex(monitor);\n        };\n        var wait = func ~(_id) { // 等待信号\n            var sem = call g_use_semaphore(\"philo_\" + _id);\n            call g_printdn(\"Philosophy#\" + _id + \" waiting\");\n            call g_lock_mutex(sem); // semaphore自带等待队列\n        };\n        var signal = func ~(_id) { // 发出信号\n            var sem = call g_use_semaphore(\"philo_\" + _id);\n            call g_unlock_mutex(sem);\n            call g_printdn(\"Philosophy#\" + _id + \" received signal\");\n        };\n        var test = func ~(_id) { // 测试哲学家是否具备进餐条件\n            var _left_id = (_id == 1) ? 5 : (_id - 1);\n            var _right_id = (_id == 5) ? 1 : (_id + 1);\n            if ((call g_array_get(states, _left_id) != \"eating\") &amp;amp;&amp;amp; // 如果左右都不在进餐\n                (call g_array_get(states, _right_id) != \"eating\") &amp;amp;&amp;amp;\n                (call g_array_get(states, _id) == \"hungry\")) { // 且自己为饥饿状态\n                call signal(_id); // 发出就餐信号\n            } else {\n                call g_printdn(\"Test failed. #\" + _left_id + \": \" + call g_array_get(states, _left_id) +\n                    \", #\" + _right_id + \": \" + call g_array_get(states, _right_id) + \", #\" +\n                    _id + \": \" +　call g_array_get(states, _id));\n            }\n        };\n        var pickup = func ~() { // 拿起叉子\n            call enter();\n            call g_array_set(states, id, \"hungry\"); // 设置状态是饥饿\n            call test(id); // 看看自己能否用餐\n            call leave();\n            if (call g_array_get(states, id) != \"eating\") { // 如果尝试失败\n                call wait(id); // 等待\n                call g_array_set(states, id, \"eating\"); // 设置为进餐状态\n            } // 这里设置状态不会冲突，因为pickup只能由一个哲学家调用\n        };\n        var putdown = func ~() { // 放下叉子\n            call enter();\n            call g_array_set(states, id, \"thinking\"); // 设置状态是思考\n            call test(left_id); // 测试左边的哲学家可否就餐\n            call test(right_id); // 测试右边的哲学家可否就餐\n            call leave();\n        };\n        foreach (var j : call g_range(1, 10)) {\n            call eat(o, \"Philosophy#\" + id + \" is thinking\");\n            call pickup();\n            call eat(o, \"Philosophy#\" + id + \" is eating. Process: \" + j + \"0%\");\n            call putdown();\n        }\n        call eat(o, \"Philosophy#\" + id + \" OK\");\n    };\n    var eating = func ~(out, str) {\n        var pm = call g_use_mutex(\"philo_print\");\n        call g_lock_mutex(pm);\n        foreach (var c : call g_range_string(str)) {\n            call g_write_pipe(out, c);\n        }\n        call g_write_pipe(out, '\\n');\n        call g_task_sleep_ms(100);\n        call g_unlock_mutex(pm);\n    };\n    foreach (var j : call g_range(1, 5)) {\n        var args = {};\n        call g_map_put(args, \"eating\", eating);\n        call g_map_put(args, \"states\", states);\n        call g_map_put(args, \"out\", out);\n        call g_map_put(args, \"id\", j);\n        call g_map_put(args, \"left_id\", (j == 1) ? 5 : (j - 1));\n        call g_map_put(args, \"right_id\", (j == 5) ? 1 : (j + 1));\n        var h = call g_create_user_process_args(philo2, args); // fork\n        call g_array_add(handles, h);\n    }\n    call g_join_process_array(handles);\n    foreach (var k : call g_range(1, 5)) {\n        call g_destroy_semaphore(call g_use_semaphore(\"fork_\" + k));\n    }\n    call g_destroy_mutex(call g_use_mutex(\"philo_print\"));\n};\n</code></pre></div><p><br></p><p><br></p><img src=\"http://pic2.zhimg.com/v2-c73b98c825ef916ad43876c7e593e235_b.png\" data-rawwidth=\"810\" data-rawheight=\"610\" class=\"origin_image zh-lightbox-thumb\" width=\"810\" data-original=\"http://pic2.zhimg.com/v2-c73b98c825ef916ad43876c7e593e235_r.png\"><p><br></p><p>从输出来看，哲学家就餐的顺序是1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4，是<b>非常有规律的、重复的、完美的顺序</b>，这说明了管程的使用是非常有效的，同时证明了<b>wait/signal机制的优越性</b>：<b>降低了锁的竞争程度(引入休眠)，同时唤醒机制保证了进程同步中各进程的运行顺序</b>。也就是说，如果一开始就出现了1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4循环，那么这个循环就一直存在直到程序结束。</p><h2>【深入】如果哲学家是6个、7个，那么就餐顺序又如何呢？</h2>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":29008180,"publishedTime":"2017-09-02T22:43:53+08:00","url":"/p/29008180","title":"【jMiniLang】哲学家就餐问题","summary":"<a href=\"https://github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95\">https://github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95</a>演示GIF(1.57MB)，控制台输出效果(还有parser/vm/ui)自己实现：信号量与PV原语<b>信号量</b>为正数代表有<u>空闲资源</u>，为零与负数代表<u>没有空闲资源</u>。负数的绝对值代表等待的进程个数。信号量用<b>（S，Q）</b>表示，S是非负初值的整型变量，Q为进程等待…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":1}},"annotationDetail":null,"commentsCount":6,"likesCount":20,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"专业研究野生技术","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{},"favlists":{}},"me":{},"global":{},"columns":{"next":{},"learncpp":{"following":false,"canManage":false,"href":"/api/columns/learncpp","name":"学习C++","creator":{"slug":"bajdcc"},"url":"/learncpp","slug":"learncpp","avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"}}},"columnPosts":{},"columnSettings":{"colomnAuthor":[],"uploadAvatarDetails":"","contributeRequests":[],"contributeRequestsTotalCount":0,"inviteAuthor":""},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true},"favlistsByUser":{},"favlistRelations":{},"promotions":{},"switches":{"couldAddVideo":false},"draft":{"titleImage":"","titleImageSize":{},"isTitleImageFullScreen":false,"canTitleImageFullScreen":false,"title":"","titleImageUploading":false,"error":"","content":"","draftLoading":false,"globalLoading":false,"pendingVideo":{"resource":null,"error":null}},"drafts":{"draftsList":[],"next":{}},"config":{"userNotBindPhoneTipString":{}},"recommendPosts":{"articleRecommendations":[],"columnRecommendations":[]},"env":{"isAppView":false,"appViewConfig":{"content_padding_top":128,"content_padding_bottom":56,"content_padding_left":16,"content_padding_right":16,"title_font_size":22,"body_font_size":16,"is_dark_theme":false,"can_auto_load_image":true,"app_info":"OS=iOS"},"isApp":false},"sys":{}}</textarea>

    
    <script src="//static.zhihu.com/hemingway/common.88ebcfb3d810a398ff8a.js"></script>
<script src="//static.zhihu.com/hemingway/app.398b3cbc1a5a7ed4c9ca.js"></script>
<script src="//static.zhihu.com/hemingway/raven.4399bd4c70bb7f1e8291.js" async defer></script>
  </body>
</html>
