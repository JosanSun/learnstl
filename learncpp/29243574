<!doctype html>
<html lang="zh-CN" class="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>【jMiniLang】实现LISP - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.801234ee6d0e1200c89b55e9d3bf896f.css" />
    <style></style>
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","wechatConfigAPI":"/api/wechat/jssdkconfig","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"29243574":{"contributes":[{"sourceColumn":{"lastUpdated":1497249764,"description":"玩玩有趣的东西","permission":"COLUMN_PUBLIC","memberId":10760740,"contributePermission":"COLUMN_PUBLIC","translatedCommentPermission":"all","canManage":true,"intro":"写写C++","urlToken":"learncpp","id":25963,"imagePath":"v2-bf63794c542fc73b11e17014b7e0d01d.jpg","slug":"learncpp","applyReason":"0","name":"学习C++","title":"学习C++","url":"https://zhuanlan.zhihu.com/learncpp","commentPermission":"COLUMN_ALL_CAN_COMMENT","canPost":true,"created":1483611626,"state":"COLUMN_NORMAL","followers":2487,"avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"activateAuthorRequested":false,"following":false,"imageUrl":"https://pic2.zhimg.com/v2-bf63794c542fc73b11e17014b7e0d01d_l.jpg","articlesCount":48},"state":"accepted","targetPost":{"titleImage":"https://pic1.zhimg.com/v2-1b12b80741e7b0fcd4f3102f462a7780_r.png","lastUpdated":1505119549,"imagePath":"v2-1b12b80741e7b0fcd4f3102f462a7780.png","permission":"ARTICLE_PUBLIC","topics":[14355,3646,17103],"summary":"最近在搞lisp，参考了lispy的实现，反正jMiniLang同样是脚本语言，哈哈如题图所示，Y组合子都能搞定了。 演示在下面（LISP部分在P2）：<a href=\"https://www.bilibili.com/video/av13294962/index_2.html#page=2\">【jMiniOS】脚本操作系统演示(2)_野生技术协会_科技_bilibili_哔哩哔哩</a> 对jMiniLang系统的介绍：<a href=\"https://zhuanlan.zhihu.com/p/28540783\">【jMiniOS】设计思路</a>Jav…","copyPermission":"ARTICLE_COPYABLE","translatedCommentPermission":"all","likes":0,"origAuthorId":0,"publishedTime":"2017-09-11T16:45:49+08:00","sourceUrl":"","urlToken":29243574,"id":3885815,"withContent":false,"slug":29243574,"bigTitleImage":false,"title":"【jMiniLang】实现LISP","url":"/p/29243574","commentPermission":"ARTICLE_ALL_CAN_COMMENT","snapshotUrl":"","created":1505119549,"comments":0,"columnId":25963,"content":"","parentId":0,"state":"ARTICLE_PUBLISHED","imageUrl":"https://pic1.zhimg.com/v2-1b12b80741e7b0fcd4f3102f462a7780_r.png","author":{"bio":"专业研究野生技术","isFollowing":false,"hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"slug":"bajdcc","isFollowed":false,"description":"专业研究野生技术 https://github.com/bajdcc","name":"陈安","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},"memberId":10760740,"excerptTitle":"","voteType":"ARTICLE_VOTE_CLEAR"},"id":812070}],"title":"【jMiniLang】实现LISP","author":"bajdcc","content":"<p>最近在搞lisp，参考了lispy的实现，反正jMiniLang同样是脚本语言，哈哈如题图所示，Y组合子都能搞定了。</p><p><br></p><p>演示在下面（LISP部分在P2）：</p><p><a href=\"http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av13294962/index_2.html%23page%3D2\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">【jMiniOS】脚本操作系统演示(2)_野生技术协会_科技_bilibili_哔哩哔哩<i class=\"icon-external\"></i></a></p><a class=\"video-box\" href=\"http://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av13294962/%23page%3D2\" target=\"_blank\" data-video-id=\"890616462358765568\" data-video-playable=\"true\" data-name=\"【jMiniOS】脚本操作系统演示_野生技术协会_科技_bilibili_哔哩哔哩\" data-poster=\"https://pic2.zhimg.com/v2-d5f56e840fa0b5784d03a46c439afc65.jpg\" data-lens-id=\"\">              <img class=\"thumbnail\" src=\"https://pic2.zhimg.com/v2-d5f56e840fa0b5784d03a46c439afc65.jpg\">              <span class=\"content\">                <span class=\"title\">【jMiniOS】脚本操作系统演示_野生技术协会_科技_bilibili_哔哩哔哩<span class=\"z-ico-extern-gray\"></span><span class=\"z-ico-extern-blue\"></span></span>                <span class=\"url\"><span class=\"z-ico-video\"></span>https://www.bilibili.com/video/av13294962/#page=2</span>              </span>            </a>            <p><br></p><p><br></p><p>对jMiniLang系统的介绍：<a href=\"https://zhuanlan.zhihu.com/p/28540783\" class=\"internal\">【jMiniOS】设计思路</a></p><p>Java源码：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jMiniLang\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/jMiniLang<i class=\"icon-external\"></i></a></p><p>后面会继续研究C++写的LISP解释器，目前只是山寨了下：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/MyScript\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/MyScript<i class=\"icon-external\"></i></a></p>","updated":"2017-09-11T08:45:49.000Z","canComment":false,"commentPermission":"anyone","commentCount":0,"collapsedCount":0,"likeCount":6,"state":"published","isLiked":false,"slug":"29243574","isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic1.zhimg.com/v2-1b12b80741e7b0fcd4f3102f462a7780_r.png","links":{"comments":"/api/posts/29243574/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/19593326","id":"19593326","name":"Lisp"},{"url":"https://www.zhihu.com/topic/19561132","id":"19561132","name":"Java"},{"url":"https://www.zhihu.com/topic/19601369","id":"19601369","name":"编译原理"}],"adminClosedComment":false,"titleImageSize":{"width":807,"height":606},"href":"/api/posts/29243574","excerptTitle":"","column":{"slug":"learncpp","name":"学习C++"},"tipjarState":"inactivated","annotationAction":[],"sourceUrl":"","pageCommentsCount":0,"hasPublishingDraft":false,"snapshotUrl":"","publishedTime":"2017-09-11T16:45:49+08:00","url":"/p/29243574","lastestLikers":[{"bio":"","isFollowing":false,"hash":"a0b8794dbd5ebae01177ae61b9df3f03","uid":28447770411008,"isOrg":false,"slug":"sonkey","isFollowed":false,"description":"","name":"sonkey","profileUrl":"https://www.zhihu.com/people/sonkey","avatar":{"id":"3c6194771b8fbaba489331b254fcd652","template":"https://pic3.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":"程序猿 / 宅男 / 游戏爱好者 / 二次元","isFollowing":false,"hash":"a33587a65e23a08fa975b805b93dd4e5","uid":77744931078144,"isOrg":false,"slug":"coderyrh","isFollowed":false,"description":"求知若饥 虚心若愚","name":"杨睿涵","profileUrl":"https://www.zhihu.com/people/coderyrh","avatar":{"id":"v2-5a205f0524a8ec3306259f671fb0fed0","template":"https://pic1.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":null,"isFollowing":false,"hash":"6a86b8115df7c9773db0a6f57cc2f62a","uid":629026581356744700,"isOrg":false,"slug":"fcs9","isFollowed":false,"description":"","name":"fcs9fhhch","profileUrl":"https://www.zhihu.com/people/fcs9","avatar":{"id":"da8e974dc","template":"https://pic1.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":"自动化学生","isFollowing":false,"hash":"18e4be068d2c9c37e6e24a51331f167e","uid":665912806717657100,"isOrg":false,"slug":"su-cheng-hao-49","isFollowed":false,"description":"","name":"苏程浩","profileUrl":"https://www.zhihu.com/people/su-cheng-hao-49","avatar":{"id":"79d636102d422cabd6916bc8fb3390bc","template":"https://pic1.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":"Malt语言之父 （逃","isFollowing":false,"hash":"5a444f1fd85a11a13560e28426a83488","uid":826202252833325000,"isOrg":false,"slug":"liu-zhi-hang-78","isFollowed":false,"description":"我不懂，我不会，我不知道/惊恐\n\n起这名是为了让每本书都印上我的名字（逃","name":"目录","profileUrl":"https://www.zhihu.com/people/liu-zhi-hang-78","avatar":{"id":"v2-48f2a6a2360c8c19b12d783643fe7889","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false}],"summary":"最近在搞lisp，参考了lispy的实现，反正jMiniLang同样是脚本语言，哈哈如题图所示，Y组合子都能搞定了。 演示在下面（LISP部分在P2）：<a href=\"https://www.bilibili.com/video/av13294962/index_2.html#page=2\">【jMiniOS】脚本操作系统演示(2)_野生技术协会_科技_bilibili_哔哩哔哩</a> 对jMiniLang系统的介绍：<a href=\"https://zhuanlan.zhihu.com/p/28540783\">【jMiniOS】设计思路</a>Jav…","reviewingCommentsCount":0,"meta":{"previous":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic1.zhimg.com/50/v2-15c59a7711011767c2279f9a23e16c78_xl.jpg","links":{"comments":"/api/posts/29008180/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19554298","id":"19554298","name":"编程"},{"url":"https://www.zhihu.com/topic/19561132","id":"19561132","name":"Java"},{"url":"https://www.zhihu.com/topic/19552686","id":"19552686","name":"操作系统"}],"adminClosedComment":false,"href":"/api/posts/29008180","excerptTitle":"","author":{"bio":"专业研究野生技术","isFollowing":false,"hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"slug":"bajdcc","isFollowed":false,"description":"专业研究野生技术 https://github.com/bajdcc","name":"陈安","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},"content":"<p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt%23L95\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/jMini</span><span class=\"invisible\">Lang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></p><p>演示GIF(1.57MB)，控制台输出效果(还有parser/vm/ui)自己实现：</p><img src=\"http://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_b.gif\" data-rawwidth=\"810\" data-rawheight=\"610\" data-thumbnail=\"http://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"810\" data-original=\"http://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_r.gif\"><h2>信号量与PV原语</h2><p><b>信号量</b>为正数代表有<u>空闲资源</u>，为零与负数代表<u>没有空闲资源</u>。负数的绝对值代表等待的进程个数。信号量用<b>（S，Q）</b>表示，S是非负初值的整型变量，Q为进程等待队列。</p><p><b>P原语（阻塞）</b>：令S=S-1，若S&amp;gt;=0，进程继续执行，否则该进程变为等待状态，入队列Q</p><p><b>V原语（唤醒）</b>：令S=S+1，若S&amp;gt;0，进程继续执行，否则释放队列Q中第一个等待信号量的进程</p><p>实现互斥：令S=1。</p><p><br></p><h2>用管道语义实现PV操作</h2><p>当前jMiniOS支持的管道操作：</p><ol><li>create_pipe，创建管道，返回句柄</li><li>write_pipe，向管道中写入一个字符（非堵塞）</li><li>read_pipe，从管道中不断读取字符流（堵塞）</li><li>read_pipe_once，从管道中读取一个字符（堵塞）</li><li>destroy_pipe，销毁管道</li></ol><p>用管道实现信号量：</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>var g_create_semaphore = func ~(name, n) {\n    if (call g_query_pipe(name)) {\n        return;\n    }\n    var pipe = call g_create_pipe(name);\n    call g_write_pipe(pipe, call g_string_rep(\"*\", n));\n    return pipe;\n};\nexport \"g_create_semaphore\";\nvar g_use_semaphore = func ~(name) {\n    return call g_create_pipe(name);\n};\nexport \"g_use_semaphore\";\nvar g_destroy_semaphore = func ~(handle) {\n    call g_destroy_pipe_once(handle);\n};\nexport \"g_destroy_semaphore\";\nvar g_lock_semaphore = func ~(handle) {\n    call g_read_pipe_once(handle);\n};\nexport \"g_lock_semaphore\";\nvar g_unlock_semaphore = func ~(handle) {\n    call g_write_pipe(handle, \"*\");\n};\nexport \"g_unlock_semaphore\";\n</code></pre></div><p><b>关键：</b></p><ol><li>创建管道后，信号量的初始值=管道中存储的字符个数，即管道中的内容=信号量中可用资源。</li><li>P操作 = 向管道中写一字符</li><li>V操作 = 从管道中读一字符</li><li>Mutex实现，create_mutex = create_semaphore(1)</li></ol><h2>实现哲学家就餐问题</h2><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>/* 哲学家就餐问题 */\nvar stage_philo = func ~() {\n    call word_typewrite(\"演示哲学家就餐问题！    \\n\", 100);\n    var print_mutex = call g_create_mutex(\"philo_print\");\n    foreach (var i : call g_range(1, 5)) {\n        call g_create_semaphore(\"fork_\" + i, 1); // 每个叉最多能使用一次\n    }\n    var handles = [];\n    var philo = func ~(args) { // philo = 新建进程， args = 参数\n        var eat = call g_map_get(args, \"eating\");\n        var o = call g_map_get(args, \"out\");\n        var id = call g_map_get(args, \"id\");\n        var left_id = call g_map_get(args, \"left_id\"); // 左叉ID\n        var right_id = call g_map_get(args, \"right_id\"); // 右叉ID\n        var left = call g_use_semaphore(\"fork_\" + left_id); // 左叉信号量\n        var right = call g_use_semaphore(\"fork_\" + right_id); // 右叉信号量\n        call eat(o, \"Philosophy#\" + id + \" ready\");\n        foreach (var j : call g_range(1, 10)) { // 吃十次才饱\n            call g_lock_semaphore(left); // P左叉\n            call eat(o, \"Philosophy#\" + id + \" is using fork#\" + left_id);\n            call g_lock_semaphore(right); // P右叉\n            call eat(o, \"Philosophy#\" + id + \" is using fork#\" + right_id);\n            call eat(o, \"Philosophy#\" + id + \" is eating. Process: \" + j + \"0%\");\n            call g_unlock_semaphore(left); // V左叉\n            call g_unlock_semaphore(right); // V右叉\n        }\n        call eat(o, \"Philosophy#\" + id + \" OK\");\n    };\n    var eating = func ~(out, str) { // 输出\n        var pm = call g_use_mutex(\"philo_print\");\n        call g_lock_mutex(pm);\n        foreach (var c : call g_range_string(str)) {\n            call g_write_pipe(out, c);\n        }\n        call g_write_pipe(out, '\\n');\n        call g_task_sleep_ms(100);\n        call g_unlock_mutex(pm);\n    };\n    foreach (var j : call g_range(1, 5)) {\n        var args = {}; // 传参\n        call g_map_put(args, \"eating\", eating);\n        call g_map_put(args, \"out\", out);\n        call g_map_put(args, \"id\", j);\n        call g_map_put(args, \"left_id\", (j == 1) ? 5 : (j - 1));\n        call g_map_put(args, \"right_id\", (j == 5) ? 1 : (j + 1));\n        var h = call g_create_user_process_args(philo, args); // 新建进程\n        call g_array_add(handles, h);\n        call g_task_sleep(1);\n    }\n    call g_join_process_array(handles);\n    foreach (var k : call g_range(1, 5)) {\n        call g_destroy_semaphore(call g_use_semaphore(\"fork_\" + k)); // 销毁\n    }\n    call g_destroy_mutex(call g_use_mutex(\"philo_print\")); // 销毁\n};\n</code></pre></div><p><br></p><h2>总结</h2><p>从实例上看，哲学家不是同时开始就餐的，而是陆续就餐，同时就餐肯定会导致死锁问题。所以要有一定的防死锁和饥饿的解法，网上也有很多，有一种管程的解法。</p><p>例子中<b>每个哲学家不会知道其他哲学家的状态</b>，因此肯定会有缺陷啦，假如先让A就餐，然后A吃完再唤醒其他人，那就好办了。</p><p><b>唤醒</b>语义，好东西，想想linux中的进程状态实现，soga。因此，我们的程序除了要支持lock/unlock之外，还要支持wait/notify，下回分解。</p><p><br></p><p>===========================================</p><h2>0903 更新：用管程实现（jMiniLang语言）</h2><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>/* 哲学家就餐问题 - 管程解决 */\nvar stage_philo2 = func ~() {\n    call word_typewrite(\"【管程】演示哲学家就餐问题！    \\n\", 100);\n    call g_create_mutex(\"philo_print\");\n    call g_create_mutex(\"philo_monitor\");\n    var states = [];\n    call g_array_add(states, g_null);\n    foreach (var i : call g_range(1, 5)) {\n        call g_create_semaphore(\"philo_\" + i, 1); // 记录每个哲学家的状态（管程）\n        call g_array_add(states, \"thinking\"); // 开始时哲学家都在思考\n    }\n    var handles = [];\n    var philo2 = func ~(args) {\n        var eat = call g_map_get(args, \"eating\"); // 拿参数\n        var states = call g_map_get(args, \"states\");\n        var o = call g_map_get(args, \"out\");\n        var id = call g_map_get(args, \"id\");\n        var left_id = call g_map_get(args, \"left_id\");\n        var right_id = call g_map_get(args, \"right_id\");\n        var monitor = call g_use_mutex(\"philo_monitor\");\n        call eat(o, \"Philosophy#\" + id + \" ready\");\n        var enter = func ~() { // 进入临界区\n            var monitor = call g_use_mutex(\"philo_monitor\");\n            call g_lock_mutex(monitor); // mutex自带等待队列\n            call g_printdn(\"Philosophy#\" + id + \" entered critical section\");\n        };\n        var leave = func ~() { // 离开临界区\n            call g_printdn(\"Philosophy#\" + id + \" leaved critical section\");\n            var monitor = call g_use_mutex(\"philo_monitor\");\n            call g_unlock_mutex(monitor);\n        };\n        var wait = func ~(_id) { // 等待信号\n            var sem = call g_use_semaphore(\"philo_\" + _id);\n            call g_printdn(\"Philosophy#\" + _id + \" waiting\");\n            call g_lock_mutex(sem); // semaphore自带等待队列\n        };\n        var signal = func ~(_id) { // 发出信号\n            var sem = call g_use_semaphore(\"philo_\" + _id);\n            call g_unlock_mutex(sem);\n            call g_printdn(\"Philosophy#\" + _id + \" received signal\");\n        };\n        var test = func ~(_id) { // 测试哲学家是否具备进餐条件\n            var _left_id = (_id == 1) ? 5 : (_id - 1);\n            var _right_id = (_id == 5) ? 1 : (_id + 1);\n            if ((call g_array_get(states, _left_id) != \"eating\") &amp;amp;&amp;amp; // 如果左右都不在进餐\n                (call g_array_get(states, _right_id) != \"eating\") &amp;amp;&amp;amp;\n                (call g_array_get(states, _id) == \"hungry\")) { // 且自己为饥饿状态\n                call signal(_id); // 发出就餐信号\n            } else {\n                call g_printdn(\"Test failed. #\" + _left_id + \": \" + call g_array_get(states, _left_id) +\n                    \", #\" + _right_id + \": \" + call g_array_get(states, _right_id) + \", #\" +\n                    _id + \": \" +　call g_array_get(states, _id));\n            }\n        };\n        var pickup = func ~() { // 拿起叉子\n            call enter();\n            call g_array_set(states, id, \"hungry\"); // 设置状态是饥饿\n            call test(id); // 看看自己能否用餐\n            call leave();\n            if (call g_array_get(states, id) != \"eating\") { // 如果尝试失败\n                call wait(id); // 等待\n                call g_array_set(states, id, \"eating\"); // 设置为进餐状态\n            } // 这里设置状态不会冲突，因为pickup只能由一个哲学家调用\n        };\n        var putdown = func ~() { // 放下叉子\n            call enter();\n            call g_array_set(states, id, \"thinking\"); // 设置状态是思考\n            call test(left_id); // 测试左边的哲学家可否就餐\n            call test(right_id); // 测试右边的哲学家可否就餐\n            call leave();\n        };\n        foreach (var j : call g_range(1, 10)) {\n            call eat(o, \"Philosophy#\" + id + \" is thinking\");\n            call pickup();\n            call eat(o, \"Philosophy#\" + id + \" is eating. Process: \" + j + \"0%\");\n            call putdown();\n        }\n        call eat(o, \"Philosophy#\" + id + \" OK\");\n    };\n    var eating = func ~(out, str) {\n        var pm = call g_use_mutex(\"philo_print\");\n        call g_lock_mutex(pm);\n        foreach (var c : call g_range_string(str)) {\n            call g_write_pipe(out, c);\n        }\n        call g_write_pipe(out, '\\n');\n        call g_task_sleep_ms(100);\n        call g_unlock_mutex(pm);\n    };\n    foreach (var j : call g_range(1, 5)) {\n        var args = {};\n        call g_map_put(args, \"eating\", eating);\n        call g_map_put(args, \"states\", states);\n        call g_map_put(args, \"out\", out);\n        call g_map_put(args, \"id\", j);\n        call g_map_put(args, \"left_id\", (j == 1) ? 5 : (j - 1));\n        call g_map_put(args, \"right_id\", (j == 5) ? 1 : (j + 1));\n        var h = call g_create_user_process_args(philo2, args); // fork\n        call g_array_add(handles, h);\n    }\n    call g_join_process_array(handles);\n    foreach (var k : call g_range(1, 5)) {\n        call g_destroy_semaphore(call g_use_semaphore(\"fork_\" + k));\n    }\n    call g_destroy_mutex(call g_use_mutex(\"philo_print\"));\n};\n</code></pre></div><p><br></p><p><br></p><img src=\"http://pic2.zhimg.com/v2-c73b98c825ef916ad43876c7e593e235_b.png\" data-rawwidth=\"810\" data-rawheight=\"610\" class=\"origin_image zh-lightbox-thumb\" width=\"810\" data-original=\"http://pic2.zhimg.com/v2-c73b98c825ef916ad43876c7e593e235_r.png\"><p><br></p><p>从输出来看，哲学家就餐的顺序是1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4，是<b>非常有规律的、重复的、完美的顺序</b>，这说明了管程的使用是非常有效的，同时证明了<b>wait/signal机制的优越性</b>：<b>降低了锁的竞争程度(引入休眠)，同时唤醒机制保证了进程同步中各进程的运行顺序</b>。也就是说，如果一开始就出现了1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4循环，那么这个循环就一直存在直到程序结束。</p><h2>【深入】如果哲学家是6个、7个，那么就餐顺序又如何呢？</h2>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":29008180,"publishedTime":"2017-09-02T22:43:53+08:00","url":"/p/29008180","title":"【jMiniLang】哲学家就餐问题","summary":"<a href=\"https://github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95\">https://github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95</a>演示GIF(1.57MB)，控制台输出效果(还有parser/vm/ui)自己实现：信号量与PV原语<b>信号量</b>为正数代表有<u>空闲资源</u>，为零与负数代表<u>没有空闲资源</u>。负数的绝对值代表等待的进程个数。信号量用<b>（S，Q）</b>表示，S是非负初值的整型变量，Q为进程等待…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":1},"next":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic3.zhimg.com/50/v2-8ecd6093851e4cda1271ba94c66f3cc2_xl.jpg","links":{"comments":"/api/posts/29589948/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19599592","id":"19599592","name":"设计模式"},{"url":"https://www.zhihu.com/topic/19554298","id":"19554298","name":"编程"},{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"}],"adminClosedComment":false,"href":"/api/posts/29589948","excerptTitle":"","author":{"bio":"专业研究野生技术","isFollowing":false,"hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"slug":"bajdcc","isFollowed":false,"description":"专业研究野生技术 https://github.com/bajdcc","name":"陈安","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},"content":"<h2>CEval - 四则运算器（C++）</h2><p>源码：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/CEval\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/CEval<i class=\"icon-external\"></i></a></p><p>最近把jMiniLang玩得差不多了，有点腻了。重温一下设计模式，这也不是重新造轮子，不必用高大上的LR分析去弄，这个正经C++专栏（雾）还是要来点C++干货的。</p><p>回故一下曾经做的：</p><ul><li>LR分析（Java）一条龙工程——Parser、IR、VM、UI，维护最久的：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jMiniLang\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/jMini</span><span class=\"invisible\">Lang</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li>LISP解释器（C++，ANTLR）：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/MyScript\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/MyScr</span><span class=\"invisible\">ipt</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li>简单C语言编译器+虚拟机（C++，正则表达式）：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/CParser\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/CPars</span><span class=\"invisible\">er</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li>管道：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/CppShell\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/CppSh</span><span class=\"invisible\">ell</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li>仿Prolog（Java &amp;amp; ANTLR）：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jProlog\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/jProl</span><span class=\"invisible\">og</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li>函数式语言（C#）：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/SimpleConsole\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/Simpl</span><span class=\"invisible\">eConsole</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li><li><b>数字转人民币（Java）——设计模式装逼典范，过度设计的反面教材哈哈，我已经把它翻成C++了，就在下面</b>：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/translate\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/trans</span><span class=\"invisible\">late</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></li></ul><p>没想到做过了这么多东西，写了这么多轮子，所以说对Parser这块可以说比较熟练了（排除编译优化哈），对计算器呢，肯定不能用已经实现过的方法，应该要有创新点。</p><p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/translate\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数字转人民币<i class=\"icon-external\"></i></a>这个工程我感觉很有价值（你想过用编译指令去Parse一个简单的数字吗？），想办法把它融到本项目中去（感觉用用扩展），然后这个工程是上述所有工程中最早写的，这样想还觉得现在写的代码太low了（逃</p><h2>思路</h2><h2>一、解析（Parser &amp;amp; Lexer）</h2><p>肯定要用LL人肉分析啦，这是<b>基本功</b>嘛，，</p><p>这里会重温：</p><ol><li>词法分析</li><ol><li>字符串转整型（不用正则）</li><li>字符串转浮点（不用正则）</li><li>识别操作符（包括内置操作符和<b>可自定义扩展操作符</b>）</li><li>赋值语句（简单点就是ID=Exp）</li></ol><li>语法分析</li><ol><li>LL分析</li><li>生成语法树</li></ol></ol><p><br></p><h2>二、求值（Eval）</h2><p>一般而言，求个表达式的值，用算符优先文法也能做，不过太老套了。</p><p>LL分析表达式最大问题是优先级问题，如果我写了文法，然后去掉左递归，当然也可以，不过太没人性了，这方面用yaac和ANTLR比较好，它们帮你做。</p><p>比如对于“3+4*5”，识别到乘号前，“3+4”肯定不能搞成一棵树，如果我硬要做，也行，只是到时候到乘号时就要忍痛割爱了（<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/SimpleConsole\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">函数式编程<i class=\"icon-external\"></i></a>这个项目就用这个坑爹方法）。我不做，那行，把“3+4”顺序放到栈里，也就是算符文法。看来没别的路走了。</p><p>然而我还是要做，就是要生成树，到时候我改还不成么。碰到乘号后，我就把“4”这个结点替换成树，也就是说，算符文法是碰到没有更高优先级就归约，我不管，<b>我就是要立即马上归约，这是本项目要尝试的地方</b>，管它高不高效，哈哈。</p><p>还有个问题是归约后立马求值还是整体一起求值，其实，前者是自底向上，后者是自顶向下。我就是倾向于前者——<b>立马求值</b>，第一，出错后立马爆炸，免得解析后面多余的内容，第二，直接在归约时计算数值类型，该整型换浮点就换掉。</p><h2>三、扩展（Extension）</h2><p>就是函数呗，如abs等函数。引入变量名后，好处还是比较大的。当然这又会有一个坑爹问题——函数对参数的类型要求。参照上文，我的想法是——类型不同，如果不能自动转换，那立马爆炸。</p><p>扩展的第一个内容我想应该是<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/translate\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">人民币翻译方案<i class=\"icon-external\"></i></a>，我把多余的设计去掉，只剩下指令部分。一般LR分析看到一个函数调用，肯定先把参数给归约了，然后再到函数。而LL的话，我一看到变量名，发现是函数，就调用了相应函数的Parser方法，将控制权交给它。</p><p>为什么？因为不用对参数归约了呀，让函数去做。人民币翻译的代码里面，它就是Lexer和Parser搅在一起，哈哈，真是神设计，不知道当初怎么想的。</p><h2>计划</h2><ol><li><b>【已完成】</b> 人民币解析（Java移植到C++）</li><li>完成四则运算解析</li><li>完成某些黑科技</li></ol><h2>====================================</h2><h2>【已完成模块】人民币翻译（C++）</h2><p>本模块代码：<b>2k Lines</b>。</p><p>【简要分析】数字转人民币显示的难点有：数字按四位划分、合法性检查、零的取舍。</p><h2>一、顶层设计</h2><p>三个阶段：词法过滤、正则分组、语法分析。</p><p>设计原因：便于匹配顶层调用（面向调用的），结合常见的设计方式。</p><p>后面的专栏我会以下面三大阶段分别介绍。</p><h2>阶段一：RefString 系列代码（词法分析阶段的流过滤器）</h2><p>实现基于字符串的装饰器模式，类似于LINQ。</p><p>示例代码在ModRmbLexer结尾处（建造者模式）：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"n\">shared_ptr</span><span class=\"o\">&amp;lt;</span><span class=\"n\">IRefStringIterator</span><span class=\"o\">&amp;gt;</span> <span class=\"n\">RmbLexer</span><span class=\"o\">::</span><span class=\"n\">decorator</span><span class=\"p\">(</span><span class=\"n\">string</span> <span class=\"n\">text</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">make_shared</span><span class=\"o\">&amp;lt;</span><span class=\"n\">RefString</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">)</span>\n        <span class=\"o\">-&amp;gt;</span><span class=\"n\">iterator</span><span class=\"p\">()</span> <span class=\"c1\">// 启用流</span>\n        <span class=\"o\">-&amp;gt;</span><span class=\"n\">skipHead</span><span class=\"p\">(</span><span class=\"sc\">'0'</span><span class=\"p\">)</span> <span class=\"c1\">// 启用向前看，跳过数字前置零</span>\n        <span class=\"o\">-&amp;gt;</span><span class=\"n\">findFirst</span><span class=\"p\">(</span><span class=\"sc\">'.'</span><span class=\"p\">)</span> <span class=\"c1\">// 找到小数点</span>\n        <span class=\"o\">-&amp;gt;</span><span class=\"n\">take</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"c1\">// 只取小数点后两位</span>\n        <span class=\"o\">-&amp;gt;</span><span class=\"n\">lookAhead</span><span class=\"p\">();</span> <span class=\"c1\">// 启用向前看</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>经过筛选后，\"000905000234.0678\"就变成了\"905000234.06\"。</p><p>而RefString设计之初就是只保存<b>原字符串指针和起始终止位置</b>，不复制原字符串，然而Java中确实是可以这么实现的，但是！C++里面string仍然会拷贝啊，除非一直保存string的指针，感觉太繁琐，所以C++里面RefString的功能就只是提供了流的接口而已。</p><h2>阶段二：ModRmbStyle 系列代码（词法分析阶段的正则匹配状态机）</h2><p>ModRmbStyle 生成了一系列指令，用于字符串的分组捕获及错误处理（状态机模式）。该阶段将数字拆分成<b>整数、小数点、小数</b>这三个部分，结果还是字符串，可以看做是正则捕获阶段。</p><p>指令集的设计以及分阶段的指令集也是我自己的想法和实现。</p><p>示例代码在ModRmbStyle，这里不贴了。</p><h2>阶段三：ModRmbParser 系列代码（生成AST）</h2><p>ModRmbParser 生成AST，用访问者模式就可以遍历生成最终的人民币大写表示。</p><p>LL分析不说了，由于第二阶段将字符串拆分成三组，这样就分别对整数、小数点、小数三部分进行LL分析，生成AST。</p><p>语法分析阶段顶层调用代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"n\">lexer</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">match</span><span class=\"p\">();</span> <span class=\"c1\">// 词法分析+正则捕获</span>\n<span class=\"n\">group</span> <span class=\"o\">=</span> <span class=\"n\">lexer</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">getGroup</span><span class=\"p\">();</span> <span class=\"c1\">// 获取匹配后的分组</span>\n<span class=\"n\">normalizeGroup</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span> <span class=\"c1\">// 填充缺失的分组</span>\n<span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"n\">make_shared</span><span class=\"o\">&amp;lt;</span><span class=\"n\">StoreableNode</span><span class=\"o\">&amp;gt;</span><span class=\"p\">();</span> <span class=\"c1\">// AST的根</span>\n<span class=\"n\">root</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">addNode</span><span class=\"p\">(</span><span class=\"n\">parseNode</span><span class=\"p\">(</span><span class=\"n\">INTEGER</span><span class=\"p\">,</span> <span class=\"n\">group</span><span class=\"p\">.</span><span class=\"n\">at</span><span class=\"p\">(</span><span class=\"n\">INTEGER</span><span class=\"p\">)),</span> <span class=\"nb\">true</span><span class=\"p\">);</span> <span class=\"c1\">// 添加整数部分子树</span>\n<span class=\"n\">root</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">addNode</span><span class=\"p\">(</span><span class=\"n\">parseNode</span><span class=\"p\">(</span><span class=\"n\">DOT</span><span class=\"p\">,</span> <span class=\"n\">group</span><span class=\"p\">.</span><span class=\"n\">at</span><span class=\"p\">(</span><span class=\"n\">DOT</span><span class=\"p\">)),</span> <span class=\"nb\">true</span><span class=\"p\">);</span> <span class=\"c1\">// 添加小数点</span>\n<span class=\"n\">root</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">addNode</span><span class=\"p\">(</span><span class=\"n\">parseNode</span><span class=\"p\">(</span><span class=\"n\">DECIMAL</span><span class=\"p\">,</span> <span class=\"n\">group</span><span class=\"p\">.</span><span class=\"n\">at</span><span class=\"p\">(</span><span class=\"n\">DECIMAL</span><span class=\"p\">)),</span> <span class=\"nb\">true</span><span class=\"p\">);</span> <span class=\"c1\">// 添加小数部分子树</span>\n</code></pre></div><h2>二、小结</h2><p>具体的过程说明、设计模式使用、设计的原因我还没来得及想好，后面更新到专栏。</p><p>这样折腾的好处：</p><ol><li>锻炼/复习一下设计模式</li><li>便于扩展</li><li>每个项目都是自己所做的工艺品，追求极致和完美，当然是很有满足感喽</li></ol><p>原本是打算再写个RomanStyle将数字转成罗马数字的，我将转换过程独立成四个阶段：<b>词法过滤、正则匹配、生成AST、遍历AST生成结果</b>。后面会尝试完成RomanStyle，以证明这个坑爹的设计是可取的（逃</p><p>呵呵，一个小模块就有2k行代码了，那CEval这个项目最终也不会很简单就是了。</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":29589948,"publishedTime":"2017-09-22T22:24:44+08:00","url":"/p/29589948","title":"【CEval系列】简介","summary":"CEval - 四则运算器（C++）源码：<a href=\"https://github.com/bajdcc/CEval\">bajdcc/CEval</a>最近把jMiniLang玩得差不多了，有点腻了。重温一下设计模式，这也不是重新造轮子，不必用高大上的LR分析去弄，这个正经C++专栏（雾）还是要来点C++干货的。回故一下曾经做的：LR分析（Java）一条龙工程——Pars…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":1}},"annotationDetail":null,"commentsCount":0,"likesCount":6,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"专业研究野生技术","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{},"favlists":{}},"me":{},"global":{},"columns":{"next":{},"learncpp":{"following":false,"canManage":false,"href":"/api/columns/learncpp","name":"学习C++","creator":{"slug":"bajdcc"},"url":"/learncpp","slug":"learncpp","avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"}}},"columnPosts":{},"columnSettings":{"colomnAuthor":[],"uploadAvatarDetails":"","contributeRequests":[],"contributeRequestsTotalCount":0,"inviteAuthor":""},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true},"favlistsByUser":{},"favlistRelations":{},"promotions":{},"switches":{"couldAddVideo":false},"draft":{"titleImage":"","titleImageSize":{},"isTitleImageFullScreen":false,"canTitleImageFullScreen":false,"title":"","titleImageUploading":false,"error":"","content":"","draftLoading":false,"globalLoading":false,"pendingVideo":{"resource":null,"error":null}},"drafts":{"draftsList":[],"next":{}},"config":{"userNotBindPhoneTipString":{}},"recommendPosts":{"articleRecommendations":[],"columnRecommendations":[]},"env":{"isAppView":false,"appViewConfig":{"content_padding_top":128,"content_padding_bottom":56,"content_padding_left":16,"content_padding_right":16,"title_font_size":22,"body_font_size":16,"is_dark_theme":false,"can_auto_load_image":true,"app_info":"OS=iOS"},"isApp":false},"sys":{}}</textarea>

    
    <script src="//static.zhihu.com/hemingway/common.88ebcfb3d810a398ff8a.js"></script>
<script src="//static.zhihu.com/hemingway/app.398b3cbc1a5a7ed4c9ca.js"></script>
<script src="//static.zhihu.com/hemingway/raven.4399bd4c70bb7f1e8291.js" async defer></script>
  </body>
</html>
