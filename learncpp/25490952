<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>【玩转科学计算】在Win上安装Tensorflow - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.ad2159a596c8458712d70cf5a5b17235.css" />
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"25490952":{"title":"【玩转科学计算】在Win上安装Tensorflow","author":"bajdcc","content":"<h2>介绍Tensorflow</h2><p>摘自维基百科的一段文字：</p><blockquote>TensorFlow是Google Brain的第二代机器学习系统，2015年11月9日，参考实现作为开源软件发布。虽然参考实现运行在单台设备，TensorFlow可以运行在多个CPU和GPU（和可选的CUDA扩展）。它运行在64位Linux或macOS桌面或服务器系统，以及在移动计算平台上，包括Android和iOS。TensorFlow的计算用有状态的数据流图表示。许多Google团队已从DistBelief迁移到TensorFlow进行研究和生产。这个库的算法源于Google需要指导称为神经网络的计算机系统，类似人类学习和推理的方法，以便派生出新的应用程序承担以前仅人类能胜任的角色和职能；TensorFlow的名字来源于这类神经网络对多维数组执行的操作。这些多维数组被称为“张量”，但这个概念并不等同于张量的数学概念。其目的是训练神经网络检测和识别模式和相互关系。<br></blockquote><p>TF只是一个科学计算工具，要想实现一些很酷的功能，就需要学习相关的知识。作为初学者，一步一个坑，一步一个脚印，走进机器学习的世界。</p><h2>安装Tensorflow</h2><p><b>在Windows上安装Tensorflow的步骤如下（参考自<a href=\"http://link.zhihu.com/?target=http%3A//blog.csdn.net/ztf312/article/details/56018891\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">windows下基于Anaconda的Tensorflow环境配置 - CS青雀的巢 - 博客频道 - CSDN.NET<i class=\"icon-external\"></i></a></b><b>）：</b></p><br><ol><li>下载并安装<a href=\"http://link.zhihu.com/?target=https%3A//repo.continuum.io/archive/Anaconda3-4.3.0.1-Windows-x86_64.exe\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Anaconda3-4.3.0.1-Windows-x86_64.exe<i class=\"icon-external\"></i></a>，管理员运行，不要勾选“添加到PATH”</li><li>安装完成后，打开开始菜单，找到<b>Anaconda/Anaconda prompt</b>，以管理员权限运行，出现命令行窗口<br></li><li>建立名为tensorflow的conda计算环境，方法是输入命令conda create -n tensorflow python=3.5，嫌时间慢可以参考<a href=\"http://link.zhihu.com/?target=http%3A//blog.csdn.net/pengjian444/article/details/51924469\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">[加速]为conda添加国内镜像 - PJZero - 博客频道 - CSDN.NET<i class=\"icon-external\"></i></a></li><li>激活tensorflow环境，输入activate tensorflow<br></li><li>安装tensorflow，pip install <a href=\"http://link.zhihu.com/?target=https%3A//storage.googleapis.com/tensorflow/windows/cpu/tensorflow-0.12.1-cp35-cp35m-win_amd64.whl\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-0.12.0-cp35-cp35m-win_amd64.whl<i class=\"icon-external\"></i></a></li></ol><h2>测试</h2><p>输入测试命令：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span></span><span class=\"c1\"># python</span>\n<span class=\"kn\">import</span> <span class=\"nn\">tensorflow</span> <span class=\"kn\">as</span> <span class=\"nn\">tf</span>\n<span class=\"n\">hello</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'Hello, Tensorflow!'</span><span class=\"p\">)</span>\n<span class=\"n\">sess</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Session</span><span class=\"p\">()</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">sess</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">hello</span><span class=\"p\">))</span>\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"mi\">22</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">sess</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">))</span>\n</code></pre></div><p>运行结果如题图所示。</p>","updated":"2017-03-01T01:53:45.000Z","canComment":false,"commentPermission":"anyone","commentCount":2,"collapsedCount":0,"likeCount":15,"state":"published","isLiked":false,"slug":"25490952","isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic1.zhimg.com/v2-6cd541cd9f4d479281d00d7d378c3298_r.png","links":{"comments":"/api/posts/25490952/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/20032249","id":"20032249","name":"TensorFlow"},{"url":"https://www.zhihu.com/topic/19572360","id":"19572360","name":"Python 3.x"},{"url":"https://www.zhihu.com/topic/19608617","id":"19608617","name":"科学计算"}],"titleImageSize":{"width":677,"height":266},"href":"/api/posts/25490952","excerptTitle":"","column":{"slug":"learncpp","name":"从零开始构建标准库"},"tipjarState":"inactivated","sourceUrl":"","pageCommentsCount":2,"snapshotUrl":"","publishedTime":"2017-03-01T09:53:45+08:00","url":"/p/25490952","lastestLikers":[{"profileUrl":"https://www.zhihu.com/people/chen-hong-rui-55","bio":"在校学生","hash":"166acf991a36c2a573a376f6adf086cc","uid":591548759264596000,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"chen-hong-rui-55","avatar":{"id":"a7fedb07de3067cea40124b6a1de6411","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"name":"伊yi"},{"profileUrl":"https://www.zhihu.com/people/chen-yu-shao-26","bio":"兴趣广泛而不精通","hash":"aebff3d8ef69b745fb9e83d1d0957320","uid":665139991441707000,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"chen-yu-shao-26","avatar":{"id":"89d0c5c49e64d8496686813f0813703e","template":"https://pic3.zhimg.com/{id}_{size}.jpg"},"name":"陈宇韶"},{"profileUrl":"https://www.zhihu.com/people/waylanpunch","bio":"我头像像屌吗？","hash":"c51ca7c4bcf9563f8ef3fa1c476be85a","uid":548537727541514240,"isOrg":false,"description":"知乎四美之首！","isOrgWhiteList":false,"slug":"waylanpunch","avatar":{"id":"v2-9aaf9b243f06e0187ed91d8d13ba7aea","template":"https://pic3.zhimg.com/{id}_{size}.jpg"},"name":"Waylan Punch"},{"profileUrl":"https://www.zhihu.com/people/ginkgo-pine","bio":null,"hash":"d90b01dd76f148b1e7a89480b52f1065","uid":731514300488773600,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"ginkgo-pine","avatar":{"id":"v2-0e756cc6567b504da35e9a1b8887969e","template":"https://pic3.zhimg.com/{id}_{size}.jpg"},"name":"Ginkgo pine"},{"profileUrl":"https://www.zhihu.com/people/andyblocker","bio":"啥都不会的学生狗","hash":"749d2ee1773b1fcc18536c6353d0a9c8","uid":771042821418258400,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"andyblocker","avatar":{"id":"v2-476f18b7be12cad9551516ab4b849d95","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"name":"AndyBlocker"}],"summary":"介绍Tensorflow摘自维基百科的一段文字：TensorFlow是Google Brain的第二代机器学习系统，2015年11月9日，参考实现作为开源软件发布。虽然参考实现运行在单台设备，TensorFlow可以运行在多个CPU和GPU（和可选的CUDA扩展）。它运行在64位Linux或macOS桌面或…","reviewingCommentsCount":0,"meta":{"previous":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic4.zhimg.com/v2-12839bc99b6e7c81ee2048a1b9f6bea3_r.png","links":{"comments":"/api/posts/25489673/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19592366","id":"19592366","name":"MFC"},{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"},{"url":"https://www.zhihu.com/topic/19593616","id":"19593616","name":"编程学习"}],"href":"/api/posts/25489673","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<p>MFC课设做的一款矢量图形编辑器。</p><p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/GraphEditor/releases/tag/1.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Release 图形编辑器 · bajdcc/GraphEditor · GitHub<i class=\"icon-external\"></i></a><br></p><br><h2>功能概述</h2><ol><li> 添加启动界面<br></li><li> 文件可保存为位图（光栅化）和矢量图（序列化）<br></li><li> 添加控制面板和工具栏<br></li><li> 添加图形列表（双击定位）<br></li><li> 图形信息显示（选中右键）<br></li><li> 图形信息编辑（选中右键）<br></li><li> 图形删除（选中右键）<br></li><li> 图形拖拽与复制（按Ctrl键）<br></li><li> 图形拉伸变形<br></li><li> 图形位置微调（按方向键）<br></li><li> 撤消和恢复功能<br></li><li> Tab次序预览（Tab键）<br></li><li> 右键直接进入选择状态<br></li><li> 设置隐藏和显示隐藏（图形菜单）<br></li><li> 响应鼠标滚动<br></li><li> 画布动态响应窗口大小变化<br></li></ol><br><p><b>本系列主要介绍以下功能的实现：</b></p><ol><li>工厂模式实现4种矢量图形（直线、矩形、椭圆、曲线）的绘制</li><li>图形的数据结构与序列化</li><li>图形的绘制与拉伸，Shift键画正圆、正方形、45度斜线的实现</li><li>图形的选中与拖拽，选择模式的实现，使用方向键移动</li><li>历史记录功能的实现，支持撤销与重做</li><li>启动界面Splash的实现机制</li><li>双缓冲绘图</li><li>图形信息菜单的实现</li></ol><br><h2>使用帮助</h2><ol><li> 图片只能保存为位图（*.bmp），且为无损压缩</li><li> 控制栏可供选择的内容：<br></li><ol><li>   画笔颜色、风格、粗细</li><li>   画刷颜色、风格</li></ol><li> 在选择模式下可以进行的操作：<br></li><ol><li>   选中、拖动、拉伸变形、按CTRL键复制、按方向键进行微调</li><li>   右键菜单弹出信息（先选中）：包括画布大小、图形操作、图形信息概况</li><li>   选中之后必须按住图形周围的圆点进行变形</li></ol><li> 在画图模式下可以进行的操作：<br></li><ol><li>   一般操作</li><li>   按SHIFT键画正形（正圆、正方形、斜45度直线）</li></ol><li> 附加功能：<br></li><ol><li>   Tab次序：控制显示在【图形】菜单中调整</li><li>   隐藏：图形设置隐藏，隐藏显示在【图形】菜单中调整</li><li>   自定义名称：图形设置中更改</li><li>   图形列表：双击可定位图形，选中图形也会定位列表</li></ol></ol><br><h2>简要介绍</h2><p> 1. 概况</p><p>    （1）代码行数：约3000行（View：~1000 Graphic：~1000）</p><p>    （2）主要类名：（带*的会有技术讲解）</p><p>        * CGraphic（子类：直线类CLine，椭圆类CEllipse，矩形类CRectangle，曲线类CCurve）</p><p>        CHelpDlg（模态帮助提示界面）</p><p>        * CStartupDlg（非模态启动界面）</p><p>        ConfigDlg（模态图形编辑界面）</p><p>        GraphicMember（通用图形数据转存类）</p><p>        * CGraphicLog（操作记录类，实现撤消和恢复）</p><p> 2. 类的讲解和技术解析（带*的会详解）</p><p>    （1）CGraphic：图形基类</p><p>        1) 基类及派生类数据成员（看名称，略）</p><p>        2) 主要静态函数</p><p>            CreateGraphic： 根据介质创建相应类并赋值</p><p>            GetIdBySelection... ： 存储画笔（刷）类型的一种方式，采用位运算</p><p>            LineHitTest： 若点在直线上，那么短两边和等于第三边，以此判断</p><p>        3) 主要成员函数</p><p>            Serialize： 序列化（在子类中必须先调用父类的序列化）</p><p>            UpdateData： 类似于MFC中的UpdateData（GraphicMember充当交换介质）</p><p>            Draw： 画图</p><p>            DrawSelectedEdge： 画选中后四周的点</p><p>            * HitTest： 测试点是否在图形内部，若是，bResult为真</p><p>            * HitSizingTest： 测试点是否在图形的四周变形点上，若是，bResult为真</p><p>            GetRect： 返回图形的矩形坐标，便于重绘</p><p>        4) 宏</p><p>            选择误差：（-&amp;gt;N：趋于N更精确）</p><p>                SELECT_MISS_LINE： 直线（-&amp;gt;1）</p><p>                SELECT_MISS_ELLIPSE： 椭圆（-&amp;gt;0）</p><p>                DRAG_INF_WIDTH： 拉伸圆点</p><p>            其他：</p><p>                INF_WIDTH： 图形外边框厚度</p><p>                LOG_MAX_SAVE： 最大撤消数</p><p>                图形类的类型（LINE...）</p><p>                IF_NULL_PEN： 是否是透明画笔</p><p>                IF_NULL_BRUSH： 是否是透明画刷</p><p>                Convert_To_Graphic：转换为图形类</p><p>        5) 带*讲解</p><p>            HitTest和HitSizingTest：其实就是个回调函数，用来判断点是否在图形内部</p><p>                HitSizingTest有另外两个参数 PtX PtY，是int**类型（有原因的）</p><p>                假如要让图形变形，就要改它坐标，有时要改它的A坐标的X，B坐标的Y</p><p>                那么就要保存原坐标的LONG变量指针，再间接改变它</p><p>        6) 其他内容</p><p>            操作图形的界面很特殊。可以这么想，假如所有图形就不可拖动和更改，图形</p><p>                内容变的丰富，可以响应许多消息，可以加载位图，那么这个程序就实现</p><p>                了一般商业程序UI的功能。所以，可以用设计UI的思想来设计这些类。</p><p>            一般的开源UI库有Duilib和XCGUI，涉及工厂模式，观察者模式等等模式，且</p><p>                实现控件坐标非硬性编码，界面可由ZIP加载（通过解析XML和图片），</p><p>                所以多读优秀的代码可以提升思想。</p><p>            有兴趣可以看Java的《Head First设计模式》，语言不同，但思想是互通的。</p><p>            MFC的思想不错，只是可重用性不足，安全性不足，所以现在的软件一般采用</p><p>                开源的或自己开发的界面库。</p><p>            掌握了思想，技术实现就不是问题（只是时间问题）。</p><p>    （2）CGraphicLog</p><p>        1) 枚举体： 代表操作类型，包括新增，更改，删除</p><p>        2) 结构体： GraphicOperation 包括操作类型，保存的数据对象，对应下标</p><p>            Trace函数便于调试</p><p>        3) 单词解释： Undo - 撤消，Done - 恢复</p><p>        4) 解释</p><p>            本类的实现思想略为复杂（详见代码注释）</p><p>            虽然有两个成员是CList，但实现的功能是堆栈（思考为什么）</p><p>            因为删除了对象，不能真删了它，不然怎么恢复？</p><p>            对象被更改了，得保存更改之前的备份，这是UPDATE操作（new操作）</p><p>            我又画了东西，那么Done里的东西不复存在，记录记不下了，要删</p><p>            可是会导致重复删除（思考？），怎么解决？</p><p>               “引用”思想</p><p>            ——创建时维持引用计数为1，删除时减去1，如果计数为0则删除。</p><p>    （3）CStartupDlg</p><p>        运用工具：定时器，无模态对话框，线程</p><p>        线程同步方法：事件（CEvent-&amp;gt;HANDLE），WaitingForSingleObject</p><br><p> 3. 其他技术解析</p><p>    （1）双缓冲位图和后台位图</p><p>            直接在屏幕DC上操作，那么每画一次，就得更新一次界面，所以会闪屏</p><p>            如果在缓冲上操作，然后BitBlt给屏幕，那只要更新一次</p><p>            后台位图的功能是：当拖拽图形A的时候，除去这个图形之外的所有图形</p><p>            全部画在X上，此时拖动A，只要将屏幕重设成X，再画改变坐标后的A，</p><p>            再加上双缓冲，就可以有效避免闪屏</p><p>            注：为了简便（累。。），有些细节没有处理，所以还是会有闪屏</p><p>            注2： 在有些BitBlt操作之前，必须先调用UpdateWindow</p><p>    （2）保存为位图</p><p>            位图：BITMAPFILEHEADER，BITMAPINFO，位图像素</p><p>            函数实现详见XXXView::OnSaveAsBitmap，方法固定</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":25489673,"publishedTime":"2017-03-01T08:02:13+08:00","url":"/p/25489673","title":"【MFC】图形编辑器（一）","summary":"MFC课设做的一款矢量图形编辑器。<a href=\"https://github.com/bajdcc/GraphEditor/releases/tag/1.0\" class=\"\" data-editable=\"true\" data-title=\"Release 图形编辑器 · bajdcc/GraphEditor · GitHub\">Release 图形编辑器 · bajdcc/GraphEditor · GitHub</a> 功能概述 添加启动界面 文件可保存为位图（光栅化）和矢量图（序列化） 添加控制面板和工具栏 添加图形列表（双击定位） 图形信息显示（选中右键） 图形信息编辑（选中…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0},"next":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic2.zhimg.com/v2-d58044ead3cbb0d8fb1caafd05fe252d_r.png","links":{"comments":"/api/posts/25593280/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19561633","id":"19561633","name":"C（编程语言）"},{"url":"https://www.zhihu.com/topic/19625716","id":"19625716","name":"算法与数据结构"},{"url":"https://www.zhihu.com/topic/19612186","id":"19612186","name":"Lua"}],"href":"/api/posts/25593280","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<h2>写在前面</h2><p>看到过类似的将寻路算法可视化的文章。</p><ul><li><a href=\"http://link.zhihu.com/?target=http%3A//blog.csdn.net/booirror/article/details/50834915\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">A*算法可视化详解与实现 - 代码妖娆 - 博客频道 - CSDN.NET<i class=\"icon-external\"></i></a></li><li><a href=\"https://zhuanlan.zhihu.com/p/23199073\" class=\"internal\">A*寻路算法的探寻与改良（一） - 知乎专栏</a><br></li></ul><p>寻思着将它们整合进游戏框架，总体上说，整合难度比较低。</p><br><h2>实现思路</h2><p>先前实现了TableLayout，设定长宽，可以均匀排布容器内各元素。题图中的方格也是这样的实现思路。</p><p>只实现了广度遍历BFS和深度遍历DFS，两者是经典的遍历算法。</p><p><b>书上一般采用open和closed两个表的方式，这里为了图简单，就用一张表实现了。</b>图的结构二维矩阵表示，1表示未访问过，3、4表示起点和终点，2表示墙，6及以上表示访问过。那么每次访问只要将矩阵中的值标记下即可。</p><ul><li>BFS是将当前访问方块的相邻未访问方块添加进表的末尾，每次从表头取出将要访问的方块。由于添加的方块要隔一段时间才能访问到，所以可能导致表的体积迅速增大。因此，BFS的效率比较差，它会遍历所有的方块，将它能够找到全局最优解。《后天》中的海水淹没城市也是BFS的体现。<br></li><li>DFS每次将当前方块的相邻未访问方块添加进表的头部，每次从表头取方块。所以与BFS不同，新添加的方块立马就被访问，故表的体积不会迅速增大。它能快速找到解，但不一定是全局最优解。生活中的闪电生长方式就是DFS。</li></ul><p>两种算法只是对于表的添加方式不同，DFS是添加到头部，BFS是添加到尾部。</p><p>这里主要的难点在于，方块的颜色是渐变的，离起点（红色）近的呈黑色，远的呈天蓝色。计算方式是求任意点到起点的距离，然后根据HSL转换到RGB，HSL的色相是固定的，而亮度是可以调整的，从而实现渐变效果。</p><p>-------------------------------------------------</p><p>下面实现(伪)A*算法。</p><p><img src=\"https://pic3.zhimg.com/v2-21a4c9f2c5b8ec365f4dcaefff1832d6_b.png\" data-rawwidth=\"1031\" data-rawheight=\"628\" class=\"origin_image zh-lightbox-thumb\" width=\"1031\" data-original=\"https://pic3.zhimg.com/v2-21a4c9f2c5b8ec365f4dcaefff1832d6_r.png\"><u>BFS和DFS方法都有缺点：BFS能找到全局最优，然而它需要将所有位置都访问一遍，耗时间；DFS快，但只是局部最优，且DFS如何挑选需展开的结点也没有明确规定。</u></p><p>A*对上述方式有了改进。A*给出了一个评估函数F。F=G+H。G是当前移动量，H是评估的待移动距离，两者总和是当前结节的评估值，当然，值越小，走这条路的可能性越大。</p><p>解决方法很简单：<b>令G=累积的移动距离；令H=当前位置离终点的哈密顿距离</b>。在展开结点的时候，对待选结点按F值排序，使F值最小的最先展开，从而节省时间。</p><p>A*的实现一般用open和closed表，它将open表中的结点按F排序，选代价最小的展开。<b>也就是说，A*算法每一次将open表中的结点进行排序，而A*的展开方式类似于BFS。</b>为什么是基于BFS？因为BFS产生的open表结点是当前已遍历结点的<b>轮廓</b>，这有点像最小生成树算法，从当前轮廓中挑选代价最小的结点进行展开。唯一影响A*效率的就是F的计算方法。<br></p><p><i><u>PS：由于偷懒，实现A*与上面的不同！上面是将open进行排序，而我只将当前结点的相邻结点进行排序，所以算法效果肯定没A*好。再者，本系列的目标是做GUI，算法可视化只是一个demo。</u></i></p><h2>阶段性总结</h2><p>A*算法的关键是设立一个评估函数，就如同阿法狗对局面的估计一样。它采用的其实类似于最小生成树的方式(把格子想成上下左右相连的图)，只是最小生成树的挑选规则是确定的(路径长度确定)，A*的挑选规则是不确定的(评估函数不精准)。这导致最小生成树产生最优解，而A*不一定能得到最优解。</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":25593280,"publishedTime":"2017-03-06T16:31:53+08:00","url":"/p/25593280","title":"【游戏框架系列】柳暗花明","summary":"写在前面看到过类似的将寻路算法可视化的文章。<a href=\"http://link.zhihu.com/?target=http%3A//blog.csdn.net/booirror/article/details/50834915\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">A*算法可视化详解与实现 - 代码妖娆 - 博客频道 - CSDN.NET<i class=\"icon-external\"></i></a><a href=\"https://zhuanlan.zhihu.com/p/23199073\" class=\"internal\">A*寻路算法的探寻与改良（一） - 知乎专栏</a> 寻思着将它们整合进游戏框架，总体上说，整合难度比较低。 实现思路先前实现了TableLayout，设定长宽，可…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0}},"commentsCount":2,"likesCount":15,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{}},"me":{},"global":{},"columns":{"learncpp":{"following":false,"canManage":false,"href":"/api/columns/learncpp","name":"从零开始构建标准库","creator":{"slug":"bajdcc"},"url":"/learncpp","slug":"learncpp","avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"FULLINFO":false}},"columnPosts":{},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true}}</textarea>

    <script src="//static.zhihu.com/hemingway/common.ac46319b23e12700340a.js"></script>
<script src="//static.zhihu.com/hemingway/app.47dccfede9fcf0800757.js"></script>
<script src="//static.zhihu.com/hemingway/raven.ccdadd4407812d1aac2f.js" async defer></script>
  </body>
</html>
