<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>【MFC】图形编辑器（一） - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.ad2159a596c8458712d70cf5a5b17235.css" />
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"25489673":{"title":"【MFC】图形编辑器（一）","author":"bajdcc","content":"<p>MFC课设做的一款矢量图形编辑器。</p><p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/GraphEditor/releases/tag/1.0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Release 图形编辑器 · bajdcc/GraphEditor · GitHub<i class=\"icon-external\"></i></a><br></p><br><h2>功能概述</h2><ol><li> 添加启动界面<br></li><li> 文件可保存为位图（光栅化）和矢量图（序列化）<br></li><li> 添加控制面板和工具栏<br></li><li> 添加图形列表（双击定位）<br></li><li> 图形信息显示（选中右键）<br></li><li> 图形信息编辑（选中右键）<br></li><li> 图形删除（选中右键）<br></li><li> 图形拖拽与复制（按Ctrl键）<br></li><li> 图形拉伸变形<br></li><li> 图形位置微调（按方向键）<br></li><li> 撤消和恢复功能<br></li><li> Tab次序预览（Tab键）<br></li><li> 右键直接进入选择状态<br></li><li> 设置隐藏和显示隐藏（图形菜单）<br></li><li> 响应鼠标滚动<br></li><li> 画布动态响应窗口大小变化<br></li></ol><br><p><b>本系列主要介绍以下功能的实现：</b></p><ol><li>工厂模式实现4种矢量图形（直线、矩形、椭圆、曲线）的绘制</li><li>图形的数据结构与序列化</li><li>图形的绘制与拉伸，Shift键画正圆、正方形、45度斜线的实现</li><li>图形的选中与拖拽，选择模式的实现，使用方向键移动</li><li>历史记录功能的实现，支持撤销与重做</li><li>启动界面Splash的实现机制</li><li>双缓冲绘图</li><li>图形信息菜单的实现</li></ol><br><h2>使用帮助</h2><ol><li> 图片只能保存为位图（*.bmp），且为无损压缩</li><li> 控制栏可供选择的内容：<br></li><ol><li>   画笔颜色、风格、粗细</li><li>   画刷颜色、风格</li></ol><li> 在选择模式下可以进行的操作：<br></li><ol><li>   选中、拖动、拉伸变形、按CTRL键复制、按方向键进行微调</li><li>   右键菜单弹出信息（先选中）：包括画布大小、图形操作、图形信息概况</li><li>   选中之后必须按住图形周围的圆点进行变形</li></ol><li> 在画图模式下可以进行的操作：<br></li><ol><li>   一般操作</li><li>   按SHIFT键画正形（正圆、正方形、斜45度直线）</li></ol><li> 附加功能：<br></li><ol><li>   Tab次序：控制显示在【图形】菜单中调整</li><li>   隐藏：图形设置隐藏，隐藏显示在【图形】菜单中调整</li><li>   自定义名称：图形设置中更改</li><li>   图形列表：双击可定位图形，选中图形也会定位列表</li></ol></ol><br><h2>简要介绍</h2><p> 1. 概况</p><p>    （1）代码行数：约3000行（View：~1000 Graphic：~1000）</p><p>    （2）主要类名：（带*的会有技术讲解）</p><p>        * CGraphic（子类：直线类CLine，椭圆类CEllipse，矩形类CRectangle，曲线类CCurve）</p><p>        CHelpDlg（模态帮助提示界面）</p><p>        * CStartupDlg（非模态启动界面）</p><p>        ConfigDlg（模态图形编辑界面）</p><p>        GraphicMember（通用图形数据转存类）</p><p>        * CGraphicLog（操作记录类，实现撤消和恢复）</p><p> 2. 类的讲解和技术解析（带*的会详解）</p><p>    （1）CGraphic：图形基类</p><p>        1) 基类及派生类数据成员（看名称，略）</p><p>        2) 主要静态函数</p><p>            CreateGraphic： 根据介质创建相应类并赋值</p><p>            GetIdBySelection... ： 存储画笔（刷）类型的一种方式，采用位运算</p><p>            LineHitTest： 若点在直线上，那么短两边和等于第三边，以此判断</p><p>        3) 主要成员函数</p><p>            Serialize： 序列化（在子类中必须先调用父类的序列化）</p><p>            UpdateData： 类似于MFC中的UpdateData（GraphicMember充当交换介质）</p><p>            Draw： 画图</p><p>            DrawSelectedEdge： 画选中后四周的点</p><p>            * HitTest： 测试点是否在图形内部，若是，bResult为真</p><p>            * HitSizingTest： 测试点是否在图形的四周变形点上，若是，bResult为真</p><p>            GetRect： 返回图形的矩形坐标，便于重绘</p><p>        4) 宏</p><p>            选择误差：（-&amp;gt;N：趋于N更精确）</p><p>                SELECT_MISS_LINE： 直线（-&amp;gt;1）</p><p>                SELECT_MISS_ELLIPSE： 椭圆（-&amp;gt;0）</p><p>                DRAG_INF_WIDTH： 拉伸圆点</p><p>            其他：</p><p>                INF_WIDTH： 图形外边框厚度</p><p>                LOG_MAX_SAVE： 最大撤消数</p><p>                图形类的类型（LINE...）</p><p>                IF_NULL_PEN： 是否是透明画笔</p><p>                IF_NULL_BRUSH： 是否是透明画刷</p><p>                Convert_To_Graphic：转换为图形类</p><p>        5) 带*讲解</p><p>            HitTest和HitSizingTest：其实就是个回调函数，用来判断点是否在图形内部</p><p>                HitSizingTest有另外两个参数 PtX PtY，是int**类型（有原因的）</p><p>                假如要让图形变形，就要改它坐标，有时要改它的A坐标的X，B坐标的Y</p><p>                那么就要保存原坐标的LONG变量指针，再间接改变它</p><p>        6) 其他内容</p><p>            操作图形的界面很特殊。可以这么想，假如所有图形就不可拖动和更改，图形</p><p>                内容变的丰富，可以响应许多消息，可以加载位图，那么这个程序就实现</p><p>                了一般商业程序UI的功能。所以，可以用设计UI的思想来设计这些类。</p><p>            一般的开源UI库有Duilib和XCGUI，涉及工厂模式，观察者模式等等模式，且</p><p>                实现控件坐标非硬性编码，界面可由ZIP加载（通过解析XML和图片），</p><p>                所以多读优秀的代码可以提升思想。</p><p>            有兴趣可以看Java的《Head First设计模式》，语言不同，但思想是互通的。</p><p>            MFC的思想不错，只是可重用性不足，安全性不足，所以现在的软件一般采用</p><p>                开源的或自己开发的界面库。</p><p>            掌握了思想，技术实现就不是问题（只是时间问题）。</p><p>    （2）CGraphicLog</p><p>        1) 枚举体： 代表操作类型，包括新增，更改，删除</p><p>        2) 结构体： GraphicOperation 包括操作类型，保存的数据对象，对应下标</p><p>            Trace函数便于调试</p><p>        3) 单词解释： Undo - 撤消，Done - 恢复</p><p>        4) 解释</p><p>            本类的实现思想略为复杂（详见代码注释）</p><p>            虽然有两个成员是CList，但实现的功能是堆栈（思考为什么）</p><p>            因为删除了对象，不能真删了它，不然怎么恢复？</p><p>            对象被更改了，得保存更改之前的备份，这是UPDATE操作（new操作）</p><p>            我又画了东西，那么Done里的东西不复存在，记录记不下了，要删</p><p>            可是会导致重复删除（思考？），怎么解决？</p><p>               “引用”思想</p><p>            ——创建时维持引用计数为1，删除时减去1，如果计数为0则删除。</p><p>    （3）CStartupDlg</p><p>        运用工具：定时器，无模态对话框，线程</p><p>        线程同步方法：事件（CEvent-&amp;gt;HANDLE），WaitingForSingleObject</p><br><p> 3. 其他技术解析</p><p>    （1）双缓冲位图和后台位图</p><p>            直接在屏幕DC上操作，那么每画一次，就得更新一次界面，所以会闪屏</p><p>            如果在缓冲上操作，然后BitBlt给屏幕，那只要更新一次</p><p>            后台位图的功能是：当拖拽图形A的时候，除去这个图形之外的所有图形</p><p>            全部画在X上，此时拖动A，只要将屏幕重设成X，再画改变坐标后的A，</p><p>            再加上双缓冲，就可以有效避免闪屏</p><p>            注：为了简便（累。。），有些细节没有处理，所以还是会有闪屏</p><p>            注2： 在有些BitBlt操作之前，必须先调用UpdateWindow</p><p>    （2）保存为位图</p><p>            位图：BITMAPFILEHEADER，BITMAPINFO，位图像素</p><p>            函数实现详见XXXView::OnSaveAsBitmap，方法固定</p>","updated":"2017-03-01T00:02:13.000Z","canComment":false,"commentPermission":"anyone","commentCount":0,"collapsedCount":0,"likeCount":0,"state":"published","isLiked":false,"slug":"25489673","isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic4.zhimg.com/v2-12839bc99b6e7c81ee2048a1b9f6bea3_r.png","links":{"comments":"/api/posts/25489673/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/19592366","id":"19592366","name":"MFC"},{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"},{"url":"https://www.zhihu.com/topic/19593616","id":"19593616","name":"编程学习"}],"titleImageSize":{"width":1049,"height":626},"href":"/api/posts/25489673","excerptTitle":"","column":{"slug":"learncpp","name":"从零开始构建标准库"},"tipjarState":"inactivated","sourceUrl":"","pageCommentsCount":0,"snapshotUrl":"","publishedTime":"2017-03-01T08:02:13+08:00","url":"/p/25489673","lastestLikers":[],"summary":"MFC课设做的一款矢量图形编辑器。<a href=\"https://github.com/bajdcc/GraphEditor/releases/tag/1.0\" class=\"\" data-editable=\"true\" data-title=\"Release 图形编辑器 · bajdcc/GraphEditor · GitHub\">Release 图形编辑器 · bajdcc/GraphEditor · GitHub</a> 功能概述 添加启动界面 文件可保存为位图（光栅化）和矢量图（序列化） 添加控制面板和工具栏 添加图形列表（双击定位） 图形信息显示（选中右键） 图形信息编辑（选中…","reviewingCommentsCount":0,"meta":{"previous":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic4.zhimg.com/v2-a3575227ada68693bc7eef27cedccb97_r.png","links":{"comments":"/api/posts/25476629/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19612186","id":"19612186","name":"Lua"},{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"},{"url":"https://www.zhihu.com/topic/19593616","id":"19593616","name":"编程学习"}],"href":"/api/posts/25476629","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/GameFramework/releases/tag/0.1.6\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Release 实现异步更新网络图片 · bajdcc/GameFramework · GitHub<i class=\"icon-external\"></i></a><br></p><h2>写在前面</h2>计划着将一些好用的东西整合进框架中，目前用了libevent和libcurl，仅当尝鲜。话说libcurl的使用其实很简单，跟php的curl扩展差不多。libevent是初次使用，很多坑尚未发现。<p>简单介绍下封面界面的构成：必应背景、一言API、文字、二维码。其中新增的是前二个：必应背景和一言文字。</p><p>下面是主要内容：</p><ol><li>libevent和libcurl的编译与使用</li><li>如何实现异步刷新，且涉及网络请求</li></ol><h2>使用libevent</h2><p>项目中需要用到libevent，实现异步通知功能。libevent支持网络/文件IO、定时器、信号。在这里，我们只需要用到其中的<b>定时器</b>功能。</p><p><b>vs2015中编译静态库libevent</b></p><ol><li>下载libevent源码<a href=\"http://link.zhihu.com/?target=https%3A//github.com/libevent/libevent/releases/download/release-2.0.22-stable/libevent-2.0.22-stable.tar.gz\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">libevent-2.0.22-stable.tar.gz<i class=\"icon-external\"></i></a></li><li>下载<a href=\"http://link.zhihu.com/?target=https%3A//github.com/libevent/libevent/raw/master/Makefile.nmake\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Makefile.nmake<i class=\"icon-external\"></i></a>到libevent目录，默认是release版本；若需要编译debug版本，需要修改其中的第26行`CFLAGS=$(CFLAGS) /Ox /W3 /wd4996 /nologo`为`CFLAGS=$(CFLAGS) /Od /Zi /W3 /wd4996 /nologo`</li><li>开始菜单=&amp;gt;vs2015开发人员命令提示，cd切换到libevent目录，执行命令nmake /F makefile.nmake；如果要清空上一次编译的结果，执行nmake /F makefile.nmake clean</li><li>复制目录下的libevent.lib、libevent_core.lib、libevent_extras.lib到项目中</li></ol><p><b>libevent的简单使用</b></p><div class=\"highlight\"><pre><code class=\"language-c\"><span></span><span class=\"kt\">void</span> <span class=\"nf\">msg_timer</span><span class=\"p\">(</span><span class=\"n\">evutil_socket_t</span> <span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"kt\">short</span> <span class=\"n\">event</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">arg</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"cm\">/*do something...*/</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">event_base</span> <span class=\"o\">*</span><span class=\"n\">evbase</span> <span class=\"o\">=</span> <span class=\"n\">event_base_new</span><span class=\"p\">();</span><span class=\"c1\">//初始化event_base，一线程一个</span>\n<span class=\"k\">struct</span> <span class=\"n\">event</span> <span class=\"n\">msgtimer</span><span class=\"p\">;</span>\n<span class=\"k\">struct</span> <span class=\"n\">timeval</span> <span class=\"n\">tv</span><span class=\"p\">;</span>\n<span class=\"n\">evtimer_assign</span><span class=\"p\">(</span><span class=\"o\">&amp;amp;</span><span class=\"n\">msgtimer</span><span class=\"p\">,</span> <span class=\"n\">evbase</span><span class=\"p\">,</span> <span class=\"o\">&amp;amp;</span><span class=\"n\">msg_timer</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span><span class=\"c1\">//初始化事件</span>\n<span class=\"n\">evutil_timerclear</span><span class=\"p\">(</span><span class=\"o\">&amp;amp;</span><span class=\"n\">tv</span><span class=\"p\">);</span>\n<span class=\"n\">tv</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"n\">tv</span><span class=\"p\">.</span><span class=\"n\">tv_usec</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"c1\">//10毫秒后触发事件</span>\n<span class=\"n\">evtimer_add</span><span class=\"p\">(</span><span class=\"o\">&amp;amp;</span><span class=\"n\">msgtimer</span><span class=\"p\">,</span> <span class=\"o\">&amp;amp;</span><span class=\"n\">tv</span><span class=\"p\">);</span><span class=\"c1\">//将事件加入到队列中</span>\n<span class=\"n\">event_base_dispatch</span><span class=\"p\">(</span><span class=\"n\">evbase</span><span class=\"p\">);</span><span class=\"c1\">//开始处理队列</span>\n<span class=\"n\">event_base_free</span><span class=\"p\">(</span><span class=\"n\">evbase</span><span class=\"p\">);</span><span class=\"c1\">//释放</span>\n</code></pre></div><p>上述例子简单介绍了如何用libevent设置定时事件。</p><h2>使用libcurl</h2><p>curl和wget是做爬虫的常用工具，它们有很多功能。这里，项目中使用libcurl来下载web上的json。</p><p><b>vs2015中编译静态库libcurl</b><br></p><ol><li>下载libcurl源码<a href=\"http://link.zhihu.com/?target=https%3A//curl.haxx.se/download/curl-7.53.1.tar.gz\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">curl-7.53.1.tar.gz<i class=\"icon-external\"></i></a></li><li>打开vs2015工具命令提示，进入到curl\\winbuild目录，执行nmake -F Makefile.vc mode=static VC=14 DEBUG=no MACHINE=x86，这里编译的是32位适用于VS2015的静态库release版本；如果需要调试，令DEBUG=yes</li><li>编译好的文件在curl\\builds\\libcurl-vc14-x86-debug-static-ipv6-sspi-winssl下；我们需要lib下的静态库，以及include中的头文件<br></li></ol><p>libcurl的简单使用</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">static</span> <span class=\"kt\">size_t</span> <span class=\"nf\">http_get_process</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"kt\">size_t</span> <span class=\"n\">size</span><span class=\"p\">,</span> <span class=\"kt\">size_t</span> <span class=\"n\">nmemb</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;amp;</span><span class=\"n\">content</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">sizes</span> <span class=\"o\">=</span> <span class=\"n\">size</span> <span class=\"o\">*</span> <span class=\"n\">nmemb</span><span class=\"p\">;</span>\n    <span class=\"n\">content</span> <span class=\"o\">+=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"p\">((</span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">sizes</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">sizes</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">curl_global_init</span><span class=\"p\">(</span><span class=\"n\">CURL_GLOBAL_ALL</span><span class=\"p\">);</span>\n<span class=\"n\">CURL</span> <span class=\"o\">*</span><span class=\"n\">curl</span> <span class=\"o\">=</span> <span class=\"n\">curl_easy_init</span><span class=\"p\">();</span><span class=\"c1\">//初始化</span>\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">text</span><span class=\"p\">;</span><span class=\"c1\">//保存的内容</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_URL</span><span class=\"p\">,</span> <span class=\"s\">\"http://www.baidu.com\"</span><span class=\"p\">);</span><span class=\"c1\">//url</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_USERAGENT</span><span class=\"p\">,</span> <span class=\"s\">\"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/50.0.2661.102 Safari/537.36\"</span><span class=\"p\">);</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_CONNECTTIMEOUT</span><span class=\"p\">,</span> <span class=\"mi\">2L</span><span class=\"p\">);</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_TIMEOUT</span><span class=\"p\">,</span> <span class=\"mi\">2L</span><span class=\"p\">);</span><span class=\"c1\">//超时，单位秒</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_FOLLOWLOCATION</span><span class=\"p\">,</span> <span class=\"mi\">1L</span><span class=\"p\">);</span><span class=\"c1\">//自动301、302跳转</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_ACCEPT_ENCODING</span><span class=\"p\">,</span> <span class=\"s\">\"\"</span><span class=\"p\">);</span><span class=\"c1\">//留空表示自动解压</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_SSL_VERIFYPEER</span><span class=\"p\">,</span> <span class=\"n\">TRUE</span><span class=\"p\">);</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_SSL_VERIFYHOST</span><span class=\"p\">,</span> <span class=\"n\">TRUE</span><span class=\"p\">);</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_WRITEDATA</span><span class=\"p\">,</span> <span class=\"o\">&amp;amp;</span><span class=\"n\">text</span><span class=\"p\">);</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_WRITEFUNCTION</span><span class=\"p\">,</span> <span class=\"o\">&amp;amp;</span><span class=\"n\">http_get_process</span><span class=\"p\">);</span>\n<span class=\"n\">CURLcode</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">curl_easy_perform</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">res</span> <span class=\"o\">==</span> <span class=\"n\">CURLE_OK</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"cm\">/*text中的内容就是url返回的内容，当然这里面有编码问题，暂且不谈*/</span>\n<span class=\"p\">}</span>\n<span class=\"n\">curl_easy_cleanup</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">);</span>\n<span class=\"n\">curl_global_cleanup</span><span class=\"p\">();</span>\n</code></pre></div><p>那么后面json的下载就要用到curl了。</p><h2>异步模型</h2><p><b>Win32事件驱动模型</b></p><p>经典的win32程序是基于消息的，程序不断处理操作系统给的消息，总体是单线程的。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"c1\">//消息处理函数</span>\n<span class=\"n\">LRESULT</span> <span class=\"n\">CALLBACK</span> <span class=\"nf\">WndProc</span><span class=\"p\">(</span><span class=\"n\">HWND</span> <span class=\"n\">hwnd</span><span class=\"p\">,</span> <span class=\"n\">UINT</span> <span class=\"n\">uMsg</span><span class=\"p\">,</span> <span class=\"n\">WPARAM</span> <span class=\"n\">wParam</span><span class=\"p\">,</span> <span class=\"n\">LPARAM</span> <span class=\"n\">lParam</span><span class=\"p\">)</span>\n\n<span class=\"c1\">//主循环</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">GetMessage</span> <span class=\"p\">(</span><span class=\"o\">&amp;amp;</span><span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">))</span>\n<span class=\"p\">{</span>\n     <span class=\"n\">TranslateMessage</span> <span class=\"p\">(</span><span class=\"o\">&amp;amp;</span><span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"p\">;</span> <span class=\"c1\">//翻译消息</span>\n     <span class=\"n\">DispatchMessage</span> <span class=\"p\">(</span><span class=\"o\">&amp;amp;</span><span class=\"n\">msg</span><span class=\"p\">)</span> <span class=\"p\">;</span> <span class=\"c1\">//分派消息</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>大道至简，一个循环解决问题。一般而言，这么写没问题。但是，如果涉及耗时的操作如网络IO……程序就假死了！</p><p>比如想做一个下载器，做一个带界面的爬虫，如果只是单线程处理，那么在下载过程中，win32窗口是无响应的，因为它卡在网络IO上了。为了避免这种情况，只能使用多线程。</p><p>有了多线程，也就有了竞争与冲突风险，以及各种线程同步问题，解决这些问题的关键是设计一个好用的、简单的模型。最终的思路必然是简单的，否则出了问题谁也找不出。</p><p><b>异步模型的思考</b></p><p>一般的思路：耗时的操作交给工作线程做，主线程处理窗口的消息。这里用libevent解决。</p><p>libevent其实也相当于一个死循环，在这个死循环中，它可以：</p><ol><li>查看当前是否有win32窗口的消息</li><li>查看定时器事件是否到期了</li><li>查看网络/文件IO是否完成</li></ol><p>注意，它一直在“查看”，也就是说，看看没消息，它就继续干别的事，不会卡死在一个地方。</p><p>那么结合win32和libevent，我们有：</p><ol><li>每隔10毫秒查看win32消息，若有，立马处理一个消息</li><li>不断监听定时器消息，若有，立马执行</li></ol><p>这样保证：win32消息的处理和定时器消息的处理<b>处于同一线程中</b>。这个“处于同一线程中”，好处可大了，因为可以避免线程同步等一系列问题。我们在win32主线程中用lua处理各种消息，而lua可以设置定时器；同样地，我们用lua处理定时器消息。<b>换句话说，自始至终，lua都跑在主线程中，跟其他线程无关。</b></p><p><b>异步下载网络资源</b></p><p>实现了整个框架最为核心的异步事件模型，那么如何解决网络资源下载问题呢？比如说，我想点击按钮，就下载一个json，通过分析json，下载相应的背景图片，并将这个图片作为程序的背景。</p><p>目前，libevent的设置定时器功能是可以跨线程调用的，要注意的是只有这里存在跨线程调用。</p><p>那么这一流程如下：</p><ol><li>按下按钮</li><li>lua处理单击事件，设置定时器timer1并传参request</li><li>timer1中，创建新线程thread2*</li><li>thread2*中，用libcurl下载json文件/图片，若下载成功，设置定时器timer2并传参response</li><li>timer2中，处理response，得到json/图片，用lua更新UI</li></ol><p>以上，打*星号的是其他线程，只有curl所在的thread2是其他线程，其他操作都在主线程中。这个模型也是实现题图效果的关键。</p><h2>其他的问题</h2>不是说实现了模型就能运行程序了，上得了厅堂、下得了厨房，还有些细节需要考虑。<p><b>编码问题</b></p><p>默认的std::string是GBK编码的，而一般的json文件是UTF-8，需要转码。</p><p>在curl中，我们用</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">content_type</span><span class=\"p\">;</span>\n<span class=\"n\">curl_easy_getinfo</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLINFO_CONTENT_TYPE</span><span class=\"p\">,</span> <span class=\"o\">&amp;amp;</span><span class=\"n\">content_type</span><span class=\"p\">);</span>\n</code></pre></div><p>如果content_type中有UTF-8出现，那么文件编码就是UTF8。<br></p><p>第一步：先用curl下载byte[]二进制数据</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"kt\">size_t</span> <span class=\"nf\">http_get_process_bin</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"kt\">size_t</span> <span class=\"n\">size</span><span class=\"p\">,</span> <span class=\"kt\">size_t</span> <span class=\"n\">nmemb</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&amp;lt;</span><span class=\"n\">byte</span><span class=\"o\">&amp;gt;</span> <span class=\"o\">&amp;amp;</span><span class=\"n\">content</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">sizes</span> <span class=\"o\">=</span> <span class=\"n\">size</span> <span class=\"o\">*</span> <span class=\"n\">nmemb</span><span class=\"p\">;</span>\n    <span class=\"k\">auto</span> <span class=\"n\">bin</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">byte</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">data</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">size_t</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&amp;lt;</span> <span class=\"n\">sizes</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">content</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">bin</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">sizes</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">auto</span> <span class=\"n\">bindata</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&amp;lt;</span><span class=\"n\">byte</span><span class=\"o\">&amp;gt;</span><span class=\"p\">();</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_WRITEDATA</span><span class=\"p\">,</span> <span class=\"n\">bindata</span><span class=\"p\">);</span>\n<span class=\"n\">curl_easy_setopt</span><span class=\"p\">(</span><span class=\"n\">curl</span><span class=\"p\">,</span> <span class=\"n\">CURLOPT_WRITEFUNCTION</span><span class=\"p\">,</span> <span class=\"o\">&amp;amp;</span><span class=\"n\">http_get_process_bin</span><span class=\"p\">);</span>\n<span class=\"cm\">/*其他的设置以及curl_easy_perform都省略了*/</span>\n</code></pre></div><p>将数据存到std::vector&amp;lt;byte&amp;gt;中。</p><p>第二步：转码，UTF8 to GBK</p><br><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"n\">CString</span> <span class=\"nf\">Utf8ToStringT</span><span class=\"p\">(</span><span class=\"n\">LPCSTR</span> <span class=\"n\">str</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">_ASSERT</span><span class=\"p\">(</span><span class=\"n\">str</span><span class=\"p\">);</span>\n    <span class=\"n\">USES_CONVERSION</span><span class=\"p\">;</span>\n    <span class=\"n\">WCHAR</span> <span class=\"o\">*</span><span class=\"n\">buf</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"n\">MultiByteToWideChar</span><span class=\"p\">(</span><span class=\"n\">CP_UTF8</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">str</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"k\">nullptr</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"n\">buf</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">WCHAR</span><span class=\"p\">[</span><span class=\"n\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n    <span class=\"n\">ZeroMemory</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">length</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">WCHAR</span><span class=\"p\">));</span>\n    <span class=\"n\">MultiByteToWideChar</span><span class=\"p\">(</span><span class=\"n\">CP_UTF8</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">str</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">length</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">CString</span><span class=\"p\">(</span><span class=\"n\">W2T</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)));</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">auto</span> <span class=\"n\">gbk</span> <span class=\"o\">=</span> <span class=\"n\">CStringA</span><span class=\"p\">(</span><span class=\"n\">content_type</span><span class=\"p\">);</span><span class=\"c1\">//gbk相当于std::string</span>\n</code></pre></div><p>其中CString是ATL中的unicode字符串。将CString自行转换至CStringA，而CStringA是ANSI编码的。</p><p><b>如何呈现网上下载的图片</b></p><p>先用libcurl下载二进制图片数据std::vector&amp;lt;byte&amp;gt; data，我们需要用一个byte[]类型去呈现它。</p><p>data首先存放在libcurl所在线程中，最终调用者却是渲染图元ImageElement位于主线程中的渲染事件中，两者相距太远，如何联络？</p><p>我采取的解决方法是：</p><ol><li>libcurl所在线程thread2*下载完图片数据data，注意，data是new出来的区域，不会自动释放</li><li>在thread*中设置定时器timer2，带参data，为了方便与lua互动，我将用base64字符串表示二进制数据data，那么存放在lua中的UI对象中的text就是<b>将指针地址进行base64编码后的字符串</b></li><li>一段时间过去了……</li><li>开始渲染事件了</li><li>ImageElementRender中，获取UI对象的text，它是个字符串，<b>用base64解码得到图片数据指针</b></li><li>利用指针中的二进制数据，初始化WICBitmap，进而初始化ID2D1Bitmap用于绘制，释放数据data</li><li>为防止多次渲染闪屏，将WICBitmap保存，仅当图片URL变化时进行重新绘制操作，每次用WICBitmap初始化ID2D1Bitmap</li></ol><br><h2>阶段性小结</h2><p>花了两天时间实现上网爬json下图片设置背景与文字，让程序具有“诗情画意”。同样地，完成这个功能后，感到的喜悦与满足是远大于先前编程中遇到的困难的，不仅仅是编程，任何一件事，锲而不舍去做，总有质变的那天。就像好声音中的，一开始人被音乐玩，后来才能玩音乐。什么时候能够玩编程，不是被编程玩呢？绳锯木断，水滴石穿，不停做下去，不断走出舒适区，不断迎接新的突破。当知识在脑海中渐渐汇成整体性的知识框架，就是量变到质变的体现，而在这个突破之前，需要的是漫长的积累时间。然而，不能因为积累太长太累而放弃，人总归要向前看。</p><p>下面的任务是做一个计算器，做一个A*寻路可视化界面，总体并不难。</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":25476629,"publishedTime":"2017-02-28T14:18:51+08:00","url":"/p/25476629","title":"【游戏框架系列】诗情画意","summary":"<a href=\"https://github.com/bajdcc/GameFramework/releases/tag/0.1.6\" class=\"\" data-editable=\"true\" data-title=\"Release 实现异步更新网络图片 · bajdcc/GameFramework · GitHub\">Release 实现异步更新网络图片 · bajdcc/GameFramework · GitHub</a> 写在前面计划着将一些好用的东西整合进框架中，目前用了libevent和libcurl，仅当尝鲜。话说libcurl的使用其实很简单，跟php的curl扩展差不多。libevent是初次使用，很多坑尚未发现。简单介…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0},"next":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic1.zhimg.com/v2-6cd541cd9f4d479281d00d7d378c3298_r.png","links":{"comments":"/api/posts/25490952/comments"},"topics":[{"url":"https://www.zhihu.com/topic/20032249","id":"20032249","name":"TensorFlow"},{"url":"https://www.zhihu.com/topic/19572360","id":"19572360","name":"Python 3.x"},{"url":"https://www.zhihu.com/topic/19608617","id":"19608617","name":"科学计算"}],"href":"/api/posts/25490952","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<h2>介绍Tensorflow</h2><p>摘自维基百科的一段文字：</p><blockquote>TensorFlow是Google Brain的第二代机器学习系统，2015年11月9日，参考实现作为开源软件发布。虽然参考实现运行在单台设备，TensorFlow可以运行在多个CPU和GPU（和可选的CUDA扩展）。它运行在64位Linux或macOS桌面或服务器系统，以及在移动计算平台上，包括Android和iOS。TensorFlow的计算用有状态的数据流图表示。许多Google团队已从DistBelief迁移到TensorFlow进行研究和生产。这个库的算法源于Google需要指导称为神经网络的计算机系统，类似人类学习和推理的方法，以便派生出新的应用程序承担以前仅人类能胜任的角色和职能；TensorFlow的名字来源于这类神经网络对多维数组执行的操作。这些多维数组被称为“张量”，但这个概念并不等同于张量的数学概念。其目的是训练神经网络检测和识别模式和相互关系。<br></blockquote><p>TF只是一个科学计算工具，要想实现一些很酷的功能，就需要学习相关的知识。作为初学者，一步一个坑，一步一个脚印，走进机器学习的世界。</p><h2>安装Tensorflow</h2><p><b>在Windows上安装Tensorflow的步骤如下（参考自<a href=\"http://link.zhihu.com/?target=http%3A//blog.csdn.net/ztf312/article/details/56018891\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">windows下基于Anaconda的Tensorflow环境配置 - CS青雀的巢 - 博客频道 - CSDN.NET<i class=\"icon-external\"></i></a></b><b>）：</b></p><br><ol><li>下载并安装<a href=\"http://link.zhihu.com/?target=https%3A//repo.continuum.io/archive/Anaconda3-4.3.0.1-Windows-x86_64.exe\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Anaconda3-4.3.0.1-Windows-x86_64.exe<i class=\"icon-external\"></i></a>，管理员运行，不要勾选“添加到PATH”</li><li>安装完成后，打开开始菜单，找到<b>Anaconda/Anaconda prompt</b>，以管理员权限运行，出现命令行窗口<br></li><li>建立名为tensorflow的conda计算环境，方法是输入命令conda create -n tensorflow python=3.5，嫌时间慢可以参考<a href=\"http://link.zhihu.com/?target=http%3A//blog.csdn.net/pengjian444/article/details/51924469\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">[加速]为conda添加国内镜像 - PJZero - 博客频道 - CSDN.NET<i class=\"icon-external\"></i></a></li><li>激活tensorflow环境，输入activate tensorflow<br></li><li>安装tensorflow，pip install <a href=\"http://link.zhihu.com/?target=https%3A//storage.googleapis.com/tensorflow/windows/cpu/tensorflow-0.12.1-cp35-cp35m-win_amd64.whl\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-0.12.0-cp35-cp35m-win_amd64.whl<i class=\"icon-external\"></i></a></li></ol><h2>测试</h2><p>输入测试命令：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span></span><span class=\"c1\"># python</span>\n<span class=\"kn\">import</span> <span class=\"nn\">tensorflow</span> <span class=\"kn\">as</span> <span class=\"nn\">tf</span>\n<span class=\"n\">hello</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'Hello, Tensorflow!'</span><span class=\"p\">)</span>\n<span class=\"n\">sess</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Session</span><span class=\"p\">()</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">sess</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">hello</span><span class=\"p\">))</span>\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"mi\">22</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">sess</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">))</span>\n</code></pre></div><p>运行结果如题图所示。</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":25490952,"publishedTime":"2017-03-01T09:53:45+08:00","url":"/p/25490952","title":"【玩转科学计算】在Win上安装Tensorflow","summary":"介绍Tensorflow摘自维基百科的一段文字：TensorFlow是Google Brain的第二代机器学习系统，2015年11月9日，参考实现作为开源软件发布。虽然参考实现运行在单台设备，TensorFlow可以运行在多个CPU和GPU（和可选的CUDA扩展）。它运行在64位Linux或macOS桌面或…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0}},"commentsCount":0,"likesCount":0,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{}},"me":{},"global":{},"columns":{"learncpp":{"following":false,"canManage":false,"href":"/api/columns/learncpp","name":"从零开始构建标准库","creator":{"slug":"bajdcc"},"url":"/learncpp","slug":"learncpp","avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"FULLINFO":false}},"columnPosts":{},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true}}</textarea>

    <script src="//static.zhihu.com/hemingway/common.ac46319b23e12700340a.js"></script>
<script src="//static.zhihu.com/hemingway/app.47dccfede9fcf0800757.js"></script>
<script src="//static.zhihu.com/hemingway/raven.ccdadd4407812d1aac2f.js" async defer></script>
  </body>
</html>
