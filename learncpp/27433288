<!doctype html>
<html lang="zh-CN" class="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>【操作系统系列】Tinix - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.697838bb2e80a05fbcead68b45e858df.css" />
    <style></style>
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","wechatConfigAPI":"/api/wechat/jssdkconfig","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":"2|102d4e70|2e0dd2819b250f1c30a1cefb1f4e262b|1502542350","X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"27433288":{"title":"【操作系统系列】Tinix","author":"bajdcc","content":"<h2>前言</h2><p>最近找到一个做得很不错很不错的操作系统源码，原文在<a href=\"http://link.zhihu.com/?target=http%3A//bbs.pediy.com/thread-182967.htm\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">[原创]自己实现的一个基于x86的操作系统-『编程技术』-看雪安全论坛<i class=\"icon-external\"></i></a>，作者源码<a href=\"http://link.zhihu.com/?target=http%3A//code.taobao.org/p/tinixdev/src/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">tinixdev - / - Taocode<i class=\"icon-external\"></i></a>。原代码编译有问题，我加工了下，在<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/tinix\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/tinix<i class=\"icon-external\"></i></a>，一个命令行敲下去就能编译运行了。</p><p>关于tinix的介绍在作者文章中有，链接在<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/tinix/raw/master/%25E8%25AE%25BE%25E8%25AE%25A1%25E4%25B8%258E%25E5%25AE%259E%25E7%258E%25B0.doc\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/tinix</span><span class=\"invisible\">/raw/master/%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0.doc</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a>。</p><h2>介绍</h2><p>tinix比我做的minios长得漂亮多了，代码非常清晰，注释非常齐全！</p><p>它实现了：</p><ol><li>内存管理</li><li>文件管理（fat12，只读）</li><li>控制台管理（多控制台切换，着色）</li><li>时钟中断</li><li>多任务调度</li><li>虚拟文件系统（如cat /sys/cpuinfo）</li><li>系统调用（exec等）</li></ol><p>系统调用：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span></span><span class=\"cp\">#define\t_NR_sys_open\t0\t</span><span class=\"c1\">//s32 sys_open(u8 *);</span>\n<span class=\"cp\">#define\t_NR_sys_close \t1\t</span><span class=\"c1\">//s32 sys_close(s32);</span>\n<span class=\"cp\">#define\t_NR_sys_write\t2\t</span><span class=\"c1\">//s32 sys_write(s32 , u8* , u32 );</span>\n<span class=\"cp\">#define\t_NR_sys_read\t3\t</span><span class=\"c1\">//s32 sys_read(s32 , u8* , u32 );</span>\n<span class=\"cp\">#define\t_NR_sys_seek\t4\t</span><span class=\"c1\">//s32 sys_seek(s32 , s32 , u32 );</span>\n<span class=\"cp\">#define\t_NR_sys_wait\t5\t</span><span class=\"c1\">//s32 sys_wait(u32);</span>\n<span class=\"cp\">#define\t_NR_sys_exit\t6\t</span><span class=\"c1\">//s32 sys_exit();</span>\n<span class=\"cp\">#define\t_NR_sys_exec\t7\t</span><span class=\"c1\">//s32 sys_exec(u8 *);</span>\n<span class=\"cp\">#define\t_NR_sys_kill\t8\t</span><span class=\"c1\">//s32 sys_kill(u32);</span>\n<span class=\"cp\">#define\t_NR_sys_getpid\t9\t</span><span class=\"c1\">//s32 sys_getpid(u32);</span>\n<span class=\"cp\">#define\t_NR_sys_getticks10\t</span><span class=\"c1\">//s32 sys_getticks();</span>\n<span class=\"cp\">#define\t_NR_sys_pstat\t11\t</span><span class=\"c1\">//s32 sys_pstat(u32, void *, u32);</span>\n<span class=\"cp\">#define\t_NR_sys_opendir\t12\t</span><span class=\"c1\">//s32 sys_opendir(u8 *);</span>\n<span class=\"cp\">#define _NR_sys_readdir\t13\t</span><span class=\"c1\">//s32 sys_readdir(s32, void *, u32);</span>\n<span class=\"cp\">#define\t_NR_sys_getdate\t14\t</span><span class=\"c1\">//s32 sys_getdate(void *, u32);</span>\n<span class=\"cp\">#define\t_NR_sys_reboot\t15\t</span><span class=\"c1\">//s32 sys_reboot(u32);</span>\n<span class=\"cp\">#define _NR_sys_sleep  \t16\t</span><span class=\"c1\">//s32 sys_sleep(u32);</span>\n</code></pre></div><p>原本以作者的代码，如果要编译生成img并运行的话，比较繁琐，所以我写了点脚本，直接用mount去修改镜像。</p><p>但是有个bug，经过两天研究，我发现作者的user中生成的程序，它的段不是以4096对齐的，这就导致exec加载代码的时候出现page fault（假设段从0x80005120开始，长度2个页面大小，那么实际上经过计算，只是加载了从0x80005000-0x80006FFFF的虚页，那么我要访问0x80007000就gg了，这个问题比较坑人，经过我调试才发现）。解决方案是在ld命令行中指定“-Tdata的地址”。</p><p>总之，非常推荐用作者的代码来学习。</p><p>PS：32位Ubuntu 14.04 LTS编译通过。用64位编译会有问题，问题在于有些汇编指令不兼容。目前qemu的调试不能用，想调试的话，装好vmware和ida，参照<a href=\"http://link.zhihu.com/?target=http%3A//bbs.pediy.com/showthread.php%3Ft%3D135229\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">[翻译]使用VMWare GDB和IDA调试Windows内核<i class=\"icon-external\"></i></a>。</p>","updated":"2017-06-16T12:12:48.000Z","canComment":false,"commentPermission":"anyone","commentCount":14,"collapsedCount":0,"likeCount":63,"state":"published","isLiked":false,"slug":"27433288","isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic3.zhimg.com/v2-f342676acbeb80a4fb9c534c7d067fa6_r.png","links":{"comments":"/api/posts/27433288/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/19552686","id":"19552686","name":"操作系统"},{"url":"https://www.zhihu.com/topic/19561633","id":"19561633","name":"C（编程语言）"},{"url":"https://www.zhihu.com/topic/19593616","id":"19593616","name":"编程学习"}],"adminClosedComment":false,"titleImageSize":{"width":720,"height":400},"href":"/api/posts/27433288","excerptTitle":"","column":{"slug":"learncpp","name":"学习C++"},"tipjarState":"inactivated","annotationAction":[],"sourceUrl":"","pageCommentsCount":14,"hasPublishingDraft":false,"snapshotUrl":"","publishedTime":"2017-06-16T20:12:48+08:00","url":"/p/27433288","lastestLikers":[{"bio":"电气自动化/软件","isFollowing":false,"hash":"3f853123504a8f627a8b5719d4877bd4","uid":866021775664894000,"isOrg":false,"slug":"Electronics-1","isFollowed":false,"description":"","name":"Electronics","profileUrl":"https://www.zhihu.com/people/Electronics-1","avatar":{"id":"v2-e48c0159a9bb8630b62e779f7987a712","template":"https://pic3.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":"坐吃等死","isFollowing":false,"hash":"226d0eeb5a3d217dcd7d72279117496c","uid":565130541179920400,"isOrg":false,"slug":"yu-shu-heng-75","isFollowed":false,"description":"不想当程序员的拳手","name":"嚼口香糖的joker","profileUrl":"https://www.zhihu.com/people/yu-shu-heng-75","avatar":{"id":"c7619e9e32d6c7d6719801d3253204a9","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":null,"isFollowing":false,"hash":"edf7edd3ce715e31270092d3e2676125","uid":57297590026240,"isOrg":false,"slug":"mo-pian-22","isFollowed":false,"description":"","name":"默片","profileUrl":"https://www.zhihu.com/people/mo-pian-22","avatar":{"id":"v2-c7ed0394418b87f0d9bd4162863d3e8d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":"敲代码的","isFollowing":false,"hash":"b395f042925cf9e87fb52ea48128051e","uid":57696766132224,"isOrg":false,"slug":"yang-zhe-42-74","isFollowed":false,"description":"","name":"圣凌霄","profileUrl":"https://www.zhihu.com/people/yang-zhe-42-74","avatar":{"id":"v2-8b6e006045a6492b30ed0edb83aad082","template":"https://pic3.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},{"bio":"计算机／摄影／音乐／弯弯的~","isFollowing":false,"hash":"fc70c8803c208bda435693afefcca8c2","uid":667086490417500200,"isOrg":false,"slug":"chen-wei-hang-3-47","isFollowed":false,"description":"兴趣比较广泛，然而都没出啥样子，苦练编程中","name":"伯伦希尔de荣耀","profileUrl":"https://www.zhihu.com/people/chen-wei-hang-3-47","avatar":{"id":"v2-942b1358226486af243a35431c569d77","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false}],"summary":"前言最近找到一个做得很不错很不错的操作系统源码，原文在<a href=\"http://bbs.pediy.com/thread-182967.htm\" data-editable=\"true\" data-title=\"[原创]自己实现的一个基于x86的操作系统-『编程技术』-看雪安全论坛\" class=\"\">[原创]自己实现的一个基于x86的操作系统-『编程技术』-看雪安全论坛</a>，作者源码<a href=\"http://code.taobao.org/p/tinixdev/src/\" data-editable=\"true\" data-title=\"tinixdev - / - Taocode\" class=\"\">tinixdev - / - Taocode</a>。原代码编译有问题，我加工了下，在<a href=\"https://github.com/bajdcc/tinix\" data-editable=\"true\" data-title=\"bajdcc/tinix\" class=\"\">bajdcc/tinix</a>，一个命令行敲下去就能编译运行了。关于tinix…","reviewingCommentsCount":0,"meta":{"previous":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic2.zhimg.com/v2-eb2ae043caf58722b88ad084bccda1bd_r.png","links":{"comments":"/api/posts/27350169/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19592366","id":"19592366","name":"MFC"},{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"},{"url":"https://www.zhihu.com/topic/19554298","id":"19554298","name":"编程"}],"adminClosedComment":false,"href":"/api/posts/27350169","excerptTitle":"","author":{"bio":"专业研究野生技术","isFollowing":false,"hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"slug":"bajdcc","isFollowed":false,"description":"专业研究野生技术 https://github.com/bajdcc","name":"陈安","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},"column":{"slug":"learncpp","name":"学习C++"},"content":"<h2>前言</h2><p>vs2015竟然可以完美打开工程，哈哈可以直接生成类图了。由于内容较多，所以根据内容的重要性会安排详略。</p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/GraphEditor/releases/tag/1.0\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/Graph</span><span class=\"invisible\">Editor/releases/tag/1.0</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a><br><p>主要的内容：</p><ol><li>MFC的基本使用介绍</li><li>4种图形的绘制</li><li>图形的事件处理</li><li>撤销与恢复功能的实现</li><li>其他功能</li></ol><h2>介绍</h2><p>MFC好歹是必学课目，其实搞GUI有多种方法，可以用Qt、WPF、SWT、Electron等等，之所以要学MFC是因为C++，还因为vc6.0体积小安装快，不需要安装其他重量级的库。</p><p>那么最基础的部分都不废话了。图形编辑器肯定要有保存功能、同时编辑多个图像、各种工具栏，所以要建立多文档的工程。看类图其实东西也不多，多了一些算法，哈这些算法比较有趣。那么本工程作为MFC的练习项目，需要读者先学习MFC相关的知识。</p><h2>图形</h2><p><b><u>图形的创建</u></b></p><p>这里只有四种图形：直线、矩形、椭圆、曲线(应该为折线)，因为API支持这些多，其他图形太过复杂了。学习完多态就会知道，四种图形是继承自某一类的，这个基类就是CGraphic。</p><p>先来看看基类：</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>class CGraphic : public CObject\n{\n    DECLARE_SERIAL( CGraphic )\npublic:\n    virtual void Serialize( CArchive &amp;amp;ar );\n\npublic:\n\tCGraphic( UINT type = NONE );\n    virtual void UpdateData( GraphicMember* pSrc, BOOL bSave = TRUE );\n\n    virtual void Draw( CDC* pDC );\n    virtual void DrawSelectedEdge( CDC* pDC );\n    virtual void HitTest( CPoint&amp;amp; pt, BOOL&amp;amp; bResult );\n    virtual LPCTSTR HitSizingTest( CPoint&amp;amp; pt, BOOL&amp;amp; bResult, LONG** PtX = NULL, LONG** PtY = NULL );\n    virtual void GetRect( CRect&amp;amp; rt );\n    virtual LPCTSTR GetName() const;\n    virtual int GetPts() const;\n    virtual BOOL EnableBrush() const;\n\npublic:\n    enum _GBS { GBS_PEN = 0x1, GBS_BRUSH };\n\n    static CGraphic* CreateGraphic( GraphicMember* );\n    static void GraphicDrawSelectedEdge( CDC* pDC, CPoint&amp;amp; pt, int&amp;amp; inflate );\n    static int GetIdBySelection( _GBS SelectType, int ID );\n    static int GetSelectionById( _GBS SelectType, int sel );\n    static LPCTSTR GetPenStyleById( int ID, BOOL bConvert = TRUE );\n    static LPCTSTR GetBrushStyleById( int ID, BOOL bConvert = TRUE );\n    static void CreateGdiObjectFromId( _GBS GdiType, int ID, CGdiObject* object, int width, int color );\n    static void GraphicHitSizingTest( LONG&amp;amp; x, LONG&amp;amp; y, int inf, CPoint&amp;amp; pt, BOOL&amp;amp; bResult,\n        LONG** X = NULL, LONG** Y = NULL );\n\nprotected:\n    static LONG DotsLengthSquare( CPoint&amp;amp; p1, CPoint&amp;amp; p2 );\n    static void LineHitTest( CPoint&amp;amp; p1, CPoint&amp;amp; p2, CPoint&amp;amp; p3, BOOL&amp;amp; bResult );\n    BOOL PtInRectTest( CPoint&amp;amp; pt );\n\npublic:\n    UINT    m_DrawType;\n    BOOL    m_bHidden;\n    CString m_lpszName;\n    CPoint  m_pt1, m_pt2;\n    CTime   m_createTime, m_modifiedTime;\n};\n</code></pre></div><p>除去一些MFC相关的方法，基类的内容很多，要实现图形的绘制、选中测试、序列化，以及Get/Set方法等。</p><p>来看看它的数据成员，包括了图形的类别、是否隐藏、自定义名称、起始点和终点、创建时间和修改时间。有人会说那折线是多个点的，两个点不肯存啊，不是的，这两个点是四种图形都会包括的，所以索性放基类中了。</p><p>工厂方法：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">CGraphic</span><span class=\"o\">::</span><span class=\"n\">CreateGraphic</span><span class=\"p\">(</span> <span class=\"n\">GraphicMember</span><span class=\"o\">*</span> <span class=\"n\">pSrc</span> <span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"n\">pSrc</span><span class=\"p\">);</span>\n    <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pRet</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"k\">switch</span> <span class=\"p\">(</span><span class=\"n\">pSrc</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">m_DrawType</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n    <span class=\"k\">case</span> <span class=\"nl\">LINE</span><span class=\"p\">:</span>          <span class=\"n\">pRet</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CLine</span><span class=\"p\">;</span>       <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"k\">case</span> <span class=\"nl\">RECTANGLE</span><span class=\"p\">:</span>     <span class=\"n\">pRet</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CRectangle</span><span class=\"p\">;</span>  <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"k\">case</span> <span class=\"nl\">ELLIPSE</span><span class=\"p\">:</span>       <span class=\"n\">pRet</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CEllipse</span><span class=\"p\">;</span>    <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"k\">case</span> <span class=\"nl\">CURVE</span><span class=\"p\">:</span>         <span class=\"n\">pRet</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CCurve</span><span class=\"p\">;</span>      <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"k\">return</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">pRet</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">UpdateData</span><span class=\"p\">(</span><span class=\"n\">pSrc</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">pRet</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>其实不复杂，就是根据名称创建相应对象而已。</p><p><u><b>图形的选中</b></u></p><p>鼠标可以选中图形并拖动它，改变它大小时，光标会变成相应的形态，这怎么实现呢？其实很多游戏都有选中图形如3D对象的功能，如MC、看门狗等，当然在2D世界中，问题相应简单的多，我们这里用最笨的方法，就是一个个找。。</p><p>在正式GUI中，控件间有父子和兄弟关系，这样的话，就是在一棵树中查找，效率相对高点，而本项目中所有图形是兄弟关系，所以只能一个个遍历啦~</p><p>那么线段的选中是怎样实现的？直线没有宽度啊。。这个问题也困扰了我，不过这里不要求精确，假设线段的两端点为AB，当然鼠标所在位置为C，只要算AC+BC跟AB很接近就可以了。</p><p>椭圆的选中呢？很简单，因为这里不支持旋转，所以椭圆是方正的，只要根据椭圆的二次解析式方程就可以判断，就点代进去，然后算大于0还是小于0。这里有个注意点：<b>浮点数的大小判断不能用等号，要用不等式区间去判断。</b></p><p>折线的选中就是连着判断所有线段。</p><p><b><u>图形的调整与拖动</u></b><br></p><p>图形的调整大小：首先要选中图形，然后出现选中轮廓提示，再移动到轮廓上等光标改变，就可以改变图形的大小。这部分较简单。</p><p>图形的拖动：监听几个事件，OnLButtonDown/OnLButtonUp/OnMouseMove，如当前选中了哪个图形就要将它记录下来，万一要调整图形的大小了，就可以马上将记录下来的图形进行修改。这部分比较繁琐（代码比较乱），建议自己先建立Win32程序练习或参考更简单的代码。这部分就是个状态机，我也是debug了很久才把代码完善好的，这里也讲不明白。</p><p><b><u>图形的绘制</u></b></p><p>都是调的API：Ellipse/Rectangle/LineTo。</p><p>双缓存：假如直接在屏幕DC上操作，那么每画一次，就得更新一次界面，所以会闪屏。如果在缓冲上操作，然后BitBlt给屏幕，就可以尽量避免闪屏。</p><p><b><u>图形的保存</u></b></p><p>工程的序列化不用多说，CArchive去弄。保存成bmp位图需要了解下bmp的格式，然后用DIB相关的API将DC的图像数据拎出来，存到文件里。</p><br><h2>历史记录的实现</h2><p>这一部分是我认为比较有趣的部分，也是实现较难的部分，大家日常用word它就有撤销的功能，像PS有历史记录可供恢复，那么这一功能实现起来还真不是那么简单。</p><p>看代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">class</span> <span class=\"nc\">CGraphicLog</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">CGraphicLog</span><span class=\"p\">(</span> <span class=\"n\">CObArray</span><span class=\"o\">*</span> <span class=\"n\">arr</span> <span class=\"p\">);</span>\n    <span class=\"o\">~</span><span class=\"n\">CGraphicLog</span><span class=\"p\">();</span>\n\n    <span class=\"k\">enum</span> <span class=\"p\">{</span> <span class=\"n\">MAX_SAVE</span> <span class=\"o\">=</span> <span class=\"n\">LOG_MAX_SAVE</span> <span class=\"p\">};</span>\n    <span class=\"k\">enum</span> <span class=\"n\">GOS</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">GOS_NONE</span><span class=\"p\">,</span>\n        <span class=\"n\">GOS_ADD</span><span class=\"p\">,</span>\n        <span class=\"n\">GOS_DELETE</span><span class=\"p\">,</span>\n        <span class=\"n\">GOS_UPDATE</span><span class=\"p\">,</span>\n    <span class=\"p\">};</span>\n\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">void</span> <span class=\"n\">Clear</span><span class=\"p\">();</span>\n    <span class=\"n\">BOOL</span> <span class=\"nf\">CanUndo</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n    <span class=\"n\">BOOL</span> <span class=\"nf\">CanDo</span><span class=\"p\">()</span> <span class=\"k\">const</span><span class=\"p\">;</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">Undo</span><span class=\"p\">();</span> <span class=\"c1\">// 撤消纪录</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">Done</span><span class=\"p\">();</span> <span class=\"c1\">// 恢复纪录</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">Operator</span><span class=\"p\">(</span> <span class=\"n\">GOS</span><span class=\"p\">,</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">BOOL</span> <span class=\"n\">bClear</span> <span class=\"o\">=</span> <span class=\"n\">TRUE</span><span class=\"p\">);</span> <span class=\"c1\">// 添加操作纪录</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">DoneOper</span><span class=\"p\">(</span> <span class=\"n\">GOS</span><span class=\"p\">,</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"p\">);</span> <span class=\"c1\">// 添加恢复纪录</span>\n\n    <span class=\"n\">BOOL</span> <span class=\"nf\">Add</span><span class=\"p\">(</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pOb</span> <span class=\"p\">);</span> <span class=\"c1\">// 添加数据</span>\n    <span class=\"n\">BOOL</span> <span class=\"nf\">Add</span><span class=\"p\">(</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pOb</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">ID</span> <span class=\"p\">);</span> <span class=\"c1\">// 添加数据</span>\n\n<span class=\"k\">protected</span><span class=\"o\">:</span>\n    <span class=\"kt\">void</span> <span class=\"n\">ClearDone</span><span class=\"p\">();</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">ClearUndo</span><span class=\"p\">();</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">ClearArray</span><span class=\"p\">();</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">Delete</span><span class=\"p\">(</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pOb</span> <span class=\"p\">);</span>\n    <span class=\"n\">BOOL</span> <span class=\"nf\">AddRef</span><span class=\"p\">(</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pOb</span> <span class=\"p\">);</span>\n\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">GraphicOperation</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">GOS</span>         <span class=\"n\">oper</span><span class=\"p\">;</span>\n        <span class=\"n\">CGraphic</span><span class=\"o\">*</span>   <span class=\"n\">pGraphic</span><span class=\"p\">;</span>\n        <span class=\"kt\">int</span>         <span class=\"n\">index</span><span class=\"p\">;</span>\n\n        <span class=\"n\">CString</span> <span class=\"nf\">Trace</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span> <span class=\"n\">_GO</span> <span class=\"p\">;</span>\n\n    <span class=\"n\">CList</span><span class=\"o\">&amp;lt;</span><span class=\"n\">_GO</span><span class=\"p\">,</span> <span class=\"n\">_GO</span><span class=\"o\">&amp;amp;&amp;gt;</span>    <span class=\"n\">m_listDone</span><span class=\"p\">;</span>\n    <span class=\"n\">CList</span><span class=\"o\">&amp;lt;</span><span class=\"n\">_GO</span><span class=\"p\">,</span> <span class=\"n\">_GO</span><span class=\"o\">&amp;amp;&amp;gt;</span>    <span class=\"n\">m_listUndo</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span>                 <span class=\"n\">m_dones</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span>                 <span class=\"n\">m_undos</span><span class=\"p\">;</span>\n    <span class=\"n\">CObArray</span><span class=\"o\">*</span>           <span class=\"n\">m_parr</span><span class=\"p\">;</span>\n    <span class=\"n\">CMap</span><span class=\"o\">&amp;lt;</span><span class=\"n\">CGraphic</span><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"n\">CGraphic</span><span class=\"o\">*&amp;amp;</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">&amp;amp;&amp;gt;</span> <span class=\"n\">m_refs</span><span class=\"p\">;</span> <span class=\"c1\">// 引用表</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>几大问题：</p><ul><li>撤销能不能真正删除数据？不能，否则如何恢复</li><li>一会恢复一会撤销，对象就是动态创建的，如何管理？引用计数加链表</li><li>撤销和恢复互为逆操作吗？是</li><li>只是将对象放进链表里吗？不是，因为对象一旦被修改，就要记录修改前的副本</li></ul><p>因此，操作有三种：添加、删除、更改，但组合起来不那么简单。</p><p>最核心函数：void Operator( GOS, CGraphic*, int, BOOL bClear = TRUE); // 添加操作纪录</p><p><b><u>添加操作记录</u></b><br></p><p>共有两组链表：撤销记录和恢复记录，记录着操作的类型/对象指针/对象ID。数据在CObArray*m_parr中。增加引用AddRef，去引用Delete，添加Add。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"kt\">void</span> <span class=\"n\">CGraphicLog</span><span class=\"o\">::</span><span class=\"n\">Operator</span><span class=\"p\">(</span> <span class=\"n\">GOS</span> <span class=\"n\">oper</span><span class=\"p\">,</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">BOOL</span> <span class=\"n\">bClear</span> <span class=\"cm\">/*= TRUE*/</span> <span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">ASSERT_VALID</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">// 每次操作之后，记忆的恢复操作应该全部清除</span>\n    <span class=\"c1\">// 使用者操作时，参数bClear为真</span>\n    <span class=\"c1\">// 撤消操作时，bClear为假</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">bClear</span><span class=\"p\">)</span> <span class=\"n\">ClearDone</span><span class=\"p\">();</span>\n    \n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">bClear</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"c1\">// * * * 这里会修改引用计数和操作对象数组 * * *</span>\n\n        <span class=\"c1\">// 凡是将对象从m_obArray（*m_parr）移出至（listUndo），那么不增加引用</span>\n        <span class=\"k\">switch</span> <span class=\"p\">(</span><span class=\"n\">oper</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n        <span class=\"k\">case</span> <span class=\"nl\">GOS_ADD</span><span class=\"p\">:</span>\n            <span class=\"c1\">// 使用本类的Add(CGraphic*)添加对象并初始化引用计数</span>\n            <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">Add</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">));</span>\n            <span class=\"c1\">// 因为撤消列表里要保存添加操作，所以引用计数加一</span>\n            <span class=\"n\">AddRef</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n            <span class=\"c1\">// 这样引用计数为二</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"k\">case</span> <span class=\"nl\">GOS_DELETE</span><span class=\"p\">:</span>\n            <span class=\"c1\">// 将其从原数组中移除（不是删除）</span>\n            <span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">RemoveAt</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">);</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"k\">case</span> <span class=\"nl\">GOS_UPDATE</span><span class=\"p\">:</span>\n            <span class=\"c1\">// 更改操作，这时要保存原对象（更改前的）</span>\n            <span class=\"c1\">// 但是修改后的对象是最新创建的，没有引用计数</span>\n            <span class=\"c1\">// 所以还得初始化引用计数</span>\n            <span class=\"c1\">// 此时p为新建备份</span>\n            <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">AddRef</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">));</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"s\">\"Operation fault!\"</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m_undos</span> <span class=\"o\">==</span> <span class=\"n\">MAX_SAVE</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"c1\">// 如果撤消列表已经满，自动删除列尾</span>\n        <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">m_listUndo</span><span class=\"p\">.</span><span class=\"n\">IsEmpty</span><span class=\"p\">());</span>\n        <span class=\"n\">Delete</span><span class=\"p\">(</span><span class=\"n\">m_listUndo</span><span class=\"p\">.</span><span class=\"n\">GetTail</span><span class=\"p\">().</span><span class=\"n\">pGraphic</span><span class=\"p\">);</span>\n        <span class=\"n\">m_listUndo</span><span class=\"p\">.</span><span class=\"n\">RemoveTail</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">m_undos</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">_GO</span> <span class=\"n\">go</span><span class=\"p\">;</span>\n    <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">index</span><span class=\"p\">;</span>\n    <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">oper</span> <span class=\"o\">=</span> <span class=\"n\">oper</span><span class=\"p\">;</span>\n    <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n    <span class=\"n\">TRACE</span><span class=\"p\">(</span><span class=\"s\">\"LOG OPER %d %s / UN: %d DN: %d REF: %d</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span> <span class=\"n\">bClear</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">Trace</span><span class=\"p\">(),</span> <span class=\"n\">m_undos</span><span class=\"p\">,</span> <span class=\"n\">m_dones</span><span class=\"p\">,</span> <span class=\"n\">m_refs</span><span class=\"p\">[</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">]);</span>\n\n    <span class=\"c1\">// 添加撤消记录</span>\n    <span class=\"n\">m_listUndo</span><span class=\"p\">.</span><span class=\"n\">AddHead</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><u><b>撤销操作</b></u></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"kt\">void</span> <span class=\"n\">CGraphicLog</span><span class=\"o\">::</span><span class=\"n\">Undo</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// * * * 这里会修改引用计数和操作对象数组 * * *</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m_undos</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">TRACE</span><span class=\"p\">(</span><span class=\"s\">\"LOG UNDO ------</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\n    <span class=\"n\">m_undos</span><span class=\"o\">--</span><span class=\"p\">;</span>\n    <span class=\"n\">_GO</span> <span class=\"n\">go</span> <span class=\"o\">=</span> <span class=\"n\">m_listUndo</span><span class=\"p\">.</span><span class=\"n\">GetHead</span><span class=\"p\">();</span>\n    <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pOb</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"k\">switch</span> <span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">oper</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n    <span class=\"k\">case</span> <span class=\"nl\">GOS_ADD</span><span class=\"p\">:</span>\n        <span class=\"c1\">// 撤消添加的，所以为删除操作</span>\n        <span class=\"c1\">// 将其从图像数组中移除，引用计数减一</span>\n        <span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">RemoveAt</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">);</span>\n\n        <span class=\"c1\">// 撤消列表中本操作记录删除（用完了删除），引用计数减一</span>\n        <span class=\"c1\">// 这时要保存恢复操作，要恢复撤消添加</span>\n        <span class=\"c1\">// 所以在listDone里要保存添加操作，引用计数加一        </span>\n        <span class=\"c1\">// 总之引用计数减一</span>\n        <span class=\"n\">Delete</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">);</span>\n        <span class=\"n\">DoneOper</span><span class=\"p\">(</span><span class=\"n\">GOS_ADD</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">);</span>\n        <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"k\">case</span> <span class=\"nl\">GOS_DELETE</span><span class=\"p\">:</span>\n        <span class=\"c1\">// 撤消删除的，所以为添加操作</span>\n        <span class=\"c1\">// 将其移动到图像数组中相应位置，引用计数不变</span>\n        <span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">InsertAt</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">);</span>\n\n        <span class=\"c1\">// 撤消之前的对象要保存（移动）到恢复列表中，引用计数不变</span>\n        <span class=\"c1\">// 对象恢复到原始数组，引用计数加一</span>\n        <span class=\"n\">AddRef</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">);</span>\n        <span class=\"n\">DoneOper</span><span class=\"p\">(</span><span class=\"n\">GOS_DELETE</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">);</span>\n        <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"k\">case</span> <span class=\"nl\">GOS_UPDATE</span><span class=\"p\">:</span>\n        <span class=\"c1\">// 撤消更改，现数组中对象要恢复成撤消之前的</span>\n        <span class=\"n\">pOb</span> <span class=\"o\">=</span> <span class=\"n\">Convert_To_Graphic</span><span class=\"p\">(</span><span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">GetAt</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">));</span>\n        <span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">ElementAt</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">;</span>\n\n        <span class=\"c1\">// 所以原对象被保存（移动）进恢复列表，引用计数不变</span>\n        <span class=\"c1\">// 新对象从撤消操作记录列表中移动进对象数组，引用计数不变</span>\n        <span class=\"c1\">// 总之引用计数不变</span>\n        <span class=\"n\">DoneOper</span><span class=\"p\">(</span><span class=\"n\">GOS_UPDATE</span><span class=\"p\">,</span> <span class=\"n\">pOb</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">);</span>\n        <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"s\">\"operation fault!\"</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">m_listUndo</span><span class=\"p\">.</span><span class=\"n\">RemoveHead</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><u><b>恢复操作</b></u><br></p><br><br><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"kt\">void</span> <span class=\"n\">CGraphicLog</span><span class=\"o\">::</span><span class=\"n\">Done</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// * * * 这里会修改引用计数和操作对象数组 * * *</span>\n\n    <span class=\"c1\">// 恢复操作遵循oper指令</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m_dones</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">TRACE</span><span class=\"p\">(</span><span class=\"s\">\"LOG DONE ------</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\n    <span class=\"n\">m_dones</span><span class=\"o\">--</span><span class=\"p\">;</span>\n    <span class=\"n\">_GO</span> <span class=\"n\">go</span> <span class=\"o\">=</span> <span class=\"n\">m_listDone</span><span class=\"p\">.</span><span class=\"n\">GetHead</span><span class=\"p\">();</span>\n    <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pOb</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"k\">switch</span> <span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">oper</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n    <span class=\"k\">case</span> <span class=\"nl\">GOS_ADD</span><span class=\"p\">:</span>\n        <span class=\"c1\">// 添加操作</span>\n        <span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">InsertAt</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">);</span>\n        \n        <span class=\"c1\">// 从保存列表移动至目标数组，引用计数不变</span>\n        <span class=\"c1\">// 添加撤消操作，引用计数加一</span>\n        <span class=\"c1\">// 总之引用计数加一</span>\n        <span class=\"n\">AddRef</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">);</span>\n        <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">GOS_ADD</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">FALSE</span><span class=\"p\">);</span>\n        <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"k\">case</span> <span class=\"nl\">GOS_DELETE</span><span class=\"p\">:</span>\n        <span class=\"c1\">// 删除操作</span>\n        <span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">RemoveAt</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">);</span>\n\n        <span class=\"c1\">// 原数组中其被删除，恢复列表删除，引用计数减二</span>\n        <span class=\"c1\">// 唯一保存在撤消列表中，引用计数加一</span>\n        <span class=\"c1\">// 总之引用计数减一</span>\n        <span class=\"n\">Delete</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">);</span>\n        <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">GOS_DELETE</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">FALSE</span><span class=\"p\">);</span>\n        <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"k\">case</span> <span class=\"nl\">GOS_UPDATE</span><span class=\"p\">:</span>\n        <span class=\"c1\">// 更改操作</span>\n        <span class=\"n\">pOb</span> <span class=\"o\">=</span> <span class=\"n\">Convert_To_Graphic</span><span class=\"p\">(</span><span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">GetAt</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">));</span>\n        <span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">ElementAt</span><span class=\"p\">(</span><span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">pGraphic</span><span class=\"p\">;</span>\n\n        <span class=\"c1\">// go.pGraphic 恢复列表-&amp;gt;目标数组，引用计数不变</span>\n        <span class=\"c1\">// pOb 目标数组-&amp;gt;恢复列表，引用计数不变</span>\n        <span class=\"n\">Operator</span><span class=\"p\">(</span><span class=\"n\">GOS_UPDATE</span><span class=\"p\">,</span> <span class=\"n\">pOb</span><span class=\"p\">,</span> <span class=\"n\">go</span><span class=\"p\">.</span><span class=\"n\">index</span><span class=\"p\">,</span> <span class=\"n\">FALSE</span><span class=\"p\">);</span>\n        <span class=\"k\">break</span><span class=\"p\">;</span>\n    <span class=\"k\">default</span><span class=\"o\">:</span> <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"s\">\"operation fault!\"</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">m_listDone</span><span class=\"p\">.</span><span class=\"n\">RemoveHead</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><b><u>引用计数</u></b></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"kt\">void</span> <span class=\"n\">CGraphicLog</span><span class=\"o\">::</span><span class=\"n\">Delete</span><span class=\"p\">(</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pOb</span> <span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 删除操作，当且仅当引用计数为1时（无其他引用）删除</span>\n    <span class=\"n\">ASSERT_VALID</span><span class=\"p\">(</span><span class=\"n\">pOb</span><span class=\"p\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">ref</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m_refs</span><span class=\"p\">.</span><span class=\"n\">Lookup</span><span class=\"p\">(</span><span class=\"n\">pOb</span><span class=\"p\">,</span> <span class=\"n\">ref</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"n\">ref</span> <span class=\"o\">&amp;gt;=</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ref</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n\t\t\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&amp;lt;</span> <span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">GetSize</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n\t\t\t<span class=\"p\">{</span>\n\t\t\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">GetAt</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"n\">CObject</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">pOb</span><span class=\"p\">)</span>\n\t\t\t\t<span class=\"p\">{</span>\n\t\t\t\t\t<span class=\"n\">TRACE</span><span class=\"p\">(</span><span class=\"s\">\"Graphic Delete ID: %d, ADDR: %p In Main Array</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">pOb</span><span class=\"p\">);</span>\n\t\t\t\t\t<span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">RemoveAt</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n\t\t\t\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\n\t\t\t\t<span class=\"p\">}</span>\n\t\t\t<span class=\"p\">}</span>\n            <span class=\"k\">delete</span> <span class=\"n\">pOb</span><span class=\"p\">;</span>\n            <span class=\"n\">m_refs</span><span class=\"p\">.</span><span class=\"n\">RemoveKey</span><span class=\"p\">(</span><span class=\"n\">pOb</span><span class=\"p\">);</span>\n            <span class=\"k\">return</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">m_refs</span><span class=\"p\">[</span><span class=\"n\">pOb</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ref</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"s\">\"Object not found!\"</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">BOOL</span> <span class=\"n\">CGraphicLog</span><span class=\"o\">::</span><span class=\"n\">AddRef</span><span class=\"p\">(</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pOb</span> <span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 增加引用计数</span>\n    <span class=\"n\">ASSERT_VALID</span><span class=\"p\">(</span><span class=\"n\">pOb</span><span class=\"p\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">ref</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m_refs</span><span class=\"p\">.</span><span class=\"n\">Lookup</span><span class=\"p\">(</span><span class=\"n\">pOb</span><span class=\"p\">,</span> <span class=\"n\">ref</span><span class=\"p\">))</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">m_refs</span><span class=\"p\">[</span><span class=\"n\">pOb</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">ref</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">TRUE</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">m_refs</span><span class=\"p\">[</span><span class=\"n\">pOb</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">FALSE</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 假如是初始化引用计数，那么返回FALSE</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">BOOL</span> <span class=\"n\">CGraphicLog</span><span class=\"o\">::</span><span class=\"n\">Add</span><span class=\"p\">(</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pOb</span> <span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 新建对象后的必须操作</span>\n    <span class=\"c1\">// 向数组中新增对象</span>\n    <span class=\"c1\">// 初始化引用计数</span>\n    <span class=\"n\">ASSERT_VALID</span><span class=\"p\">(</span><span class=\"n\">pOb</span><span class=\"p\">);</span>\n    <span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">Add</span><span class=\"p\">(</span><span class=\"n\">pOb</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"nf\">AddRef</span><span class=\"p\">(</span><span class=\"n\">pOb</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">BOOL</span> <span class=\"n\">CGraphicLog</span><span class=\"o\">::</span><span class=\"n\">Add</span><span class=\"p\">(</span> <span class=\"n\">CGraphic</span><span class=\"o\">*</span> <span class=\"n\">pOb</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">ID</span> <span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 只在序列化读取时，将所有图形的引用计数初始化为1</span>\n    <span class=\"c1\">// m_parr之前必须调用SetSize（这样快）</span>\n    <span class=\"n\">ASSERT_VALID</span><span class=\"p\">(</span><span class=\"n\">pOb</span><span class=\"p\">);</span>\n    <span class=\"n\">m_parr</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">ElementAt</span><span class=\"p\">(</span><span class=\"n\">ID</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">pOb</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"nf\">AddRef</span><span class=\"p\">(</span><span class=\"n\">pOb</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><u>由于代码中有注释（都是为了debug才理清思路写），所以直接上代码了，自己现在也讲不清楚，我想应该还有更好的实现。上述代码都是在引用计数上大作文章，一个计数写错就会导致bug。。</u></p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":27350169,"publishedTime":"2017-06-12T10:07:19+08:00","url":"/p/27350169","title":"【MFC】图形编辑器（二）","summary":"前言vs2015竟然可以完美打开工程，哈哈可以直接生成类图了。由于内容较多，所以根据内容的重要性会安排详略。<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/GraphEditor/releases/tag/1.0\" data-editable=\"true\" data-title=\"https://github.com/bajdcc/GraphEditor/releases/tag/1.0\" class=\"\">https://github.com/bajdcc/GraphEditor/releases/tag/1.0</a> 主要的内容：MFC的基本使用介绍4种图形的绘制图形的事件处理撤销与恢复功能的实现其他…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":4,"likesCount":3},"next":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic1.zhimg.com/v2-b60dd44ba1e2c80515dc9bb0110fd894_r.png","links":{"comments":"/api/posts/27915133/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19584970","id":"19584970","name":"C++"},{"url":"https://www.zhihu.com/topic/19636864","id":"19636864","name":"NOI"},{"url":"https://www.zhihu.com/topic/19625716","id":"19625716","name":"算法与数据结构"}],"adminClosedComment":false,"href":"/api/posts/27915133","excerptTitle":"","author":{"bio":"专业研究野生技术","isFollowing":false,"hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"slug":"bajdcc","isFollowed":false,"description":"专业研究野生技术 https://github.com/bajdcc","name":"陈安","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},"content":"<h2>题目</h2><p>链接：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/ACM/blob/master/noi/9272/%25E5%2581%25B6%25E6%2595%25B0%25E4%25B8%25AA%25E4%25B8%2589.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/ACM<i class=\"icon-external\"></i></a></p><h2>描述</h2><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>在所有的N位数中，有多少个数中有偶数个数字3？结果模12345。(1&amp;lt;=N&amp;lt;=10000)\n</code></pre></div><h2>样例输入</h2><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>2\n</code></pre></div><h2>样例输出</h2><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>73\n</code></pre></div><h2>方法一：穷举</h2><p>评价：<b>最简单又是效率最低的方法。</b></p><p>缺陷：N很大时，用来遍历的i用long long就放不下了，gg。但是首先，你要耐心等到long long溢出。耗时就不算了，太慢。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"cp\">#include</span> <span class=\"cpf\">&amp;lt;iostream&amp;gt;</span><span class=\"cp\"></span>\n\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#define LL long long</span>\n<span class=\"cp\">#define NUM 3</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t<span class=\"n\">LL</span> <span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">i</span><span class=\"p\">,</span><span class=\"n\">j</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"n\">count</span><span class=\"p\">;</span>\n\t<span class=\"n\">cin</span><span class=\"o\">&amp;gt;&amp;gt;</span><span class=\"n\">n</span><span class=\"p\">;</span>\n\t<span class=\"k\">for</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"n\">m</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"n\">i</span><span class=\"o\">&amp;lt;</span><span class=\"n\">n</span><span class=\"p\">;</span><span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"n\">m</span><span class=\"o\">*=</span><span class=\"mi\">10</span><span class=\"p\">;</span> <span class=\"c1\">// 求N位数上界 </span>\n\t<span class=\"k\">for</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">m</span><span class=\"o\">/</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"n\">count</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"n\">i</span><span class=\"o\">&amp;lt;</span><span class=\"n\">m</span><span class=\"p\">;</span><span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 从10..000 ~ 99..999</span>\n\t\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">j</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"o\">=</span><span class=\"n\">i</span><span class=\"p\">;</span><span class=\"n\">t</span><span class=\"p\">;</span><span class=\"n\">t</span><span class=\"o\">/=</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"c1\">// 取每一位 </span>\n\t\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">%</span><span class=\"mi\">10</span><span class=\"o\">==</span><span class=\"n\">NUM</span><span class=\"p\">)</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">;</span> <span class=\"c1\">// 如果是NUM计数j加一 </span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">j</span><span class=\"o\">%</span><span class=\"mi\">2</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t    <span class=\"n\">count</span><span class=\"o\">++</span><span class=\"p\">;</span> <span class=\"c1\">// 偶数个NUM计数count加一</span>\n\t\t    <span class=\"n\">count</span><span class=\"o\">%=</span><span class=\"mi\">12345</span><span class=\"p\">;</span>\n\t\t<span class=\"p\">}</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"n\">cout</span><span class=\"o\">&amp;lt;&amp;lt;</span><span class=\"n\">count</span><span class=\"p\">;</span>\n\t<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>方法二：递推</h2><p>穷举法有着天生的缺陷：遍历的i范围有限，除非用高精度才能避免。</p><p>进一步思考，将题目改为“有多少个数中有偶数个4”，结果记为N4。那么我想N4应该跟N3是一样的，对称性嘛。证明：对应每个数中有偶数个3的数，我都可以找到相应的数，只要将原数中的3跟4对调下即可，比如133242，调下变144232，欧了。当然了，想到这个结论然并卵，我们目前只证得N1~N9是相等的，理所应当，假如知道了N1~N9的和，那只要平均下就能得出结果。然而还是手足无措，那就用递推来想想。</p><p>假如目前有数6XXXXX，以6开头的符合条件的数有多少呢？好吧，无视6，得出f(6XXXXX)=f(XXXXX)，因为6根本没必要算进去嘛，欧了！我们发现一个重要结论：有些子问题是重复的！所以无脑穷举法太慢的原因就是计算了重复的子问题。好吧，现在来找找哪些是重复的子问题。</p><p>设下函数f(n)和g(n)，n是位数，f表示有偶数个3的总数，g表示有奇数个3的总数。从一位数开始，0不算，f(1)=8,g(1)=1，只要看有没有3就行了。</p><p>现在是N位数XY，想一想，如果Y有奇数个3同时X有奇数个3，那么f函数欧了；如果Y有偶数个3同时X有偶数个3，那么f函数欧了。如果Y有奇数个3同时X有偶数个3，那么g函数欧了；如果Y有偶数个3同时X有奇数个3，那么g函数欧了。最后，我们将X定为最高一位，Y定为后N-1位，用来递推，这样的话X就不能是0，这就决定了f(1)=8而不是9，说到底，0还是要考虑到，不过是作为后n-1位了，体现在下面推导式右边的乘数9上。</p><p>有点思路了，现在把f和g的推导式写出来。边界：f(1)=8,g(1)=1。如果第n位是3，那么加上g(n-1)；如果第n位不是3，那么加上9*f(n-1)，因为不是3的话有9种可能，乘法原理。</p><p>整理下：</p><ul><li><b>f(1)=8,g(1)=1</b></li><li><b>f(n)=g(n-1)+9*f(n-1)</b></li><li><b>g(n)=f(n-1)+9*g(n-1)</b></li></ul><p>书写代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"cp\">#include</span> <span class=\"cpf\">&amp;lt;iostream&amp;gt;</span><span class=\"cp\"></span>\n\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">);</span>\n<span class=\"kt\">int</span> <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"o\">==</span><span class=\"mi\">1</span><span class=\"o\">?</span><span class=\"mi\">8</span><span class=\"o\">:</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">9</span><span class=\"o\">*</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">%</span><span class=\"mi\">12345</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">g</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"o\">==</span><span class=\"mi\">1</span><span class=\"o\">?</span><span class=\"mi\">1</span><span class=\"o\">:</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">9</span><span class=\"o\">*</span><span class=\"n\">g</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">%</span><span class=\"mi\">12345</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n\t<span class=\"n\">cin</span><span class=\"o\">&amp;gt;&amp;gt;</span><span class=\"n\">n</span><span class=\"p\">;</span>\n\t<span class=\"n\">cout</span><span class=\"o\">&amp;lt;&amp;lt;</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span>\n\t<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>运行速度明显快多了。</p><h2>方法三：动态规划</h2><p>方法二还是需要改进，f和g函数有重复的递归调用，当然可以用<b>记忆化</b>去搞定。这里既然有了递推式，<b>状态转移方程</b>就呼之欲出了，方法二中已写出。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"cp\">#include</span> <span class=\"cpf\">&amp;lt;iostream&amp;gt;</span><span class=\"cp\"></span>\n\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">f</span><span class=\"p\">[</span><span class=\"mi\">10002</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">];</span><span class=\"c1\">//f[][0]=偶数个3，f[][1]=奇数个3 </span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n\t<span class=\"n\">cin</span><span class=\"o\">&amp;gt;&amp;gt;</span><span class=\"n\">n</span><span class=\"p\">;</span>\n\t<span class=\"n\">f</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"mi\">8</span><span class=\"p\">,</span><span class=\"n\">f</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n\t<span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">;</span><span class=\"n\">i</span><span class=\"o\">&amp;lt;=</span><span class=\"n\">n</span><span class=\"p\">;</span><span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t<span class=\"n\">f</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"o\">*</span><span class=\"n\">f</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"n\">f</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">])</span><span class=\"o\">%</span><span class=\"mi\">12345</span><span class=\"p\">;</span>\n\t\t<span class=\"n\">f</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"mi\">9</span><span class=\"o\">*</span><span class=\"n\">f</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">])</span><span class=\"o\">%</span><span class=\"mi\">12345</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"n\">cout</span><span class=\"o\">&amp;lt;&amp;lt;</span><span class=\"n\">f</span><span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n\t<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>方法四：打表法</h2><p>略。</p><h2>方法五：公式法</h2><p>没想到吧，这也能用公式做！Fibonacci数列也是有通项公式的，但是要怎么求呢？（当然参照书上的）</p><p><br></p><img src=\"http://pic3.zhimg.com/v2-f95a8addc9a192fb3a613e7daa03d402_b.png\" data-rawwidth=\"1654\" data-rawheight=\"2598\" class=\"origin_image zh-lightbox-thumb\" width=\"1654\" data-original=\"http://pic3.zhimg.com/v2-f95a8addc9a192fb3a613e7daa03d402_r.png\"><p>书写代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"cp\">#include</span> <span class=\"cpf\">&amp;lt;iostream&amp;gt;</span><span class=\"cp\"></span>\n\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#define MOD 12345</span>\n\n<span class=\"c1\">// 快速幂取模 </span>\n<span class=\"kt\">int</span> <span class=\"nf\">fast</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">mod</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">aa</span><span class=\"o\">=</span><span class=\"n\">a</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    \t<span class=\"c1\">//取N的二进制位，是一则乘上相应幂并求余 </span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">N</span> <span class=\"o\">&amp;amp;</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">*</span> <span class=\"n\">aa</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">mod</span><span class=\"p\">;</span>\n        <span class=\"n\">N</span> <span class=\"o\">&amp;gt;&amp;gt;=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"n\">aa</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">aa</span> <span class=\"o\">*</span> <span class=\"n\">aa</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">mod</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span><span class=\"n\">r</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 快速幂取模（2为底） </span>\n<span class=\"kt\">int</span> <span class=\"nf\">fast2</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">mod</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t<span class=\"k\">static</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">a</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1LL</span><span class=\"o\">&amp;lt;&amp;lt;</span><span class=\"mi\">62</span><span class=\"p\">)</span><span class=\"o\">%</span><span class=\"n\">mod</span><span class=\"p\">;</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"o\">=</span><span class=\"n\">N</span><span class=\"o\">%</span><span class=\"mi\">62</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"o\">=</span><span class=\"n\">N</span><span class=\"o\">/</span><span class=\"mi\">62</span><span class=\"p\">;</span><span class=\"c1\">// 2^N=2^s*a^t</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">1LL</span><span class=\"o\">&amp;lt;&amp;lt;</span><span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"n\">mod</span><span class=\"p\">;</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">&amp;gt;</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\t\t<span class=\"n\">r</span> <span class=\"o\">*=</span> <span class=\"n\">fast</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"n\">mod</span><span class=\"p\">);</span><span class=\"c1\">// 2^s*a^t % mod</span>\n\t\t<span class=\"n\">r</span> <span class=\"o\">%=</span> <span class=\"n\">mod</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span><span class=\"n\">r</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">;</span>\n\t<span class=\"n\">cin</span><span class=\"o\">&amp;gt;&amp;gt;</span><span class=\"n\">n</span><span class=\"p\">;</span>\n\t<span class=\"c1\">//化简：</span>\n\t<span class=\"c1\">// an=1/2*{7*2^(3n-3)+9*2^(n-1)*5^(n-1)}</span>\n\t<span class=\"c1\">// an=2^(n-2)*{9*5^(n-1)+7*2^(2n-2)} </span>\n\t<span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">=</span><span class=\"n\">fast2</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"n\">MOD</span><span class=\"p\">);</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">=</span><span class=\"n\">a</span><span class=\"o\">&amp;lt;&amp;lt;</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">ans</span><span class=\"o\">=</span><span class=\"n\">a</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"o\">*</span><span class=\"n\">fast</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">MOD</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">7</span><span class=\"o\">*</span><span class=\"p\">((</span><span class=\"n\">b</span><span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">)</span><span class=\"o\">%</span><span class=\"n\">MOD</span><span class=\"p\">));</span>\n\t<span class=\"n\">ans</span><span class=\"o\">%=</span><span class=\"n\">MOD</span><span class=\"p\">;</span>\n\t<span class=\"n\">cout</span><span class=\"o\">&amp;lt;&amp;lt;</span><span class=\"n\">ans</span><span class=\"o\">&amp;lt;&amp;lt;</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\t<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>可以看出，为了优化，代码显得不怎么美观，如果题目不要求精确值的话，那么用浮点数以及pow我想应该可以让速度再快一点。</p><p>比较而言，其实<b>动态规划法是最简洁且高效的</b>。</p><h2>总结</h2><p>一个题目，多种方法，其实从本质而言，以计算机的思维做，自然是DP，以数学家的思维做，就是推导通项公式。然而，通项公式中有幂，让计算机做本质上也不高效。</p><p>从多线程优化的角度来看，DP法的本质是一层层递推的计算，后者依赖前者，计算并不独立，不能分解成小任务，最快就是O(n)。而公式法本质就是求幂，而求幂也存在依赖关系，且子问题都相同，没必要分割。穷举法倒可以保证子任务的独立性，不过计算量还是很大，当且仅当没有其他好方法的时候用。</p><p>公式法推导很复杂，耗时间，因此，用动态规划法是绝佳的。</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":27915133,"publishedTime":"2017-07-16T16:08:28+08:00","url":"/p/27915133","title":"【NOI】9272 偶数个三","summary":"题目链接：<a href=\"https://github.com/bajdcc/ACM/blob/master/noi/9272/%E5%81%B6%E6%95%B0%E4%B8%AA%E4%B8%89.md\">bajdcc/ACM</a>描述在所有的N位数中，有多少个数中有偶数个数字3？结果模12345。(1&amp;lt;=N&amp;lt;=10000)\n样例输入2\n样例输出73\n方法一：穷举评价：<b>最简单又是效率最低的方法。</b>缺陷：N很大时，用来遍历的i用long long就放不下了，gg。但是首先，你要耐心等到lon…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":7,"likesCount":31}},"annotationDetail":null,"commentsCount":14,"likesCount":63,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"专业研究野生技术","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{},"favlists":{}},"me":{},"global":{},"columns":{"next":{},"learncpp":{"following":false,"canManage":false,"href":"/api/columns/learncpp","name":"学习C++","creator":{"slug":"bajdcc"},"url":"/learncpp","slug":"learncpp","avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"}}},"columnPosts":{},"columnSettings":{"colomnAuthor":[],"uploadAvatarDetails":"","contributeRequests":[],"contributeRequestsTotalCount":0,"inviteAuthor":""},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true},"favlistsByUser":{},"favlistRelations":{},"promotions":{},"switches":{"couldAddVideo":false},"draft":{"titleImage":"","titleImageSize":{},"isTitleImageFullScreen":false,"canTitleImageFullScreen":false,"title":"","titleImageUploading":false,"error":"","content":"","draftLoading":false,"globalLoading":false,"pendingVideo":{"resource":null,"error":null}},"drafts":{"draftsList":[],"next":{}},"config":{"userNotBindPhoneTipString":{}},"recommendPosts":{"articleRecommendations":[],"columnRecommendations":[]},"env":{"isAppView":false,"appViewConfig":{"content_padding_top":128,"content_padding_bottom":56,"content_padding_left":16,"content_padding_right":16,"title_font_size":22,"body_font_size":16,"is_dark_theme":false,"can_auto_load_image":true,"app_info":"OS=iOS"},"isApp":false},"sys":{}}</textarea>

    
    <script src="//static.zhihu.com/hemingway/common.91b038e1bfdd343c17b1.js"></script>
<script src="//static.zhihu.com/hemingway/app.c97bc6d7df9ba310a52c.js"></script>
<script src="//static.zhihu.com/hemingway/raven.58b55ef131892b91fa07.js" async defer></script>
  </body>
</html>
