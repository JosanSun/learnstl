<!doctype html>
<html lang="zh-CN" class="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>【jMiniLang】哲学家就餐问题 - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.801234ee6d0e1200c89b55e9d3bf896f.css" />
    <style></style>
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","wechatConfigAPI":"/api/wechat/jssdkconfig","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"29008180":{"contributes":[{"sourceColumn":{"lastUpdated":1497249764,"description":"玩玩有趣的东西","permission":"COLUMN_PUBLIC","memberId":10760740,"contributePermission":"COLUMN_PUBLIC","translatedCommentPermission":"all","canManage":true,"intro":"写写C++","urlToken":"learncpp","id":25963,"imagePath":"v2-bf63794c542fc73b11e17014b7e0d01d.jpg","slug":"learncpp","applyReason":"0","name":"学习C++","title":"学习C++","url":"https://zhuanlan.zhihu.com/learncpp","commentPermission":"COLUMN_ALL_CAN_COMMENT","canPost":true,"created":1483611626,"state":"COLUMN_NORMAL","followers":2487,"avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"activateAuthorRequested":false,"following":false,"imageUrl":"https://pic2.zhimg.com/v2-bf63794c542fc73b11e17014b7e0d01d_l.jpg","articlesCount":48},"state":"accepted","targetPost":{"titleImage":"https://pic1.zhimg.com/v2-15c59a7711011767c2279f9a23e16c78_r.png","lastUpdated":1504410429,"imagePath":"v2-15c59a7711011767c2279f9a23e16c78.png","permission":"ARTICLE_PUBLIC","topics":[1354,3646,824],"summary":"<a href=\"https://github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95\">https://github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95</a>演示GIF(1.57MB)，控制台输出效果(还有parser/vm/ui)自己实现：信号量与PV原语<b>信号量</b>为正数代表有<u>空闲资源</u>，为零与负数代表<u>没有空闲资源</u>。负数的绝对值代表等待的进程个数。信号量用<b>（S，Q）</b>表示，S是非负初值的整型变量，Q为进程等待…","copyPermission":"ARTICLE_COPYABLE","translatedCommentPermission":"all","likes":0,"origAuthorId":0,"publishedTime":"2017-09-02T22:43:53+08:00","sourceUrl":"","urlToken":29008180,"id":3791204,"withContent":false,"slug":29008180,"bigTitleImage":false,"title":"【jMiniLang】哲学家就餐问题","url":"/p/29008180","commentPermission":"ARTICLE_ALL_CAN_COMMENT","snapshotUrl":"","created":1504363433,"comments":0,"columnId":0,"content":"","parentId":0,"state":"ARTICLE_PUBLISHED","imageUrl":"https://pic1.zhimg.com/v2-15c59a7711011767c2279f9a23e16c78_r.png","author":{"bio":"专业研究野生技术","isFollowing":false,"hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"slug":"bajdcc","isFollowed":false,"description":"专业研究野生技术 https://github.com/bajdcc","name":"陈安","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false},"memberId":10760740,"excerptTitle":"","voteType":"ARTICLE_VOTE_CLEAR"},"id":797654}],"title":"【jMiniLang】哲学家就餐问题","author":"bajdcc","content":"<p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt%23L95\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/jMini</span><span class=\"invisible\">Lang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></p><p>演示GIF(1.57MB)，控制台输出效果(还有parser/vm/ui)自己实现：</p><noscript><img src=\"https://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_b.gif\" data-rawwidth=\"810\" data-rawheight=\"610\" data-thumbnail=\"https://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"810\" data-original=\"https://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_r.gif\"></noscript><img src=\"data:image/svg+xml;utf8,&amp;lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='810'%20height='610'&amp;gt;&amp;lt;/svg&amp;gt;\" data-rawwidth=\"810\" data-rawheight=\"610\" data-thumbnail=\"https://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"810\" data-original=\"https://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_r.gif\" data-actualsrc=\"https://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_b.gif\"><h2>信号量与PV原语</h2><p><b>信号量</b>为正数代表有<u>空闲资源</u>，为零与负数代表<u>没有空闲资源</u>。负数的绝对值代表等待的进程个数。信号量用<b>（S，Q）</b>表示，S是非负初值的整型变量，Q为进程等待队列。</p><p><b>P原语（阻塞）</b>：令S=S-1，若S&amp;gt;=0，进程继续执行，否则该进程变为等待状态，入队列Q</p><p><b>V原语（唤醒）</b>：令S=S+1，若S&amp;gt;0，进程继续执行，否则释放队列Q中第一个等待信号量的进程</p><p>实现互斥：令S=1。</p><p><br></p><h2>用管道语义实现PV操作</h2><p>当前jMiniOS支持的管道操作：</p><ol><li>create_pipe，创建管道，返回句柄</li><li>write_pipe，向管道中写入一个字符（非堵塞）</li><li>read_pipe，从管道中不断读取字符流（堵塞）</li><li>read_pipe_once，从管道中读取一个字符（堵塞）</li><li>destroy_pipe，销毁管道</li></ol><p>用管道实现信号量：</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>var g_create_semaphore = func ~(name, n) {\n    if (call g_query_pipe(name)) {\n        return;\n    }\n    var pipe = call g_create_pipe(name);\n    call g_write_pipe(pipe, call g_string_rep(\"*\", n));\n    return pipe;\n};\nexport \"g_create_semaphore\";\nvar g_use_semaphore = func ~(name) {\n    return call g_create_pipe(name);\n};\nexport \"g_use_semaphore\";\nvar g_destroy_semaphore = func ~(handle) {\n    call g_destroy_pipe_once(handle);\n};\nexport \"g_destroy_semaphore\";\nvar g_lock_semaphore = func ~(handle) {\n    call g_read_pipe_once(handle);\n};\nexport \"g_lock_semaphore\";\nvar g_unlock_semaphore = func ~(handle) {\n    call g_write_pipe(handle, \"*\");\n};\nexport \"g_unlock_semaphore\";\n</code></pre></div><p><b>关键：</b></p><ol><li>创建管道后，信号量的初始值=管道中存储的字符个数，即管道中的内容=信号量中可用资源。</li><li>P操作 = 向管道中写一字符</li><li>V操作 = 从管道中读一字符</li><li>Mutex实现，create_mutex = create_semaphore(1)</li></ol><h2>实现哲学家就餐问题</h2><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>/* 哲学家就餐问题 */\nvar stage_philo = func ~() {\n    call word_typewrite(\"演示哲学家就餐问题！    \\n\", 100);\n    var print_mutex = call g_create_mutex(\"philo_print\");\n    foreach (var i : call g_range(1, 5)) {\n        call g_create_semaphore(\"fork_\" + i, 1); // 每个叉最多能使用一次\n    }\n    var handles = [];\n    var philo = func ~(args) { // philo = 新建进程， args = 参数\n        var eat = call g_map_get(args, \"eating\");\n        var o = call g_map_get(args, \"out\");\n        var id = call g_map_get(args, \"id\");\n        var left_id = call g_map_get(args, \"left_id\"); // 左叉ID\n        var right_id = call g_map_get(args, \"right_id\"); // 右叉ID\n        var left = call g_use_semaphore(\"fork_\" + left_id); // 左叉信号量\n        var right = call g_use_semaphore(\"fork_\" + right_id); // 右叉信号量\n        call eat(o, \"Philosophy#\" + id + \" ready\");\n        foreach (var j : call g_range(1, 10)) { // 吃十次才饱\n            call g_lock_semaphore(left); // P左叉\n            call eat(o, \"Philosophy#\" + id + \" is using fork#\" + left_id);\n            call g_lock_semaphore(right); // P右叉\n            call eat(o, \"Philosophy#\" + id + \" is using fork#\" + right_id);\n            call eat(o, \"Philosophy#\" + id + \" is eating. Process: \" + j + \"0%\");\n            call g_unlock_semaphore(left); // V左叉\n            call g_unlock_semaphore(right); // V右叉\n        }\n        call eat(o, \"Philosophy#\" + id + \" OK\");\n    };\n    var eating = func ~(out, str) { // 输出\n        var pm = call g_use_mutex(\"philo_print\");\n        call g_lock_mutex(pm);\n        foreach (var c : call g_range_string(str)) {\n            call g_write_pipe(out, c);\n        }\n        call g_write_pipe(out, '\\n');\n        call g_task_sleep_ms(100);\n        call g_unlock_mutex(pm);\n    };\n    foreach (var j : call g_range(1, 5)) {\n        var args = {}; // 传参\n        call g_map_put(args, \"eating\", eating);\n        call g_map_put(args, \"out\", out);\n        call g_map_put(args, \"id\", j);\n        call g_map_put(args, \"left_id\", (j == 1) ? 5 : (j - 1));\n        call g_map_put(args, \"right_id\", (j == 5) ? 1 : (j + 1));\n        var h = call g_create_user_process_args(philo, args); // 新建进程\n        call g_array_add(handles, h);\n        call g_task_sleep(1);\n    }\n    call g_join_process_array(handles);\n    foreach (var k : call g_range(1, 5)) {\n        call g_destroy_semaphore(call g_use_semaphore(\"fork_\" + k)); // 销毁\n    }\n    call g_destroy_mutex(call g_use_mutex(\"philo_print\")); // 销毁\n};\n</code></pre></div><p><br></p><h2>总结</h2><p>从实例上看，哲学家不是同时开始就餐的，而是陆续就餐，同时就餐肯定会导致死锁问题。所以要有一定的防死锁和饥饿的解法，网上也有很多，有一种管程的解法。</p><p>例子中<b>每个哲学家不会知道其他哲学家的状态</b>，因此肯定会有缺陷啦，假如先让A就餐，然后A吃完再唤醒其他人，那就好办了。</p><p><b>唤醒</b>语义，好东西，想想linux中的进程状态实现，soga。因此，我们的程序除了要支持lock/unlock之外，还要支持wait/notify，下回分解。</p><p><br></p><p>===========================================</p><h2>0903 更新：用管程实现（jMiniLang语言）</h2><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>/* 哲学家就餐问题 - 管程解决 */\nvar stage_philo2 = func ~() {\n    call word_typewrite(\"【管程】演示哲学家就餐问题！    \\n\", 100);\n    call g_create_mutex(\"philo_print\");\n    call g_create_mutex(\"philo_monitor\");\n    var states = [];\n    call g_array_add(states, g_null);\n    foreach (var i : call g_range(1, 5)) {\n        call g_create_semaphore(\"philo_\" + i, 1); // 记录每个哲学家的状态（管程）\n        call g_array_add(states, \"thinking\"); // 开始时哲学家都在思考\n    }\n    var handles = [];\n    var philo2 = func ~(args) {\n        var eat = call g_map_get(args, \"eating\"); // 拿参数\n        var states = call g_map_get(args, \"states\");\n        var o = call g_map_get(args, \"out\");\n        var id = call g_map_get(args, \"id\");\n        var left_id = call g_map_get(args, \"left_id\");\n        var right_id = call g_map_get(args, \"right_id\");\n        var monitor = call g_use_mutex(\"philo_monitor\");\n        call eat(o, \"Philosophy#\" + id + \" ready\");\n        var enter = func ~() { // 进入临界区\n            var monitor = call g_use_mutex(\"philo_monitor\");\n            call g_lock_mutex(monitor); // mutex自带等待队列\n            call g_printdn(\"Philosophy#\" + id + \" entered critical section\");\n        };\n        var leave = func ~() { // 离开临界区\n            call g_printdn(\"Philosophy#\" + id + \" leaved critical section\");\n            var monitor = call g_use_mutex(\"philo_monitor\");\n            call g_unlock_mutex(monitor);\n        };\n        var wait = func ~(_id) { // 等待信号\n            var sem = call g_use_semaphore(\"philo_\" + _id);\n            call g_printdn(\"Philosophy#\" + _id + \" waiting\");\n            call g_lock_mutex(sem); // semaphore自带等待队列\n        };\n        var signal = func ~(_id) { // 发出信号\n            var sem = call g_use_semaphore(\"philo_\" + _id);\n            call g_unlock_mutex(sem);\n            call g_printdn(\"Philosophy#\" + _id + \" received signal\");\n        };\n        var test = func ~(_id) { // 测试哲学家是否具备进餐条件\n            var _left_id = (_id == 1) ? 5 : (_id - 1);\n            var _right_id = (_id == 5) ? 1 : (_id + 1);\n            if ((call g_array_get(states, _left_id) != \"eating\") &amp;amp;&amp;amp; // 如果左右都不在进餐\n                (call g_array_get(states, _right_id) != \"eating\") &amp;amp;&amp;amp;\n                (call g_array_get(states, _id) == \"hungry\")) { // 且自己为饥饿状态\n                call signal(_id); // 发出就餐信号\n            } else {\n                call g_printdn(\"Test failed. #\" + _left_id + \": \" + call g_array_get(states, _left_id) +\n                    \", #\" + _right_id + \": \" + call g_array_get(states, _right_id) + \", #\" +\n                    _id + \": \" +　call g_array_get(states, _id));\n            }\n        };\n        var pickup = func ~() { // 拿起叉子\n            call enter();\n            call g_array_set(states, id, \"hungry\"); // 设置状态是饥饿\n            call test(id); // 看看自己能否用餐\n            call leave();\n            if (call g_array_get(states, id) != \"eating\") { // 如果尝试失败\n                call wait(id); // 等待\n                call g_array_set(states, id, \"eating\"); // 设置为进餐状态\n            } // 这里设置状态不会冲突，因为pickup只能由一个哲学家调用\n        };\n        var putdown = func ~() { // 放下叉子\n            call enter();\n            call g_array_set(states, id, \"thinking\"); // 设置状态是思考\n            call test(left_id); // 测试左边的哲学家可否就餐\n            call test(right_id); // 测试右边的哲学家可否就餐\n            call leave();\n        };\n        foreach (var j : call g_range(1, 10)) {\n            call eat(o, \"Philosophy#\" + id + \" is thinking\");\n            call pickup();\n            call eat(o, \"Philosophy#\" + id + \" is eating. Process: \" + j + \"0%\");\n            call putdown();\n        }\n        call eat(o, \"Philosophy#\" + id + \" OK\");\n    };\n    var eating = func ~(out, str) {\n        var pm = call g_use_mutex(\"philo_print\");\n        call g_lock_mutex(pm);\n        foreach (var c : call g_range_string(str)) {\n            call g_write_pipe(out, c);\n        }\n        call g_write_pipe(out, '\\n');\n        call g_task_sleep_ms(100);\n        call g_unlock_mutex(pm);\n    };\n    foreach (var j : call g_range(1, 5)) {\n        var args = {};\n        call g_map_put(args, \"eating\", eating);\n        call g_map_put(args, \"states\", states);\n        call g_map_put(args, \"out\", out);\n        call g_map_put(args, \"id\", j);\n        call g_map_put(args, \"left_id\", (j == 1) ? 5 : (j - 1));\n        call g_map_put(args, \"right_id\", (j == 5) ? 1 : (j + 1));\n        var h = call g_create_user_process_args(philo2, args); // fork\n        call g_array_add(handles, h);\n    }\n    call g_join_process_array(handles);\n    foreach (var k : call g_range(1, 5)) {\n        call g_destroy_semaphore(call g_use_semaphore(\"fork_\" + k));\n    }\n    call g_destroy_mutex(call g_use_mutex(\"philo_print\"));\n};\n</code></pre></div><p><br></p><p><br></p><noscript><img src=\"https://pic2.zhimg.com/v2-c73b98c825ef916ad43876c7e593e235_b.png\" data-rawwidth=\"810\" data-rawheight=\"610\" class=\"origin_image zh-lightbox-thumb\" width=\"810\" data-original=\"https://pic2.zhimg.com/v2-c73b98c825ef916ad43876c7e593e235_r.png\"></noscript><img src=\"data:image/svg+xml;utf8,&amp;lt;svg%20xmlns='http://www.w3.org/2000/svg'%20width='810'%20height='610'&amp;gt;&amp;lt;/svg&amp;gt;\" data-rawwidth=\"810\" data-rawheight=\"610\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"810\" data-original=\"https://pic2.zhimg.com/v2-c73b98c825ef916ad43876c7e593e235_r.png\" data-actualsrc=\"https://pic2.zhimg.com/v2-c73b98c825ef916ad43876c7e593e235_b.png\"><p><br></p><p>从输出来看，哲学家就餐的顺序是1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4，是<b>非常有规律的、重复的、完美的顺序</b>，这说明了管程的使用是非常有效的，同时证明了<b>wait/signal机制的优越性</b>：<b>降低了锁的竞争程度(引入休眠)，同时唤醒机制保证了进程同步中各进程的运行顺序</b>。也就是说，如果一开始就出现了1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4循环，那么这个循环就一直存在直到程序结束。</p><h2>【深入】如果哲学家是6个、7个，那么就餐顺序又如何呢？</h2>","updated":"2017-09-02T14:43:53.000Z","canComment":false,"commentPermission":"anyone","commentCount":0,"collapsedCount":0,"likeCount":1,"state":"published","isLiked":false,"slug":"29008180","isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic1.zhimg.com/v2-15c59a7711011767c2279f9a23e16c78_r.png","links":{"comments":"/api/posts/29008180/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/19554298","id":"19554298","name":"编程"},{"url":"https://www.zhihu.com/topic/19561132","id":"19561132","name":"Java"},{"url":"https://www.zhihu.com/topic/19552686","id":"19552686","name":"操作系统"}],"adminClosedComment":false,"titleImageSize":{"width":810,"height":610},"href":"/api/posts/29008180","excerptTitle":"","tipjarState":"inactivated","annotationAction":[],"sourceUrl":"","pageCommentsCount":0,"hasPublishingDraft":false,"snapshotUrl":"","publishedTime":"2017-09-02T22:43:53+08:00","url":"/p/29008180","lastestLikers":[{"bio":"萍水相逢，多多保重。","isFollowing":false,"hash":"20493f511872e2ff6dd97d5f2db5a186","uid":36252736815104,"isOrg":false,"slug":"loodorz","isFollowed":false,"description":"猫奴十级，费边主义程序猿","name":"三毛","profileUrl":"https://www.zhihu.com/people/loodorz","avatar":{"id":"c13ce6cbd","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false}],"summary":"<img src=\"http://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_200x112.jpg\" data-rawwidth=\"810\" data-rawheight=\"610\" data-thumbnail=\"https://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_b.jpg\" class=\"origin_image inline-img zh-lightbox-thumb\" data-original=\"http://pic4.zhimg.com/v2-8735e0381ca5a6bf21c36106bfd69613_r.jpg\"><a href=\"https://github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95\">https://github.com/bajdcc/jMiniLang/blob/master/src/priv/bajdcc/LALR1/interpret/os/user/routine/URTest.txt#L95</a>演示GIF(1.57MB)，控制台输出效果(还有parser/vm/ui)自己实现：信号量与PV原语<b>信号量</b>为正数代表有<u>空闲资源</u>，为零与负数代表<u>没有空闲资源</u>。负数的绝对值代表等待的进程个数。信号量用<b>（S，Q）</b>表示，S是非负初值的整型变量，Q为进程等待…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"annotationDetail":null,"commentsCount":0,"likesCount":1,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"专业研究野生技术","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{},"favlists":{}},"me":{},"global":{},"columns":{"next":{}},"columnPosts":{},"columnSettings":{"colomnAuthor":[],"uploadAvatarDetails":"","contributeRequests":[],"contributeRequestsTotalCount":0,"inviteAuthor":""},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true},"favlistsByUser":{},"favlistRelations":{},"promotions":{},"switches":{"couldAddVideo":false},"draft":{"titleImage":"","titleImageSize":{},"isTitleImageFullScreen":false,"canTitleImageFullScreen":false,"title":"","titleImageUploading":false,"error":"","content":"","draftLoading":false,"globalLoading":false,"pendingVideo":{"resource":null,"error":null}},"drafts":{"draftsList":[],"next":{}},"config":{"userNotBindPhoneTipString":{}},"recommendPosts":{"articleRecommendations":[],"columnRecommendations":[]},"env":{"isAppView":false,"appViewConfig":{"content_padding_top":128,"content_padding_bottom":56,"content_padding_left":16,"content_padding_right":16,"title_font_size":22,"body_font_size":16,"is_dark_theme":false,"can_auto_load_image":true,"app_info":"OS=iOS"},"isApp":false},"sys":{}}</textarea>

    
    <script src="//static.zhihu.com/hemingway/common.88ebcfb3d810a398ff8a.js"></script>
<script src="//static.zhihu.com/hemingway/app.398b3cbc1a5a7ed4c9ca.js"></script>
<script src="//static.zhihu.com/hemingway/raven.4399bd4c70bb7f1e8291.js" async defer></script>
  </body>
</html>
