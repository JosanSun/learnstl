<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>【游戏框架系列】柳暗花明 - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.ad2159a596c8458712d70cf5a5b17235.css" />
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"25593280":{"title":"【游戏框架系列】柳暗花明","author":"bajdcc","content":"<h2>写在前面</h2><p>看到过类似的将寻路算法可视化的文章。</p><ul><li><a href=\"http://link.zhihu.com/?target=http%3A//blog.csdn.net/booirror/article/details/50834915\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">A*算法可视化详解与实现 - 代码妖娆 - 博客频道 - CSDN.NET<i class=\"icon-external\"></i></a></li><li><a href=\"https://zhuanlan.zhihu.com/p/23199073\" class=\"internal\">A*寻路算法的探寻与改良（一） - 知乎专栏</a><br></li></ul><p>寻思着将它们整合进游戏框架，总体上说，整合难度比较低。</p><br><h2>实现思路</h2><p>先前实现了TableLayout，设定长宽，可以均匀排布容器内各元素。题图中的方格也是这样的实现思路。</p><p>只实现了广度遍历BFS和深度遍历DFS，两者是经典的遍历算法。</p><p><b>书上一般采用open和closed两个表的方式，这里为了图简单，就用一张表实现了。</b>图的结构二维矩阵表示，1表示未访问过，3、4表示起点和终点，2表示墙，6及以上表示访问过。那么每次访问只要将矩阵中的值标记下即可。</p><ul><li>BFS是将当前访问方块的相邻未访问方块添加进表的末尾，每次从表头取出将要访问的方块。由于添加的方块要隔一段时间才能访问到，所以可能导致表的体积迅速增大。因此，BFS的效率比较差，它会遍历所有的方块，将它能够找到全局最优解。《后天》中的海水淹没城市也是BFS的体现。<br></li><li>DFS每次将当前方块的相邻未访问方块添加进表的头部，每次从表头取方块。所以与BFS不同，新添加的方块立马就被访问，故表的体积不会迅速增大。它能快速找到解，但不一定是全局最优解。生活中的闪电生长方式就是DFS。</li></ul><p>两种算法只是对于表的添加方式不同，DFS是添加到头部，BFS是添加到尾部。</p><p>这里主要的难点在于，方块的颜色是渐变的，离起点（红色）近的呈黑色，远的呈天蓝色。计算方式是求任意点到起点的距离，然后根据HSL转换到RGB，HSL的色相是固定的，而亮度是可以调整的，从而实现渐变效果。</p><p>-------------------------------------------------</p><p>下面实现(伪)A*算法。</p><p><img src=\"https://pic3.zhimg.com/v2-21a4c9f2c5b8ec365f4dcaefff1832d6_b.png\" data-rawwidth=\"1031\" data-rawheight=\"628\" class=\"origin_image zh-lightbox-thumb\" width=\"1031\" data-original=\"https://pic3.zhimg.com/v2-21a4c9f2c5b8ec365f4dcaefff1832d6_r.png\"><u>BFS和DFS方法都有缺点：BFS能找到全局最优，然而它需要将所有位置都访问一遍，耗时间；DFS快，但只是局部最优，且DFS如何挑选需展开的结点也没有明确规定。</u></p><p>A*对上述方式有了改进。A*给出了一个评估函数F。F=G+H。G是当前移动量，H是评估的待移动距离，两者总和是当前结节的评估值，当然，值越小，走这条路的可能性越大。</p><p>解决方法很简单：<b>令G=累积的移动距离；令H=当前位置离终点的哈密顿距离</b>。在展开结点的时候，对待选结点按F值排序，使F值最小的最先展开，从而节省时间。</p><p>A*的实现一般用open和closed表，它将open表中的结点按F排序，选代价最小的展开。<b>也就是说，A*算法每一次将open表中的结点进行排序，而A*的展开方式类似于BFS。</b>为什么是基于BFS？因为BFS产生的open表结点是当前已遍历结点的<b>轮廓</b>，这有点像最小生成树算法，从当前轮廓中挑选代价最小的结点进行展开。唯一影响A*效率的就是F的计算方法。<br></p><p><i><u>PS：由于偷懒，实现A*与上面的不同！上面是将open进行排序，而我只将当前结点的相邻结点进行排序，所以算法效果肯定没A*好。再者，本系列的目标是做GUI，算法可视化只是一个demo。</u></i></p><h2>阶段性总结</h2><p>A*算法的关键是设立一个评估函数，就如同阿法狗对局面的估计一样。它采用的其实类似于最小生成树的方式(把格子想成上下左右相连的图)，只是最小生成树的挑选规则是确定的(路径长度确定)，A*的挑选规则是不确定的(评估函数不精准)。这导致最小生成树产生最优解，而A*不一定能得到最优解。</p>","updated":"2017-03-06T08:31:53.000Z","canComment":false,"commentPermission":"anyone","commentCount":3,"collapsedCount":0,"likeCount":24,"state":"published","isLiked":false,"slug":"25593280","isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic2.zhimg.com/v2-d58044ead3cbb0d8fb1caafd05fe252d_r.png","links":{"comments":"/api/posts/25593280/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/19561633","id":"19561633","name":"C（编程语言）"},{"url":"https://www.zhihu.com/topic/19625716","id":"19625716","name":"算法与数据结构"},{"url":"https://www.zhihu.com/topic/19612186","id":"19612186","name":"Lua"}],"titleImageSize":{"width":1031,"height":628},"href":"/api/posts/25593280","excerptTitle":"","column":{"slug":"learncpp","name":"从零开始构建标准库"},"tipjarState":"inactivated","sourceUrl":"","pageCommentsCount":3,"snapshotUrl":"","publishedTime":"2017-03-06T16:31:53+08:00","url":"/p/25593280","lastestLikers":[{"profileUrl":"https://www.zhihu.com/people/li-bin-3-10","bio":"等不到就努力，等到了就珍惜","hash":"d68d9076393d53b0def7eb6f9d8c5918","uid":29354235002880,"isOrg":false,"description":"我跑呀跑，跑呀跑，只为追上那个曾被寄予厚望的自己。","isOrgWhiteList":false,"slug":"li-bin-3-10","avatar":{"id":"af75c69b1","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"name":"李斌"},{"profileUrl":"https://www.zhihu.com/people/jiao-shu-peng-26","bio":"敢同恶鬼争高下,岂因福祸避趋之。","hash":"d03132501938a8a8b5c87f7996b8606a","uid":547427576545742850,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"jiao-shu-peng-26","avatar":{"id":"f2027bddce42cc1d29239f3203338ffd","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"name":"无花无酒"},{"profileUrl":"https://www.zhihu.com/people/kagaya-80","bio":"计算机专业初心者，loveliver","hash":"54ddb18a7871fbce7c4f4ed11d0bbe3a","uid":793418762832449500,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"kagaya-80","avatar":{"id":"v2-bc0b4cef0ed57eb8bf041f55ac14002b","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"kagaya"},{"profileUrl":"https://www.zhihu.com/people/everwangJS","bio":"网球/滑雪/读书/电影  前端","hash":"2df9e12f614e727008e2c567a0428aa4","uid":29021303734272,"isOrg":false,"description":"网球/ 前端/","isOrgWhiteList":false,"slug":"everwangJS","avatar":{"id":"v2-bcaeb9cfb0afdd4497478106632889f1","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"name":"吃垚少年"},{"profileUrl":"https://www.zhihu.com/people/yuzhonglele","bio":"码农","hash":"1474599faed18411815907f95f2bdf66","uid":32539162968064,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"yuzhonglele","avatar":{"id":"6865497c4","template":"https://pic1.zhimg.com/{id}_{size}.jpg"},"name":"王华涛"}],"summary":"写在前面看到过类似的将寻路算法可视化的文章。<a href=\"http://link.zhihu.com/?target=http%3A//blog.csdn.net/booirror/article/details/50834915\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">A*算法可视化详解与实现 - 代码妖娆 - 博客频道 - CSDN.NET<i class=\"icon-external\"></i></a><a href=\"https://zhuanlan.zhihu.com/p/23199073\" class=\"internal\">A*寻路算法的探寻与改良（一） - 知乎专栏</a> 寻思着将它们整合进游戏框架，总体上说，整合难度比较低。 实现思路先前实现了TableLayout，设定长宽，可…","reviewingCommentsCount":0,"meta":{"previous":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic1.zhimg.com/v2-6cd541cd9f4d479281d00d7d378c3298_r.png","links":{"comments":"/api/posts/25490952/comments"},"topics":[{"url":"https://www.zhihu.com/topic/20032249","id":"20032249","name":"TensorFlow"},{"url":"https://www.zhihu.com/topic/19572360","id":"19572360","name":"Python 3.x"},{"url":"https://www.zhihu.com/topic/19608617","id":"19608617","name":"科学计算"}],"href":"/api/posts/25490952","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<h2>介绍Tensorflow</h2><p>摘自维基百科的一段文字：</p><blockquote>TensorFlow是Google Brain的第二代机器学习系统，2015年11月9日，参考实现作为开源软件发布。虽然参考实现运行在单台设备，TensorFlow可以运行在多个CPU和GPU（和可选的CUDA扩展）。它运行在64位Linux或macOS桌面或服务器系统，以及在移动计算平台上，包括Android和iOS。TensorFlow的计算用有状态的数据流图表示。许多Google团队已从DistBelief迁移到TensorFlow进行研究和生产。这个库的算法源于Google需要指导称为神经网络的计算机系统，类似人类学习和推理的方法，以便派生出新的应用程序承担以前仅人类能胜任的角色和职能；TensorFlow的名字来源于这类神经网络对多维数组执行的操作。这些多维数组被称为“张量”，但这个概念并不等同于张量的数学概念。其目的是训练神经网络检测和识别模式和相互关系。<br></blockquote><p>TF只是一个科学计算工具，要想实现一些很酷的功能，就需要学习相关的知识。作为初学者，一步一个坑，一步一个脚印，走进机器学习的世界。</p><h2>安装Tensorflow</h2><p><b>在Windows上安装Tensorflow的步骤如下（参考自<a href=\"http://link.zhihu.com/?target=http%3A//blog.csdn.net/ztf312/article/details/56018891\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">windows下基于Anaconda的Tensorflow环境配置 - CS青雀的巢 - 博客频道 - CSDN.NET<i class=\"icon-external\"></i></a></b><b>）：</b></p><br><ol><li>下载并安装<a href=\"http://link.zhihu.com/?target=https%3A//repo.continuum.io/archive/Anaconda3-4.3.0.1-Windows-x86_64.exe\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Anaconda3-4.3.0.1-Windows-x86_64.exe<i class=\"icon-external\"></i></a>，管理员运行，不要勾选“添加到PATH”</li><li>安装完成后，打开开始菜单，找到<b>Anaconda/Anaconda prompt</b>，以管理员权限运行，出现命令行窗口<br></li><li>建立名为tensorflow的conda计算环境，方法是输入命令conda create -n tensorflow python=3.5，嫌时间慢可以参考<a href=\"http://link.zhihu.com/?target=http%3A//blog.csdn.net/pengjian444/article/details/51924469\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">[加速]为conda添加国内镜像 - PJZero - 博客频道 - CSDN.NET<i class=\"icon-external\"></i></a></li><li>激活tensorflow环境，输入activate tensorflow<br></li><li>安装tensorflow，pip install <a href=\"http://link.zhihu.com/?target=https%3A//storage.googleapis.com/tensorflow/windows/cpu/tensorflow-0.12.1-cp35-cp35m-win_amd64.whl\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow-0.12.0-cp35-cp35m-win_amd64.whl<i class=\"icon-external\"></i></a></li></ol><h2>测试</h2><p>输入测试命令：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span></span><span class=\"c1\"># python</span>\n<span class=\"kn\">import</span> <span class=\"nn\">tensorflow</span> <span class=\"kn\">as</span> <span class=\"nn\">tf</span>\n<span class=\"n\">hello</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"s1\">'Hello, Tensorflow!'</span><span class=\"p\">)</span>\n<span class=\"n\">sess</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">Session</span><span class=\"p\">()</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">sess</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">hello</span><span class=\"p\">))</span>\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">tf</span><span class=\"o\">.</span><span class=\"n\">constant</span><span class=\"p\">(</span><span class=\"mi\">22</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">sess</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">))</span>\n</code></pre></div><p>运行结果如题图所示。</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":25490952,"publishedTime":"2017-03-01T09:53:45+08:00","url":"/p/25490952","title":"【玩转科学计算】在Win上安装Tensorflow","summary":"介绍Tensorflow摘自维基百科的一段文字：TensorFlow是Google Brain的第二代机器学习系统，2015年11月9日，参考实现作为开源软件发布。虽然参考实现运行在单台设备，TensorFlow可以运行在多个CPU和GPU（和可选的CUDA扩展）。它运行在64位Linux或macOS桌面或…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0},"next":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic2.zhimg.com/v2-8c93a396956492760f4541a49b5c42d5_r.png","links":{"comments":"/api/posts/25593938/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19610596","id":"19610596","name":"元胞自动机理论"},{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"},{"url":"https://www.zhihu.com/topic/19593616","id":"19593616","name":"编程学习"}],"href":"/api/posts/25593938","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<i>【多图预警】本文含有大量图片</i><h2>写在前面</h2><p>这次实现的是Wireworld元胞自动机，相关资料如下：</p><ul><li>维基：<a href=\"http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Wireworld\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Wireworld - Wikipedia<i class=\"icon-external\"></i></a><br></li><li>介绍：<a href=\"http://link.zhihu.com/?target=http%3A//karlscherer.com/Wireworld.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Wireworld<i class=\"icon-external\"></i></a></li><li>Flash模拟：<a href=\"http://link.zhihu.com/?target=http%3A//www.rezmason.net/wireworld/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Wireworld Player (Flash)<i class=\"icon-external\"></i></a><br></li><li>如何实现简单的计算机：<a href=\"http://link.zhihu.com/?target=https%3A//www.quinapalus.com/wi-index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Wireworld computer<i class=\"icon-external\"></i></a><br></li><li>Clojure实现：<a href=\"http://link.zhihu.com/?target=https%3A//danprince.github.io/wireworld/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Wireworld Simulator<i class=\"icon-external\"></i></a><br></li><li>C++跨平台模拟器：<a href=\"http://link.zhihu.com/?target=https%3A//sourceforge.net/projects/golly/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Golly<i class=\"icon-external\"></i></a><br></li></ul><h2>规则</h2><p>组成：</p><ol><li>空</li><li>导体</li><li>电子头</li><li>电子尾<br></li></ol><p>每代变化：</p><br><ol><li>空→空</li><li>电子头→电子尾</li><li>电子尾→导体</li><li>当仅有一个或仅有两个电子头的邻居是导体时，导体→电子头</li></ol><p>第一次见到用Wireworld实现计算机的时候，我是崩溃的，竟然能够设计这么简单的自动机去实现计算机，这里一共只有三种状态（空不算），而真实世界只有两种状态，更为简单。遗憾的是，这个模拟的计算机需要几万代才能使七段LED上的数字产生变化，真实情况（CPU频率是几GHz）比这快多了。</p><h2>简单介绍</h2><p><b>一、时钟信号发生器</b></p><br><img src=\"http://pic2.zhimg.com/v2-940b168ed11c0734c872b5552aca7cbd_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\"><p>上图是3周期、4周期时钟。</p><p><b>二、二极管</b></p><img src=\"http://pic2.zhimg.com/v2-ce7cfe981c7b6ecb3862b958914320ed_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\"><p>上两个是二极管，下两个是与非门和与门。</p><p><b>三、逻辑门</b></p><img src=\"http://pic4.zhimg.com/v2-16a0d83606ff7e7211f200dd9915e3c3_b.jpg\" data-rawwidth=\"400\" data-rawheight=\"400\" class=\"content_image\" width=\"400\"><p>上图是非门，周期为3、4、5、6。</p><p><img src=\"http://pic1.zhimg.com/v2-5d030cb7dc50408a4896be86fd5c2ac0_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\">上图为或门。</p><p><img src=\"http://pic2.zhimg.com/v2-94d9444eab2ba3d85ca73afa84803c11_b.jpg\" data-rawwidth=\"400\" data-rawheight=\"400\" class=\"content_image\" width=\"400\">上图为3周期异或门。</p><p><img src=\"http://pic1.zhimg.com/v2-bfa11ecd82d1f4537acf26ddc412bbec_b.jpg\" data-rawwidth=\"400\" data-rawheight=\"400\" class=\"content_image\" width=\"400\">上图为与门。</p><p><img src=\"http://pic4.zhimg.com/v2-c21281004316608b1a32f5de20b7cdf7_b.jpg\" data-rawwidth=\"400\" data-rawheight=\"400\" class=\"content_image\" width=\"400\">上图为与非门。</p><p><b>四、分频器</b></p><p><img src=\"http://pic4.zhimg.com/v2-73613797bc12a15896da474c5c53278b_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\">上图为增频器。</p><p><img src=\"http://pic2.zhimg.com/v2-036719cb3891986b0cdb0a7acad8a35d_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\">上图为降频器。</p><p><b>五、熔断器</b></p><p><img src=\"http://pic2.zhimg.com/v2-3f1f4b78127cf42c712e02a7a1bb7b1d_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\"><img src=\"http://pic3.zhimg.com/v2-bdfe49e525782bd52d11ab83d7cf241a_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\"><img src=\"http://pic2.zhimg.com/v2-e3b90cc0fc39d854208727e08213a959_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\">上三图为4、5、6周期熔断器。当熔断器接收到信号后，它将阻断后续的一切信号。</p><p><b>六、ROM</b></p><p><img src=\"http://pic1.zhimg.com/v2-e5c04857093bd2856b5d1a0cece37194_b.jpg\" data-rawwidth=\"400\" data-rawheight=\"400\" class=\"content_image\" width=\"400\">ROM比较有趣，实现很简洁，左三线为寻址线，右三线为输出数据线。</p><p><b>七、触发器</b></p><p><img src=\"http://pic2.zhimg.com/v2-7ec35900b336547fb6bcbfc8904f6f99_b.jpg\" data-rawwidth=\"400\" data-rawheight=\"400\" class=\"content_image\" width=\"400\">上图是RS锁存器（双输入翻转器）。</p><p><b>八、边沿检测</b></p><p><img src=\"http://pic2.zhimg.com/v2-e729540af8af759823b5ec15dbb14b09_b.jpg\" data-rawwidth=\"400\" data-rawheight=\"400\" class=\"content_image\" width=\"400\">上图为上升沿检测。</p><p><img src=\"http://pic3.zhimg.com/v2-dafa49b0be65b2bb21eba2e45009dbb6_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\">上图为下降沿检测。</p><p><b>九、信号分离器</b></p><p><img src=\"http://pic3.zhimg.com/v2-cad10d5dea718ec19515250fe4bed0e6_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\"><img src=\"http://pic4.zhimg.com/v2-baa1a8a2becc63f761cf52e73990e427_b.jpg\" data-rawwidth=\"400\" data-rawheight=\"400\" class=\"content_image\" width=\"400\">它将信号按周期进行分离。</p><p><b>十、信号延长与缩短</b></p><p><img src=\"http://pic4.zhimg.com/v2-9471703506ad0cfaf755dd5f1c3b8fcb_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\">上图将一系列连续信号的尾部延长/缩短一周期。</p><p><img src=\"http://pic3.zhimg.com/v2-e1b041cb2c42118b42bc11c4081255ea_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\">上图将一系列连续信号的头部延长/缩短一周期。<br></p><p><b>十一、移位暂存器</b></p><p><img src=\"http://pic3.zhimg.com/v2-f4aed2e73b5d1b212c62451513a15ca6_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\">完成串行到并行的转换。左边输入端的信号经过处理，输出至右边的相应地址线。左边源源不断产生信号，右边的1、2、3、4、5端相继输出，每次只有一条输出端有效。</p><p><b>十二、计数器</b></p><img src=\"http://pic1.zhimg.com/v2-271aa3a7b02d4da9404a0b4fa69ae2b8_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\"><p><b>十三、ALU</b></p><p><img src=\"http://pic4.zhimg.com/v2-40c1dc3635b6ed2de891ca3d2357d1af_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\">上图为乘法器。</p><p><img src=\"http://pic2.zhimg.com/v2-783c111cac1feac4abdcb60c3f7b0de1_b.jpg\" data-rawwidth=\"398\" data-rawheight=\"398\" class=\"content_image\" width=\"398\">上图为加法器。</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":25593938,"publishedTime":"2017-03-06T16:44:24+08:00","url":"/p/25593938","title":"【游戏框架系列】Wireworld元胞自动机","summary":"<i>【多图预警】本文含有大量图片</i>写在前面这次实现的是Wireworld元胞自动机，相关资料如下：维基：<a href=\"https://en.wikipedia.org/wiki/Wireworld\" data-editable=\"true\" data-title=\"Wireworld - Wikipedia\" class=\"\">Wireworld - Wikipedia</a> 介绍：<a href=\"http://karlscherer.com/Wireworld.html\" data-editable=\"true\" data-title=\"Wireworld\" class=\"\">Wireworld</a>Flash模拟：<a href=\"http://www.rezmason.net/wireworld/\" class=\"\" data-editable=\"true\" data-title=\"Wireworld Player (Flash)\">Wireworld Player (Flash)</a> 如何实现简单的计算机：<a href=\"https://www.quinapalus.com/wi-index.html\" class=\"\" data-editable=\"true\" data-title=\"The Wireworld computer\">The Wireworld computer</a> Clojure实现：<a href=\"https://danprince.github.io/wireworld/\" data-editable=\"true\" data-title=\"Wireworld Simulator\" class=\"\">Wireworld Simulator</a>…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0}},"commentsCount":3,"likesCount":24,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{}},"me":{},"global":{},"columns":{"learncpp":{"following":false,"canManage":false,"href":"/api/columns/learncpp","name":"从零开始构建标准库","creator":{"slug":"bajdcc"},"url":"/learncpp","slug":"learncpp","avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"FULLINFO":false}},"columnPosts":{},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true}}</textarea>

    <script src="//static.zhihu.com/hemingway/common.ac46319b23e12700340a.js"></script>
<script src="//static.zhihu.com/hemingway/app.47dccfede9fcf0800757.js"></script>
<script src="//static.zhihu.com/hemingway/raven.ccdadd4407812d1aac2f.js" async defer></script>
  </body>
</html>
