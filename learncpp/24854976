<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>第一章：内存管理 - 知乎专栏</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <link rel="shortcut icon" href="https://static.zhihu.com/static/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//static.zhihu.com/hemingway/app.ad2159a596c8458712d70cf5a5b17235.css" />
    <script>document.documentElement.className += ('ontouchstart' in window) ? ' touch' : ' no-touch'</script>
  </head>
  <body>

    <div id="react-root"></div>
    <textarea id="clientConfig" hidden>{"debug":false,"apiRoot":"","paySDK":"https://pay.zhihu.com/api/js","name":"production","instance":"column","tokens":{"X-XSRF-TOKEN":null,"X-UDID":null,"Authorization":"oauth c3cef7c66a1843f8b3a9e6a1e3160e20"}}</textarea>
    <textarea id="preloadedState" hidden>{"database":{"Post":{"24854976":{"title":"第一章：内存管理","author":"bajdcc","content":"<h1>第一章：内存管理</h1><h2>地位</h2><p>程序=数据结构+算法，总体还是围绕内存进行各种操作。偌大的一块内存令人茫然，如同空白的棋盘一样，令人无从下手。然而，下棋有固定的套路，管理内存亦然。管理一块内存，粗看看是简单的活儿，但实际中体会一遍过后就感觉不那么简单。</p><p>接触C语言，那么对malloc和free一定不陌生，C++中的new和delete同样如此。有了这些方法，变长数组和对象的灵活创建也就成了可能。</p><p>想一想：假如没有了malloc、free，或是new和delete，哪些程序还能原模原样运行着？这个答案也就暗示着内存管理的地位如何。这部分内容和整个库的联系暗含其中，地位处于库的底层，依赖链条的起始端。因而，本部分是最先可以动手完成的内容。</p><h2>基础</h2><h3>内存</h3><p>所有的struct、class等内容都位于内存中。通过调用相关的方法可以向操作系统申请特定大小的内存。主要的内存管理操作这里就实现两种：申请和释放，另外还做了一些必要的安全检查。</p><h3>内存池</h3><p>这里其实也可以叫作对象池。内存池负责管理一块内存，完成日常的内存申请和释放操作，那么它的任务简不简单？并不简单！</p><p>申请和释放？一般人想到设个flag不就没事了。事实没有那么简单，因为会有一种叫作<strong>内存碎片</strong>的情况出现。</p><p>假设一开始全部是申请操作，所有内存都申请完了。接着要接二连三释放一半的内存。释放完后，出现一片片的空洞。可用空间还有一半，但是如何从一个个空洞中去找够用的内存块？值得深究。况且，申请的内存大小参差不齐，更加增加了难度。</p><h3>实现</h3><p>自己去实现一个内存池很有难度，好在有优秀的方法可以参考。</p><p>这里就采用<strong>分块法</strong>，即把内存分成一个个块，每个块有自己的属性：是否空闲、大小等。为了使块与块之间能够遍历，需要添加链表指针，这里就采用<strong>双向链表</strong>。内存的查找采用<strong>初次匹配</strong>的原则，而不是最佳匹配，后者需要花更多的时间。内存的释放附有<strong>合并空闲块</strong>的任务。</p><h2>思路</h2><ol><li><p>建立原始类型type</p></li><li><p>构建原始内存池legacy_memory_pool&amp;lt;default_allocator&amp;gt;，无块大小限制，双向链表</p></li><li><p>完善legacy_memory_pool，实现allocator接口，实现legacy_memory_pool_allocator</p></li><li><p>命名类型using memory_pool = legacy_memory_pool&amp;lt;legacy_memory_pool_allocator&amp;gt;</p></li><li><p>编写单元测试，除bug</p></li><li><p>思考需要改进的地方，这里没有实现realloc和calloc</p></li></ol><h2>详解</h2><h3>一、原始类型</h3><p>这里没有什么难点。需要注意32位和64位的区别。</p><p>简单起见，库的实现就先照顾32位系统。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">namespace</span> <span class=\"n\">clib</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">namespace</span> <span class=\"n\">type</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">using</span> <span class=\"n\">int8</span> <span class=\"o\">=</span> <span class=\"kt\">signed</span> <span class=\"kr\">__int8</span><span class=\"p\">;</span>\n        <span class=\"k\">using</span> <span class=\"n\">uint8</span> <span class=\"o\">=</span> <span class=\"kt\">unsigned</span> <span class=\"kr\">__int8</span><span class=\"p\">;</span>\n        <span class=\"k\">using</span> <span class=\"n\">int16</span> <span class=\"o\">=</span> <span class=\"kt\">signed</span> <span class=\"kr\">__int16</span><span class=\"p\">;</span>\n        <span class=\"k\">using</span> <span class=\"n\">uint16</span> <span class=\"o\">=</span> <span class=\"kt\">unsigned</span> <span class=\"kr\">__int16</span><span class=\"p\">;</span>\n        <span class=\"k\">using</span> <span class=\"n\">int32</span> <span class=\"o\">=</span> <span class=\"kt\">signed</span> <span class=\"kr\">__int32</span><span class=\"p\">;</span>\n        <span class=\"k\">using</span> <span class=\"n\">uint32</span> <span class=\"o\">=</span> <span class=\"kt\">unsigned</span> <span class=\"kr\">__int32</span><span class=\"p\">;</span>\n        <span class=\"k\">using</span> <span class=\"n\">int64</span> <span class=\"o\">=</span> <span class=\"kt\">signed</span> <span class=\"kr\">__int64</span><span class=\"p\">;</span>\n        <span class=\"k\">using</span> <span class=\"n\">uint64</span> <span class=\"o\">=</span> <span class=\"kt\">unsigned</span> <span class=\"kr\">__int64</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#ifdef WIN32</span>\n        <span class=\"k\">using</span> <span class=\"n\">sint</span> <span class=\"o\">=</span> <span class=\"n\">int32</span><span class=\"p\">;</span>\n        <span class=\"k\">using</span> <span class=\"n\">uint</span> <span class=\"o\">=</span> <span class=\"n\">uint32</span><span class=\"p\">;</span>\n<span class=\"cp\">#else</span>\n        <span class=\"k\">using</span> <span class=\"n\">sint</span> <span class=\"o\">=</span> <span class=\"n\">int64</span><span class=\"p\">;</span>\n        <span class=\"k\">using</span> <span class=\"n\">uint</span> <span class=\"o\">=</span> <span class=\"n\">uint64</span><span class=\"p\">;</span>\n<span class=\"cp\">#endif</span>\n\n        <span class=\"k\">using</span> <span class=\"n\">byte</span> <span class=\"o\">=</span> <span class=\"n\">uint8</span><span class=\"p\">;</span>\n        <span class=\"k\">using</span> <span class=\"kt\">size_t</span> <span class=\"o\">=</span> <span class=\"n\">uint</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>二、默认接口</h3><p>这里调用了new和delete方法，没什么难点。</p><p>带args的方法意味着会调用构造函数。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"kt\">size_t</span> <span class=\"n\">DefaultSize</span> <span class=\"o\">=</span> <span class=\"mh\">0x10000</span><span class=\"o\">&amp;gt;</span>\n<span class=\"k\">class</span> <span class=\"nc\">default_allocator</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n\t<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">size_t</span> <span class=\"n\">DEFAULT_ALLOC_BLOCK_SIZE</span> <span class=\"o\">=</span> <span class=\"n\">DefaultSize</span><span class=\"p\">;</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">__alloc</span><span class=\"p\">()</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">T</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">__alloc_array</span><span class=\"p\">(</span><span class=\"n\">uint</span> <span class=\"n\">size</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">T</span><span class=\"p\">[</span><span class=\"n\">size</span><span class=\"p\">];</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"p\">,</span> <span class=\"k\">class</span> <span class=\"err\">... </span><span class=\"nc\">TArgs</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">__alloc_args</span><span class=\"p\">(</span><span class=\"n\">TArgs</span> <span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"p\">,</span> <span class=\"k\">class</span> <span class=\"err\">... </span><span class=\"nc\">TArgs</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">__alloc_array_args</span><span class=\"p\">(</span><span class=\"n\">uint</span> <span class=\"n\">size</span><span class=\"p\">,</span> <span class=\"n\">TArgs</span> <span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">T</span><span class=\"p\">[</span><span class=\"n\">size</span><span class=\"p\">];</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"kt\">bool</span> <span class=\"n\">__free</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">delete</span> <span class=\"n\">t</span><span class=\"p\">;</span>\n\t\t<span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"kt\">bool</span> <span class=\"n\">__free_array</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">delete</span><span class=\"p\">[]</span> <span class=\"n\">t</span><span class=\"p\">;</span>\n\t\t<span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><h3>三、内存块</h3><h4>块的属性</h4><p>内存块包含四个数据成员：</p><ul><li><p>size：该块后面跟着的数据部分的大小（以块的大小为基本单位）</p></li><li><p>flag：参数，比如要设置空闲位BLOCK_USING</p></li><li><p>prev：前一节点</p></li><li><p>next：后一节点</p></li></ul><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">struct</span> <span class=\"n\">block</span>\n<span class=\"p\">{</span>\n\t<span class=\"kt\">size_t</span> <span class=\"n\">size</span><span class=\"p\">;</span> <span class=\"c1\">// 数据部分的大小</span>\n\t<span class=\"n\">uint</span> <span class=\"n\">flag</span><span class=\"p\">;</span>   <span class=\"c1\">// 参数</span>\n\t<span class=\"n\">block</span> <span class=\"o\">*</span><span class=\"n\">prev</span><span class=\"p\">;</span> <span class=\"c1\">// 前指针</span>\n\t<span class=\"n\">block</span> <span class=\"o\">*</span><span class=\"n\">next</span><span class=\"p\">;</span> <span class=\"c1\">// 后指针</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">enum</span> <span class=\"n\">block_flag</span>\n<span class=\"p\">{</span>\n\t<span class=\"n\">BLOCK_USING</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"p\">};</span>\n</code></pre></div><h4>块的方法</h4><p>方法有：</p><ul><li><p>block_align：块的大小对齐，单位是块的大小（这里是16byte，那么1=16byte）</p></li><li><p>block_init：块的初始化</p></li><li><p>block_connect：块的连接，将A和B连接起来，其中A是原本有的，B是新添加上去的</p></li><li><p>block_merge：块的合并，合并后只有一个头部（块头~）</p></li><li><p>block_set_flag和block_get_flag：设置标志位</p></li></ul><h3>四、内存池</h3><h4>申请内存</h4><p>构建一个循环遍历指针，不断遍历各个块，如果当前块是空闲的且空间足够，就开辟它！</p><p>将块分割后，将在当前块后面建立一个新的块。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"c1\">// 申请内存</span>\n<span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"nf\">_alloc</span><span class=\"p\">(</span><span class=\"kt\">size_t</span> <span class=\"n\">size</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">size</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">return</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">old_size</span> <span class=\"o\">=</span> <span class=\"n\">size</span><span class=\"p\">;</span>\n\t<span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">block_align</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">size</span> <span class=\"o\">&amp;gt;=</span> <span class=\"n\">block_available_size</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">return</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">block_current</span> <span class=\"o\">==</span> <span class=\"n\">block_head</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">alloc_free_block</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">blk</span> <span class=\"o\">=</span> <span class=\"n\">block_current</span><span class=\"p\">;</span>\n\t<span class=\"k\">do</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">block_get_flag</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">,</span> <span class=\"n\">BLOCK_USING</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">size</span> <span class=\"o\">&amp;gt;=</span> <span class=\"n\">size</span><span class=\"p\">)</span>\n\t\t<span class=\"p\">{</span>\n\t\t\t<span class=\"n\">block_current</span> <span class=\"o\">=</span> <span class=\"n\">blk</span><span class=\"p\">;</span>\n\t\t\t<span class=\"k\">return</span> <span class=\"n\">alloc_free_block</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span>\n\t\t<span class=\"p\">}</span>\n\t\t<span class=\"n\">blk</span> <span class=\"o\">=</span> <span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span> <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">blk</span> <span class=\"o\">!=</span> <span class=\"n\">block_current</span><span class=\"p\">);</span>\n\t<span class=\"k\">return</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 查找空闲块</span>\n<span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"nf\">alloc_free_block</span><span class=\"p\">(</span><span class=\"kt\">size_t</span> <span class=\"n\">size</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">block_current</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">size</span> <span class=\"o\">==</span> <span class=\"n\">size</span><span class=\"p\">)</span> <span class=\"c1\">// 申请的大小正好是空闲块大小</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">alloc_cur_block</span><span class=\"p\">(</span><span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"c1\">// 申请的空间小于空闲块大小，将空闲块分裂</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">new_size</span> <span class=\"o\">=</span> <span class=\"n\">block_current</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">new_size</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">alloc_cur_block</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span> <span class=\"c1\">// 分裂后的新块空间过低，放弃分裂</span>\n\t<span class=\"n\">block</span> <span class=\"o\">*</span><span class=\"n\">new_blk</span> <span class=\"o\">=</span> <span class=\"n\">block_current</span> <span class=\"o\">+</span> <span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\t<span class=\"n\">block_init</span><span class=\"p\">(</span><span class=\"n\">new_blk</span><span class=\"p\">,</span> <span class=\"n\">new_size</span><span class=\"p\">);</span>\n\t<span class=\"n\">block_connect</span><span class=\"p\">(</span><span class=\"n\">block_current</span><span class=\"p\">,</span> <span class=\"n\">new_blk</span><span class=\"p\">);</span>\n\t<span class=\"k\">return</span> <span class=\"n\">alloc_cur_block</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 直接使用当前的空闲块</span>\n<span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"nf\">alloc_cur_block</span><span class=\"p\">(</span><span class=\"kt\">size_t</span> <span class=\"n\">size</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t<span class=\"c1\">// 直接使用空闲块</span>\n\t<span class=\"n\">block_set_flag</span><span class=\"p\">(</span><span class=\"n\">block_current</span><span class=\"p\">,</span> <span class=\"n\">BLOCK_USING</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">// 设置标志为可用</span>\n\t<span class=\"n\">block_current</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">size</span><span class=\"p\">;</span>\n\t<span class=\"n\">block_available_size</span> <span class=\"o\">-=</span> <span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&amp;lt;</span><span class=\"kt\">void</span><span class=\"o\">*&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">block_current</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n\t<span class=\"n\">block_current</span> <span class=\"o\">=</span> <span class=\"n\">block_current</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">next</span><span class=\"p\">;</span> <span class=\"c1\">// 指向后一个块</span>\n\t<span class=\"k\">return</span> <span class=\"n\">cur</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h4>释放内存</h4><p>其实这里并不是真正意义上的“释放”，只是清除了标记而已。</p><p>释放前必须检查地址合法性；释放后要进行空闲块合并的操作。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"c1\">// 释放内存</span>\n<span class=\"kt\">bool</span> <span class=\"nf\">_free</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t<span class=\"n\">block</span> <span class=\"o\">*</span><span class=\"n\">blk</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&amp;lt;</span><span class=\"n\">block</span><span class=\"o\">*&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n\t<span class=\"o\">--</span><span class=\"n\">blk</span><span class=\"p\">;</span> <span class=\"c1\">// 自减得到块的元信息头</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">verify_address</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">))</span>\n\t\t<span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">next</span> <span class=\"o\">==</span> <span class=\"n\">blk</span><span class=\"p\">)</span> <span class=\"c1\">// 只有一个块</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"n\">block_set_flag</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">,</span> <span class=\"n\">BLOCK_USING</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n\t\t<span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">prev</span> <span class=\"o\">==</span> <span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">next</span> <span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">block_get_flag</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">prev</span><span class=\"p\">,</span> <span class=\"n\">BLOCK_USING</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"c1\">// 只有两个块</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"n\">_init</span><span class=\"p\">();</span> <span class=\"c1\">// 两个块都空闲，直接初始化</span>\n\t\t<span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">is_prev_free</span> <span class=\"o\">=</span> <span class=\"n\">block_get_flag</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">prev</span><span class=\"p\">,</span> <span class=\"n\">BLOCK_USING</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">prev</span> <span class=\"o\">&amp;lt;</span> <span class=\"n\">blk</span><span class=\"p\">;</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">is_next_free</span> <span class=\"o\">=</span> <span class=\"n\">block_get_flag</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">next</span><span class=\"p\">,</span> <span class=\"n\">BLOCK_USING</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">blk</span> <span class=\"o\">&amp;lt;</span> <span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">bit</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">is_prev_free</span> <span class=\"o\">&amp;lt;&amp;lt;</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">is_next_free</span><span class=\"p\">;</span>\n\t<span class=\"k\">switch</span> <span class=\"p\">(</span><span class=\"n\">bit</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t<span class=\"k\">case</span> <span class=\"mi\">0</span><span class=\"o\">:</span>\n\t\t<span class=\"n\">block_available_size</span> <span class=\"o\">+=</span> <span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\t\t<span class=\"n\">block_set_flag</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">,</span> <span class=\"n\">BLOCK_USING</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\n\t<span class=\"k\">case</span> <span class=\"mi\">1</span><span class=\"o\">:</span>\n\t\t<span class=\"n\">block_available_size</span> <span class=\"o\">+=</span> <span class=\"n\">block_merge</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">,</span> <span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">next</span><span class=\"p\">);</span>\n\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\n\t<span class=\"k\">case</span> <span class=\"mi\">2</span><span class=\"o\">:</span>\n\t\t<span class=\"n\">block_available_size</span> <span class=\"o\">+=</span> <span class=\"n\">block_merge</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">prev</span><span class=\"p\">,</span> <span class=\"n\">blk</span><span class=\"p\">);</span>\n\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\n\t<span class=\"k\">case</span> <span class=\"mi\">3</span><span class=\"o\">:</span>\n\t\t<span class=\"n\">block_available_size</span> <span class=\"o\">+=</span> <span class=\"n\">block_merge</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">prev</span><span class=\"p\">,</span> <span class=\"n\">blk</span><span class=\"p\">,</span> <span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">next</span><span class=\"p\">);</span>\n\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\n\t<span class=\"k\">default</span><span class=\"o\">:</span>\n\t\t<span class=\"k\">break</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 验证地址是否合法</span>\n<span class=\"kt\">bool</span> <span class=\"nf\">verify_address</span><span class=\"p\">(</span><span class=\"n\">block</span> <span class=\"o\">*</span><span class=\"n\">blk</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">blk</span> <span class=\"o\">&amp;lt;</span> <span class=\"n\">block_head</span> <span class=\"o\">||</span> <span class=\"n\">blk</span> <span class=\"o\">&amp;gt;</span> <span class=\"n\">block_head</span> <span class=\"o\">+</span> <span class=\"n\">DEFAULT_ALLOC_MEMORY_SIZE</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n\t\t<span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n\t<span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">next</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">prev</span> <span class=\"o\">==</span> <span class=\"n\">blk</span><span class=\"p\">)</span> <span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">prev</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">next</span> <span class=\"o\">==</span> <span class=\"n\">blk</span><span class=\"p\">)</span> <span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"p\">(</span><span class=\"n\">block_get_flag</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">,</span> <span class=\"n\">BLOCK_USING</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>五、封装</h3><p>到这里要大功告成了，封装一下！</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"c1\">// 基于原始内存池的内存分配策略</span>\n<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">Allocator</span> <span class=\"o\">=</span> <span class=\"n\">default_allocator</span><span class=\"o\">&amp;lt;&amp;gt;</span><span class=\"p\">,</span> <span class=\"kt\">size_t</span> <span class=\"n\">DefaultSize</span> <span class=\"o\">=</span> <span class=\"n\">Allocator</span><span class=\"o\">::</span><span class=\"n\">DEFAULT_ALLOC_BLOCK_SIZE</span><span class=\"o\">&amp;gt;</span>\n<span class=\"k\">class</span> <span class=\"nc\">legacy_memory_pool_allocator</span>\n<span class=\"p\">{</span>\n\t<span class=\"n\">legacy_memory_pool</span><span class=\"o\">&amp;lt;</span><span class=\"n\">Allocator</span><span class=\"p\">,</span> <span class=\"n\">DefaultSize</span><span class=\"o\">&amp;gt;</span> <span class=\"n\">memory_pool</span><span class=\"p\">;</span>\n\n<span class=\"k\">public</span><span class=\"o\">:</span>\n\t<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">size_t</span> <span class=\"n\">DEFAULT_ALLOC_BLOCK_SIZE</span> <span class=\"o\">=</span> <span class=\"n\">DefaultSize</span> <span class=\"o\">-</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">__alloc</span><span class=\"p\">()</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">memory_pool</span><span class=\"p\">.</span><span class=\"k\">template</span> <span class=\"n\">alloc</span><span class=\"o\">&amp;lt;</span><span class=\"n\">T</span><span class=\"o\">&amp;gt;</span><span class=\"p\">();</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">__alloc_array</span><span class=\"p\">(</span><span class=\"n\">uint</span> <span class=\"n\">count</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">memory_pool</span><span class=\"p\">.</span><span class=\"k\">template</span> <span class=\"n\">alloc_array</span><span class=\"o\">&amp;lt;</span><span class=\"n\">T</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">count</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"p\">,</span> <span class=\"k\">class</span> <span class=\"err\">... </span><span class=\"nc\">TArgs</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">__alloc_args</span><span class=\"p\">(</span><span class=\"n\">TArgs</span> <span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">memory_pool</span><span class=\"p\">.</span><span class=\"k\">template</span> <span class=\"n\">alloc_args</span><span class=\"o\">&amp;lt;</span><span class=\"n\">T</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">args</span><span class=\"p\">...);</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"p\">,</span> <span class=\"k\">class</span> <span class=\"err\">... </span><span class=\"nc\">TArgs</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">__alloc_array_args</span><span class=\"p\">(</span><span class=\"n\">uint</span> <span class=\"n\">count</span><span class=\"p\">,</span> <span class=\"n\">TArgs</span> <span class=\"p\">...</span> <span class=\"n\">args</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">memory_pool</span><span class=\"p\">.</span><span class=\"k\">template</span> <span class=\"n\">alloc_array_args</span><span class=\"o\">&amp;lt;</span><span class=\"n\">T</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">count</span><span class=\"p\">,</span> <span class=\"n\">args</span><span class=\"p\">...);</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"kt\">bool</span> <span class=\"n\">__free</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">memory_pool</span><span class=\"p\">.</span><span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"o\">&amp;gt;</span>\n\t<span class=\"kt\">bool</span> <span class=\"n\">__free_array</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">t</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">memory_pool</span><span class=\"p\">.</span><span class=\"n\">free_array</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"kt\">size_t</span> <span class=\"n\">DefaultSize</span> <span class=\"o\">=</span> <span class=\"n\">default_allocator</span><span class=\"o\">&amp;lt;&amp;gt;::</span><span class=\"n\">DEFAULT_ALLOC_BLOCK_SIZE</span><span class=\"o\">&amp;gt;</span>\n<span class=\"k\">using</span> <span class=\"n\">memory_pool</span> <span class=\"o\">=</span> <span class=\"n\">legacy_memory_pool</span><span class=\"o\">&amp;lt;</span><span class=\"n\">legacy_memory_pool_allocator</span><span class=\"o\">&amp;lt;</span><span class=\"n\">default_allocator</span><span class=\"o\">&amp;lt;&amp;gt;</span><span class=\"p\">,</span> <span class=\"n\">DefaultSize</span><span class=\"o\">&amp;gt;&amp;gt;</span><span class=\"p\">;</span>\n</code></pre></div><p>在内存池基础上构建新的内存池，颇有递归的味道。</p><h3>六、单元测试</h3><p>进入最后的环节——测试环节。</p><p>运行测试的过程真是战战兢兢，因为一开始全是未通过。不过测试的过程中也发现了代码中的疏漏。</p><h2>源码</h2><p>文章：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/learnstl/blob/master/chapter/01/Memory.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bajdcc/learnstl<i class=\"icon-external\"></i></a></p><p>源码：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/learnstl/blob/master/code/01/memory.h\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/learn</span><span class=\"invisible\">stl/blob/master/code/01/memory.h</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></p><h2>参考</h2><p><a href=\"http://link.zhihu.com/?target=http%3A//blog.codinglabs.org/articles/a-malloc-tutorial.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CodingLabs - 如何实现一个malloc<i class=\"icon-external\"></i></a><br></p><h2>总结</h2><p>万里长征只走了第一步，继续努力！下一章可以实现变长数组vector了。</p>","updated":"2017-01-12T14:50:00.000Z","canComment":false,"commentPermission":"anyone","commentCount":4,"collapsedCount":0,"likeCount":2,"state":"published","isLiked":false,"slug":"24854976","isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic1.zhimg.com/v2-ee5d7b624e196d1880fe4fb946dcc284_r.png","links":{"comments":"/api/posts/24854976/comments"},"reviewers":[],"topics":[{"url":"https://www.zhihu.com/topic/19593616","id":"19593616","name":"编程学习"},{"url":"https://www.zhihu.com/topic/19584970","id":"19584970","name":"C++"},{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"}],"titleImageSize":{"width":0,"height":0},"href":"/api/posts/24854976","excerptTitle":"","column":{"slug":"learncpp","name":"从零开始构建标准库"},"tipjarState":"inactivated","sourceUrl":"","pageCommentsCount":4,"snapshotUrl":"","publishedTime":"2017-01-12T22:50:00+08:00","url":"/p/24854976","lastestLikers":[{"profileUrl":"https://www.zhihu.com/people/cking-31","bio":"it工程师","hash":"008499ee63ecc4b85bbde79f3f8da42f","uid":624873062756257800,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"cking-31","avatar":{"id":"472b0b0cca5778be6ba62fad91bf6320","template":"https://pic1.zhimg.com/{id}_{size}.png"},"name":"cking"},{"profileUrl":"https://www.zhihu.com/people/bu-xiang-tian-18-51","bio":null,"hash":"091e68843d140a4bb632c70ac5eb03ed","uid":680912136071417900,"isOrg":false,"description":"","isOrgWhiteList":false,"slug":"bu-xiang-tian-18-51","avatar":{"id":"c59f2fd6df6532da7ab1d2f264ca1288","template":"https://pic1.zhimg.com/{id}_{size}.jpg"},"name":"不想填"}],"summary":"第一章：内存管理地位程序=数据结构+算法，总体还是围绕内存进行各种操作。偌大的一块内存令人茫然，如同空白的棋盘一样，令人无从下手。然而，下棋有固定的套路，管理内存亦然。管理一块内存，粗看看是简单的活儿，但实际中体会一遍过后就感觉不那么简单。…","reviewingCommentsCount":0,"meta":{"previous":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic1.zhimg.com/v2-079a7c4b8298816df507791d43462d88_r.jpg","links":{"comments":"/api/posts/24736903/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"},{"url":"https://www.zhihu.com/topic/19593616","id":"19593616","name":"编程学习"},{"url":"https://www.zhihu.com/topic/19584970","id":"19584970","name":"C++"}],"href":"/api/posts/24736903","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<h2>序</h2><p>标准库STL庞大且复杂，很多内容从boost库吸收而来。要想得心应手，绝非一朝一夕。</p><p>起初，我们远眺这座大山，感觉它高不可攀。但心中始终有一个信念：九层之台，起于累土；千里之行，始于足下！<br></p><p>从最简单的cout，到vector，到iterator，到transform，……，我们翻过一座座山峦，不断向高峰进发，志在必得！<br></p><p>最后，于最高峰，回顾以往的点点滴滴，感慨万千。<br></p><p>不断造轮子，一方面对先前的知识进行巩固、查漏补缺，另一方面锻炼自己的编程能力。更有甚者，让别人也高兴地用上了自己造的轮子。<br></p><p>精益求精，方可匠心独运。<br></p><h2>目录</h2><ul><li><a href=\"https://zhuanlan.zhihu.com/p/24854976\" class=\"internal\">第一章：内存管理</a><br></li><li><a href=\"https://zhuanlan.zhihu.com/p/24928430\" class=\"internal\">第二章：变长数组（一）</a><br></li></ul><h2>书写顺序</h2><p>这个轮子是有难度的，好在有许多优秀代码可以参考。</p><p>我们从零开始，手写属于自己的STL库，手写属于自己的注释（hey，这是关键），手写属于自己的细节（我想怎么改就怎么改）。</p><p>目前想到的书写顺序有：</p><ol><li>建立自己的type</li><li>语义化测试用例框架</li><li>向量vector，常用操作</li><li>迭代器，用于遍历</li><li>仿函数，各种指针的包装，智能指针</li><li>字符串string，常用操作</li><li>流及包装</li><li>typelists（参考自《C++设计新思维》）</li><li>LINQ功能的实现</li><li>GC垃圾收集，内存池</li><li>一些其他的数据结构</li><li>一些排序算法</li><li>一些查找算法</li><li>正则表达式</li><li>反射与注解</li><li>XML与JSON的解析</li><li>Win32的GUI封装（DirectUI）</li><li>对多线程的封装，包括同步与互斥对象</li><li>对socket的封装</li><li>综合应用</li></ol><h2>项目地址</h2><p><a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/learnstl\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/learn</span><span class=\"invisible\">stl</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a><br></p><p>不断努力！</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":24736903,"publishedTime":"2017-01-05T19:43:19+08:00","url":"/p/24736903","title":"造轮子系列（零）——序","summary":"序标准库STL庞大且复杂，很多内容从boost库吸收而来。要想得心应手，绝非一朝一夕。起初，我们远眺这座大山，感觉它高不可攀。但心中始终有一个信念：九层之台，起于累土；千里之行，始于足下！ 从最简单的cout，到vector，到iterator，到transform，……，…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0},"next":{"isTitleImageFullScreen":false,"rating":"none","titleImage":"https://pic2.zhimg.com/v2-d05d41e5c2080b4e75613c8cf074f435_r.png","links":{"comments":"/api/posts/24928430/comments"},"topics":[{"url":"https://www.zhihu.com/topic/19601705","id":"19601705","name":"C / C++"},{"url":"https://www.zhihu.com/topic/19584970","id":"19584970","name":"C++"},{"url":"https://www.zhihu.com/topic/19593616","id":"19593616","name":"编程学习"}],"href":"/api/posts/24928430","excerptTitle":"","author":{"profileUrl":"https://www.zhihu.com/people/bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","isOrgWhiteList":false,"slug":"bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"name":"陈安"},"column":{"slug":"learncpp","name":"从零开始构建标准库"},"content":"<h1>第二章：变长数组（一）</h1><h2>地位</h2><p>变长数组是比较基础的数据结构，对初学者而言，是它是它就是它！</p><p>假如没有循环语句去遍历，那么数组也就不会那么广为人知。数组在生活中也有体现，如报表、清单等等，它意味着连续的空间。大家知道内存其实就是一片连续的空间，所以内存也是一个巨大的数组，不过由于某种原因，你只能访问有限的空间。</p><p>静态分配的定长数组，那没问题，它长度永远不变，在编译期就可以安排好，没毛病。不过定长数组功能有限，假如要读取全班成绩，没读到尾巴之前，谁也不知道有多少个学生。除非知道了大致的学生总数，先分配空间；否则定长数组就无用武之地。</p><p>为了解决定长数组的局限性，变长数组应运而生。说是变长，其实是“假”变长。先分配好空间，结果空间不够了，这时候就尴尬了：“老大，留还是撤？”。留的话，不知道后面还有没有空间，结果生死未卜；战略转移的话，很有可能找到新家，就这样决定了！</p><p>怎么个“战略转移”法？就是找处新地方，将原来的数据搬过去。</p><h2>基础</h2><h3>向量</h3><p>在这里，类名是<em>vector</em>即向量。</p><p>了解一下向量的基本操作：</p><ul><li><p>增：插入至头，插入至中间，添加至末尾，插入连续的数据</p></li><li><p>删：删除头、尾、中间、连续区域</p></li><li><p>改：修改数据，修改预设大小</p></li><li><p>查：查询某个位置的数据，获取数组的有效长度</p></li></ul><p>本节是第一节，主要介绍vector的基本功能。后续“增删改查”的环节会添加迭代器。</p><h2>思路</h2><p>在先前的内存池基础上实现简单的vector。</p><h2>详解</h2><h3>一、再分配</h3><p>补上先前缺少的重新分配内存方法。</p><p>思路：在内存池中查找指定大小的块，如果没有就报错，如果有的话，就搬运这些数据，最后把原有内存释放。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span> <span class=\"c1\">// 重新分配内存</span>\n<span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"nf\">_realloc</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">uint</span> <span class=\"n\">newSize</span><span class=\"p\">,</span> <span class=\"n\">uint</span> <span class=\"n\">clsSize</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t<span class=\"n\">block</span> <span class=\"o\">*</span><span class=\"n\">blk</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&amp;lt;</span><span class=\"n\">block</span><span class=\"o\">*&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n\t<span class=\"o\">--</span><span class=\"n\">blk</span><span class=\"p\">;</span> <span class=\"c1\">// 自减得到块的元信息头</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">verify_address</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">))</span>\n\t\t<span class=\"k\">return</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">block_align</span><span class=\"p\">(</span><span class=\"n\">newSize</span> <span class=\"o\">*</span> <span class=\"n\">clsSize</span><span class=\"p\">);</span> <span class=\"c1\">// 计算新的内存大小</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">_new</span> <span class=\"o\">=</span> <span class=\"n\">_alloc</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span>\n\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">_new</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"c1\">// 空间不足</span>\n\t\t<span class=\"n\">_free</span><span class=\"p\">(</span><span class=\"n\">blk</span><span class=\"p\">);</span>\n\t\t<span class=\"k\">return</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">auto</span> <span class=\"n\">oldSize</span> <span class=\"o\">=</span> <span class=\"n\">blk</span><span class=\"o\">-&amp;gt;</span><span class=\"n\">size</span><span class=\"p\">;</span>\n\t<span class=\"n\">memmove</span><span class=\"p\">(</span><span class=\"n\">_new</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">__min</span><span class=\"p\">(</span><span class=\"n\">oldSize</span><span class=\"p\">,</span> <span class=\"n\">size</span><span class=\"p\">));</span> <span class=\"c1\">// 移动内存</span>\n\t<span class=\"n\">_free</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n\t<span class=\"k\">return</span> <span class=\"n\">_new</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>二、设置参数</h3><p>设置一些参数。</p><br><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">namespace</span> <span class=\"n\">vector_config</span>\n<span class=\"p\">{</span>\n\t<span class=\"c1\">// 最大空间</span>\n\t<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">size_t</span> <span class=\"n\">FULL_SIZE</span> <span class=\"o\">=</span> <span class=\"mh\">0x100000</span><span class=\"p\">;</span>\n\t<span class=\"c1\">// 共用内存池</span>\n\t<span class=\"k\">static</span> <span class=\"n\">memory</span><span class=\"o\">::</span><span class=\"n\">memory_pool</span><span class=\"o\">&amp;lt;</span><span class=\"n\">FULL_SIZE</span><span class=\"o\">&amp;gt;</span> <span class=\"n\">mem</span><span class=\"p\">;</span>\n\n\t<span class=\"c1\">// 默认总容量</span>\n\t<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">size_t</span> <span class=\"n\">DEF_SIZE</span> <span class=\"o\">=</span> <span class=\"mh\">0x10</span><span class=\"p\">;</span>\n\t<span class=\"c1\">// 默认递增容量</span>\n\t<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">size_t</span> <span class=\"n\">ACC_SIZE</span> <span class=\"o\">=</span> <span class=\"mh\">0x10</span><span class=\"p\">;</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><h3>三、向量</h3><p>目前只实现了向量的核心部分。</p><p>往向量中添加数据的时候，如果可用空间不够了，就去向内存池申请更大的一片空间。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"c1\">// 向量（变长数组）</span>\n<span class=\"k\">template</span><span class=\"o\">&amp;lt;</span><span class=\"k\">class</span> <span class=\"nc\">T</span><span class=\"o\">&amp;gt;</span>\n<span class=\"k\">class</span> <span class=\"nc\">vector</span>\n<span class=\"p\">{</span>\n\t<span class=\"k\">using</span> <span class=\"n\">data_t</span> <span class=\"o\">=</span> <span class=\"n\">T</span><span class=\"p\">;</span>\n\n\t<span class=\"kt\">size_t</span> <span class=\"n\">capacity</span><span class=\"p\">;</span> <span class=\"c1\">// 所有空间</span>\n\t<span class=\"kt\">size_t</span> <span class=\"n\">used</span><span class=\"p\">;</span> <span class=\"c1\">// 已用空间</span>\n\t<span class=\"kt\">size_t</span> <span class=\"n\">acc</span><span class=\"p\">;</span> <span class=\"c1\">// 每次递增大小</span>\n\n\t<span class=\"n\">data_t</span> <span class=\"o\">*</span><span class=\"n\">data</span><span class=\"p\">;</span> <span class=\"c1\">// 数据</span>\n\n\t<span class=\"kt\">void</span> <span class=\"nf\">extend</span><span class=\"p\">()</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"n\">capacity</span> <span class=\"o\">+=</span> <span class=\"n\">acc</span><span class=\"p\">;</span>\n\t\t<span class=\"c1\">// 注意：扩充容量时，原有数据失效！</span>\n\t\t<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">vector_config</span><span class=\"o\">::</span><span class=\"n\">mem</span><span class=\"p\">.</span><span class=\"n\">realloc</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\n<span class=\"k\">public</span><span class=\"o\">:</span>\n\n\t<span class=\"n\">vector</span><span class=\"p\">()</span>\n\t\t<span class=\"o\">:</span> <span class=\"n\">capacity</span><span class=\"p\">(</span><span class=\"n\">vector_config</span><span class=\"o\">::</span><span class=\"n\">DEF_SIZE</span><span class=\"p\">)</span>\n\t\t<span class=\"p\">,</span> <span class=\"n\">used</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\t\t<span class=\"p\">,</span> <span class=\"n\">acc</span><span class=\"p\">(</span><span class=\"n\">vector_config</span><span class=\"o\">::</span><span class=\"n\">ACC_SIZE</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">vector_config</span><span class=\"o\">::</span><span class=\"n\">mem</span><span class=\"p\">.</span><span class=\"n\">alloc_array</span><span class=\"o\">&amp;lt;</span><span class=\"n\">data_t</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">capacity</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 添加新元素至末尾</span>\n\t<span class=\"kt\">void</span> <span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">obj</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">used</span> <span class=\"o\">&amp;gt;=</span> <span class=\"n\">capacity</span><span class=\"p\">)</span>\n\t\t<span class=\"p\">{</span>\n\t\t\t<span class=\"n\">extend</span><span class=\"p\">();</span>\n\t\t<span class=\"p\">}</span>\n\t\t<span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">used</span><span class=\"o\">++</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">obj</span><span class=\"p\">;</span> <span class=\"c1\">// T类型的赋值拷贝</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 弹出末尾的元素</span>\n\t<span class=\"n\">T</span><span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">pop</span><span class=\"p\">()</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">used</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t\t\t<span class=\"k\">throw</span> <span class=\"s\">\"Empty vector\"</span><span class=\"p\">;</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">forward</span><span class=\"o\">&amp;lt;</span><span class=\"n\">T</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"o\">--</span><span class=\"n\">used</span><span class=\"p\">]);</span> <span class=\"c1\">// 返回右值引用</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 获取元素</span>\n\t<span class=\"n\">T</span><span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">get</span><span class=\"p\">(</span><span class=\"kt\">size_t</span> <span class=\"n\">index</span><span class=\"p\">)</span> <span class=\"k\">const</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">index</span> <span class=\"o\">&amp;gt;=</span> <span class=\"n\">used</span><span class=\"p\">)</span>\n\t\t\t<span class=\"k\">throw</span> <span class=\"s\">\"Invalid index\"</span><span class=\"p\">;</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">forward</span><span class=\"o\">&amp;lt;</span><span class=\"n\">T</span><span class=\"o\">&amp;gt;</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">index</span><span class=\"p\">]);</span> <span class=\"c1\">// 返回右值引用</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 获取最末尾元素</span>\n\t<span class=\"n\">T</span><span class=\"o\">&amp;amp;&amp;amp;</span> <span class=\"n\">top</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">used</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n\n\t<span class=\"c1\">// 得到大小</span>\n\t<span class=\"kt\">size_t</span> <span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"k\">const</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"k\">return</span> <span class=\"n\">used</span><span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><h3>六、单元测试</h3><p>测试了添加和寻址功能，目前没啥问题。</p><h2>源码</h2><p>文章：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/learnstl/blob/master/chapter/02/Vector_I.md\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/learn</span><span class=\"invisible\">stl/blob/master/chapter/02/Vector_I.md</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></p><p>源码：<a href=\"http://link.zhihu.com/?target=https%3A//github.com/bajdcc/learnstl/blob/master/code/02/vector.h\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bajdcc/learn</span><span class=\"invisible\">stl/blob/master/code/02/vector.h</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></p><h2>总结</h2><p>vector的编写过程还算轻松~</p>","state":"published","sourceUrl":"","pageCommentsCount":0,"canComment":false,"snapshotUrl":"","slug":24928430,"publishedTime":"2017-01-17T22:50:23+08:00","url":"/p/24928430","title":"第二章：变长数组（一）","summary":"第二章：变长数组（一）地位变长数组是比较基础的数据结构，对初学者而言，是它是它就是它！假如没有循环语句去遍历，那么数组也就不会那么广为人知。数组在生活中也有体现，如报表、清单等等，它意味着连续的空间。大家知道内存其实就是一片连续的空间，所…","reviewingCommentsCount":0,"meta":{"previous":null,"next":null},"commentPermission":"anyone","commentsCount":0,"likesCount":0}},"commentsCount":4,"likesCount":2,"FULLINFO":true}},"User":{"bajdcc":{"isFollowed":false,"name":"陈安","headline":"专业研究野生技术 https://github.com/bajdcc","avatarUrl":"https://pic4.zhimg.com/v2-cd6d61ad9ef94c41b9e77f8e0f727893_s.jpg","isFollowing":false,"type":"people","slug":"bajdcc","bio":"野生技术菌","hash":"7a228f3d98a5d011f952110c10dc4976","uid":71809588264960,"isOrg":false,"description":"专业研究野生技术 https://github.com/bajdcc","profileUrl":"https://www.zhihu.com/people/bajdcc","avatar":{"id":"v2-cd6d61ad9ef94c41b9e77f8e0f727893","template":"https://pic4.zhimg.com/{id}_{size}.jpg"},"isOrgWhiteList":false,"badge":{"identity":null,"bestAnswerer":null}}},"Comment":{}},"me":{},"global":{},"columns":{"learncpp":{"following":false,"canManage":false,"href":"/api/columns/learncpp","name":"从零开始构建标准库","creator":{"slug":"bajdcc"},"url":"/learncpp","slug":"learncpp","avatar":{"id":"v2-bf63794c542fc73b11e17014b7e0d01d","template":"https://pic2.zhimg.com/{id}_{size}.jpg"},"FULLINFO":false}},"columnPosts":{},"postComments":{},"postReviewComments":{"comments":[],"newComments":[],"hasMore":true}}</textarea>

    <script src="//static.zhihu.com/hemingway/common.ac46319b23e12700340a.js"></script>
<script src="//static.zhihu.com/hemingway/app.47dccfede9fcf0800757.js"></script>
<script src="//static.zhihu.com/hemingway/raven.ccdadd4407812d1aac2f.js" async defer></script>
  </body>
</html>
