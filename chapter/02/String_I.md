# 第二章：字符串（一）

## 前言

字符串存放的就是字符数组，简而言之，就是Vector\<char\>这样的类型。对数组的管理统统交给Vector类去实现。

本系列实验，编译器用GCC，IDE用Clion。

## 介绍

**<u>私有数据</u>**

- 字符数组：Vector\<T\>

**<u>公有方法</u>**

- 构造函数
  - 无参
  - 带裸指针，以\\0结尾
  - 带填充字符及长度
  - 拷贝构造
- Get方法
  - 字符串长度
  - 裸指针
  - 字符寻址
- Set方法
  - 用下标形式修改，如str\[0\] = 1
- 常用方法
  - 运算符重载，参考标准库
  - compare比较函数
  - substr取子串，引申的left、mid、right方法
  - add添加字符
  - insert插入字符
  - remove删除指定位置的字符
  - erase清除指定字符
  - clear清空
  - reserve预留缓冲区空间
  - reverse翻转
  - split分割
  - find系列函数，此处略

## 代码

由于知乎系统中的405错误，所以此处<u>不贴代码</u>，详情移步：

- [string.h](https://github.com/bajdcc/learnstl/blob/master/code/02b/string.h)
- [vector.h](https://github.com/bajdcc/learnstl/blob/master/code/02b/vector.h)

## 编写中出现的问题

**<u>打印出多余字符</u>**

这是不论新手老手都会忽略的问题，当我们处理出内存的申请与释放后，字符串的修改可以有条不紊进行。然而，当我们要对字符串进行打印输出时，就忽略了字符串的**终止符**。所以恍然大悟：我并没有去考虑终止符！

这个问题比较难找，因为当输出一堆无关字符后，我会下意识认为内存管理出错了，然而并没有找到一丝问题。后面才想到终止符的问题。

那么我的设计是：当你每次修改完字符串后，就立马设置终止符\\0。操作包括：增加和删除。而字符串拷贝不必做，因为Vector初始化时当将所有内容置0。

**<u>常函数的问题</u>**

这个问题由上面的问题引申而来，当我们要设置\\0时，需要注意，\\0并不在字符串的有效范围中。由abc字符串，现在length是3，并不会包括终止符，因此只能采用开挂的方式解决。

按正常处理，当对Vector寻址时，它会做越界检查，因此这方法没用。如果只能用Vector的get_data取得裸指针，将其const属性去除掉，再进行修改。虽然说违反了一些规定，但实现没有办法。一者，我不希望弄个友元类；二者，如果不借助Vector去管内存，而是String类自己管，又会有一些代码重复的事出现。不过一般情况下不会有人用const_cast，就算人家想用，你怎么限制都是木有用的。假如我直接修改内存好了，那些private、const方法没有丝毫限制作用。

**<u>API设计的问题</u>**

关于String类的接口设计，代码中已经说明了，我搞一堆find系列函数就数起来有16个Orz，说不准加起来一堆有128个。。恨不等用宏去搞，然而宏又不便于调试。。

所以还是将replace和search独立开来，用专门的正则表达式类去实现。

## 代码中涉及的知识

掌握等级：

1. 基础
2. 进阶
3. 高阶

列表：

- C
   1. (Lv.1)ifndef宏
   2. (Lv.1)include
   3. (Lv.1)指针
   4. (Lv.1)static
   5. (Lv.1)sizeof
   6. (Lv.1)移位 <<=
   7. (Lv.2)calloc, free, realloc
   8. (Lv.2)memcpy, memmove
   9. (Lv.2)assert断言
- C++
   1. (Lv.1)数据与方法
   2. (Lv.1)访问范围 public private
   3. (Lv.1)const修饰
   4. (Lv.1)auto
   5. (Lv.2)引用
   6. (Lv.2)运算符重载，包括下标、比较、四则、赋值、类型转换等，以及友元重载
   7. (Lv.2)\[C++11]委托构造函数
   8. (Lv.2)\[C++11\]using别名
   9. (Lv.3)类模版

## 后续目标

1. 用string来实现stream
2. **实现正则表达式**